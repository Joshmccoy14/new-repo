#Requires AutoHotkey v1
#InstallKeybdHook
#NoEnv
#SingleInstance Force
SendMode Input
SetWorkingDir %A_ScriptDir%

SetBatchLines -1
CoordMode, ToolTip, Screen
CoordMode, Mouse, Screen
;SetKeyDelay, %KeyDelayPress%, %KeyDelayDuration%
; DetectHiddenWindows, off

; Set proper file encoding to prevent INI corruption
FileEncoding, UTF-8
; Request admin privileges
; if not A_IsAdmin
; {
;     Run *RunAs "%A_ScriptFullPath%"
;     ExitApp
; }
; ------------------------------------
; Helper to ensure our target game window is active
; ActivateGameWindow() {
;     global win1
;     if (TargetGameWindow) {
;         WinActivate, ahk_id %win1%
;         Sleep, 30
;     }
; }
; ------------------------------------
; Death detection patterns
global iniFile := A_ScriptDir "\CapturedText.ini"
global CapturedTextINI := A_ScriptDir "\CapturedText.ini"
Global WaypointGUIs := {} ; Map of waypoint indices to GUI names
Global WaypointSize := 15
Global PlacingWaypointMode := false
Global ShowWaypoints := true ; Show/hide waypoints
Global CreatingGUI := false ; Flag to prevent update conflicts during GUI creation
Global WaypointBeingDragged := false ; Track if a waypoint is being dragged
Global DraggedWaypointIndex := 0 ; Track which waypoint is being dragged

global RandomKeyDelayMin := 75
global RandomKeyDelayMax := 100
global RandomKeyPressDurationMin := 65
global RandomKeyPressDurationMax := 90
global CurrentKeyDelay := 0
global CurrentPressDuration := 0

; Set initial random KeyDelay
Global WasWindowActive := true
Global LastStuckCheckTime := 0
Global LastStuckCheckX := 0
Global LastStuckCheckY := 0
Global StuckMoveAttempts := 0
Global IsExecutingCommand := false
;SetRandomKeyDelay()
global usegodmotherbottle := "|<>*106$151.0000000000000000000000000000000000000000000000000000X00DU3361800T1003k4Y00000lU0AE1Vb0Y0080001A2K00000MrSA3rkvjvnr4DLZsazzS0000ASNa3CMLwdD+3kenUSnhtU0006DznDbA/SIbx13p/s9tqzk00U36y1Vna4j+HkUX+b74QvS00Dz0nb0Mtn27Z9sEFZFVWSIj407s0TSy7rj11Sorc8ScbVtvSy03w0200000000000000E0000001zs000000000000000M000000Tzzzzzzzzzzzzzzzzzzzzzzzzzzk"
usegodmotherbottle .= "|<>*120$151.0000000000000000000000000000000000000000000000000000008k03s0UlUG007kE00w19000004M0340MNk/0020000H0YU00002BrX0xwCvzwzl3ztS9jzLU00037aNUna5z+nnUwDgs7gdCM0001Xzwntn2rZNzkEzmz2SIjw0000FbUMQtV/mgwM8ntll7+HU00008Vk6CQkVtKSA4NwMMXZ9k00007rj1xvsErhBu27e9sSSqj3zy00U00000000000004000011"
global HVpass:="|<>EAD596-0.81$29.0000000000000Q001sy01kTw0MTzx4Dzzu0Tzzs7zzzmjzzzkDT8Tk0zM7U1zJz0lcDm1U60A01sDg0A7k803s0E1w00kT000bk000Q000000000000000001"
global hvout := false
; Resurrection settings
global ResurrectionEnabled := false
global MaxResurrections := 8
global CurrentResurrections := 0
global DeathCheckActive := false

; ========= AutoOracle Variables =========
global HealthPattern := "|<>##000000$0/0/00AA90,1/0/00AA90"
HealthPattern .= "|<>##000000$0/0/42D019"
healthpattern.= "|<>##0.90$0/0/51CA2F,0/1/48C723,0/2/42D019,0/3/25A800,0/4/259F00"

global BoundingBoxes := []
global PlayerCoords := []
global PetCoords := []

; Portrait patterns
global playerinparty:= "|<magus>F9FEFA-0.90$18.1zsMDy0Ty3zzC1zE0z04T0AD0MD1kD3UB3UB3U91U930E40U810E00U"
playerinparty.= "|<Corruptor>502668-0.86$18.U010000003zlTaMxkQ3Dz1zz1xb0vr0wP1NX3rp6Ds7/k5705WV7q3U"
playerinparty.= "|<Templar>**50$16.DDssyaTeqsOxbyszzrGRnAbBuTJjjSS/X8ANVX6qQOn028"
playerinparty.= "|<voidmage>000002-0.79$18.00000003s0Dw0zw1zo3zo27k63k73k47k47kA3kRbsz7wzzy7zzU"
playerinparty.= "|<deadeye>655593-0.81$18.U0Vy76wDXkzTVyS3ywvpwxfxx3tyLvufnkmG/Ya3qYH78KTE4y0jySU"
playerinparty.= "|<beastmaster>040108-0.90$16.0000000060kTD1zwTzuTzoDksS7kkznDzzzzzzzzU"
playerinparty.= "|<slayer>41444B-0.74$17.0000005U4308VEM3zV5z0bx/7wQ7sy7ky7VyDXyDbyDDy8"
playerinparty.= "|<berserker>DAEEEF-0.70$16.0Q01r06w0Tk1y07l0T43skTz3zETs7zczt3s8D1UU"
playerinparty.= "|<overlord>604160-0.90$16.7zky333gCDkzzXzy7z2Tm8zU1TY68k4P0880U00VU"
playerinparty.= "|<Marksman>*58$18.0D00T00z01y03y06y00w61wDXjznDzb1ya7wASMQwMvkVz06U"
playerinparty.= "|<masterbreeder>A7640B-0.90$16.3U0w43kEM9VUq77wTzkvt3yM7s08s0FI022"
; Portrait patterns
global magus := "|<>F9FEFA-0.90$18.1zsMDy0Ty3zzC1zE0z04T0AD0MD1kD3UB3UB3U91U930E40U810E00U"
global Corruptor := "|<>502668-0.86$18.U010000003zlTaMxkQ3Dz1zz1xb0vr0wP1NX3rp6Ds7/k5705WV7q3U"
global Templar :="|<>**50$16.DDssyaTeqsOxbyszzrGRnAbBuTJjjSS/X8ANVX6qQOn028"
global voidmage:="|<>000002-0.79$18.00000003s0Dw0zw1zo3zo27k63k73k47k47kA3kRbsz7wzzy7zzU"
global deadeye:="|<>655593-0.81$18.U0Vy76wDXkzTVyS3ywvpwxfxx3tyLvufnkmG/Ya3qYH78KTE4y0jySU"
global beastmaster:="|<>040108-0.90$16.0000000060kTD1zwTzuTzoDksS7kkznDzzzzzzzzU"
global slayer:="|<>41444B-0.74$17.0000005U4308VEM3zV5z0bx/7wQ7sy7ky7VyDXyDbyDDy8"
global berserker:="|<>DAEEEF-0.70$16.0Q01r06w0Tk1y07l0T43skTz3zETs7zczt3s8D1UU"
global overlord:="|<>604160-0.90$16.7zky333gCDkzzXzy7z2Tm8zU1TY68k4P0880U00VU"
global masterbreeder:="|<>A7640B-0.90$16.3U0w43kEM9VUq77wTzkvt3yM7s08s0FI022"
global Marksman := "|<>*58$18.0D00T00z01y03y06y00w61wDXjznDzb1ya7wASMQwMvkVz06U"

global petsinparty := "|<windpixie>AEAD43-0.69$18.0400A00A00A0UA0sS0sS0kQ1xR1vTHNz7VTDlRDsQTwATsAMwANU"
petsinparty.= "|<gnoll>887868-0.74$17.uXZk7bE2L0SR1IwBVtHnakj1lT6rsr3lpL/pT+kz5LyHLzITk"
petsinparty.= "|<etherealpixie>CA4EB0-0.73$18.0400400A00800800+00S00Q04Q12TH0z7UTDUQDsATwATsAMwAMU"

global windpixie := "|<>AEAD43-0.69$18.0400A00A00A0UA0sS0sS0kQ1xR1vTHNz7VTDlRDsQTwATsAMwANU"
global gnoll := "|<>887868-0.74$17.uXZk7bE2L0SR1IwBVtHnakj1lT6rsr3lpL/pT+kz5LyHLzITk"
global etherealpixie := "|<>CA4EB0-0.73$18.0400400A00800800+00S00Q04Q12TH0z7UTDUQDsATwATsAMwAMU"
global partywindow := "|<>*142$15.Tzszy80azus0yzvqvSuvrjSuvqvTTrxxymPjjjzzzzw"
partywindow .= "|<>FFFFFF-0.90$13.E17z40GF954V2FF94W0UUVBZ11U"
global partywindowlogo := "|<>*137$16.TzwTz208rzLU3xzrqvTRRxvrrLTPhyzjxxzNBvvvU"

; Global variables for patterns

global patterns := {} ; Store all loaded patterns in this object
global patternKeys := {} ; Store key assignments for each pattern
global patternNames := {} ; Store custom names for each pattern
global patternCounter := 1 ; Counter for automatic pattern naming
global HealerStatusText := ""
global healControlCounter := 1 ; Counter for heal control naming
global TargetGameWindow := "" ; Store target game window ID
global TargetGameTitle := "" ; Store target game window title
global TargetGamePID := "" ; Store target game window PID
global CriticalModeEnabled := false ; Track Critical mode state
global healPriorities := [] ; Array to store heal skill priority order
global healCheckInterval := 30 ; Heal check interval in milliseconds
global healThresholdPercent := 95 ; Percentage of health to trigger healing (95% = heal when health < 95%)
global healanddps := false
global dpstargetedhealing := false
; Heal ground targeting variables
global healGroundTargetSkills := {} ; Store which heal skills are ground-targeted
global healGroundTargetCoords := {} ; Store ground target click coordinates for each heal skill
; Heal pre-cast key variables
global healPressKeyBeforeCast := {} ; Store whether to press key before casting heal
global healPreCastKeys := {} ; Store the key to press before casting heal
; Manual healing variables
global PlayerCount := 0
global PetCount := 0
global ManualPlayerCoords := []
global ManualPetCoords := []
global isManualHealingActive := false
; DPS targeted healing variables
global DPSTargetedPlayerCoords := []
global DPSTargetedPetCoords := []
; ========= DPS Variables =========
global dpsPatterns := {} ; Store all DPS patterns
global dpsPatternKeys := {} ; Store key assignments for DPS patterns
global dpsPatternNames := {} ; Store custom names for DPS patterns
global dpsGroundTargetSkills := {} ; Store which skills are ground-targeted
global dpsGroundTargetCoords := {} ; Store ground target click coordinates for each skill
global dpsPressKeyBeforeCast := {} ; Store whether to press key before casting
global dpsPreCastKeys := {} ; Store the key to press before casting
global dpsCounter := 1 ; Counter for automatic DPS pattern naming
global dpsPriorities := [] ; Array to store skill priority order
global isDpsRunning := false ; Flag for DPS monitoring
global isSystemBusy := false ; Flag to coordinate between healing/DPS/keypresser
; Melee attack variables
global meleeAttackEnabled := false ; Flag for melee attack after skill cast
global refreshscrollEnabled := false ; Flag for refresh scroll
global meleeAttackKey := "" ; Key to press for melee attack
global refreshkey := "" ; Key to press for refresh scroll
global ccPatterns := {} ; Store all CC patterns
global ccPatternKeys := {} ; Store key assignments for CC patterns
global ccPatternNames := {} ; Store custom names for CC patterns
global ccStunDurations := {} ; Store stun durations for CC patterns
global ccTypes := {} ; Store CC types (aoe or single)
global ccCounter := 1 ; Counter for automatic CC pattern naming
global ccPriorities := [] ; Array to store skill priority order
global isccRunning := false ; Flag for CC monitoring
global lastAoeCCTime := 0 ; Track when last AoE CC was used
global aoeCCCooldown := 0 ; Duration until next AoE CC can be used
; QWERTY to QWERTZ conversion
global qwertzModeEnabled := false ; Flag for QWERTY to QWERTZ key conversion
; Define healing skill patterns
global healing := "|<>**50$13.txUTU30CA0A3I68EQ8C6N37Vckk8E"
global restoration := "|<>**50$13.03U000402010DUQEMcSQC2C064XME"
global rapidhealing := "|<>**50$13.Y5C6wCC5i3t38UMEM9d1U000Q1e+E"
global masshealing := "|<>**50$13.R4/07Z3m01CA4C65X2rV5EzsFw83k"
;other globals
global TemplarTargetCount := 1
global TemplarTargetCoords := []
global HolygroundHotkey := ""
global TemplarTargetCountEdit := ""
global HolygroundHotkeyEdit := ""
global RandomXVariation := 5
global RandomYVariation := 5
global MinDelay := 80
global MaxDelay := 150
global activeMonitors := 0
global maxMonitors := 8
global gnollbuff := false
global dtbuff := false
global destroypotions := false
; Pet buff pattern arrays
global gnollPatterns := []
global deathTyrantPatterns := []
; Pet buff timer intervals (in milliseconds)
global gnollBuffInterval := 1800000 ; 30 minutes default
global dtBuffInterval := 3600000 ; 60 minutes default

; Pet buff image patterns for detection
global gnollBuffImagePattern := "" ; Reflecting Shield image pattern
global dtBuffImagePattern := "" ; Monarch image pattern
global customSummonPattern := "" ; Custom summon pattern
global summonKeybind := "+=" ; Default: Shift+= (can be customized)

; Navigation pause state for pet buff execution
global PetBuffExecuting := false
global NavigationPausedForBuff := false
; Rotate Toggles variables
global RotateToggle1Key := ""
global RotateToggle2Key := ""
global RotateToggleRunning := false
global RotateToggleCurrentKey := 1
global RotateToggleTimer := 35000 ; 35 seconds in milliseconds
; Image Clicker variables
global imageClickerPattern := ""
global imageClickerRunning := false
; Image Clicker variables
global imageClickerPatterns := []
global imageClickerRunning := false

global destroyessences := false
global invclosed := false
; Auto-Dura variables
global autoDuraEnabled := false
global autoDuraInterval := 30 ; 30 minutes default
global repairPattern := "|<>**23$14.007ztzyFWYqdMeQ6aX9pOKvYvNzyTzU02"
repairPattern .="|<>*56$14.007ztzyTXbktsCQ7a3tlSSvbzNzyTzU02"

global DPSHoldHotkey := "" ; saved hotkey string (e.g. F1)
global DPSHotkeyTimerInterval := 200 ; ms
global DPSToggleHotkey := "Insert" ; Default hotkey for start/stop DPS
global autofollowhotkeydefault := "F10"
global autofollowhotkey:= autofollowhotkeydefault 
global selectedKey := "F9" ; Default selection  
hotkey, %autofollowhotkey%, autofollowaction, on
; Set up DPS toggle hotkey
if (DPSToggleHotkey != "")
    hotkey, %DPSToggleHotkey%, ToggleDPSAction, on
global PylonPos1X := ""
global PylonPos1Y := ""
global PylonPos2X := ""
global PylonPos2Y := ""
global PylonSetupActive := false
global PylonClickCount := 0
; Default autofollow hotkey
;global autofollowhotkeydefault := "q"   
; Profile system variables
global CurrentProfileName := "Default"
global BuffProfiles := {}
global ProfileSettingsFile := "buff_profiles.ini"

; ========= Navigation Variables =========
global NavText := "|<0>*95$5.W1nbCQtoTzz"
NavText .= "|<1>*87$5.zzyEtnbCQUz"
NavText .= "|<2>*95$5.zA7jQvivkTz"
NavText .= "|<3>*95$5.zy8DSnXri1z"
NavText .= "|<4>*95$6.zzztldNN0tttzU"
NavText .= "|<5>*95$5.z01nVtvr0zz"
NavText .= "|<6>*95$6.zzlVDT1RQQBVzU"
NavText .= "|<7>*95$4.zk3gqPBry"
NavText .= "|<8>*95$7.lmPhq31i7/g6"
NavText .= "|<9>*95$5.0tnUGxkDzzz"

;============================================

Global win2 := ""
Global win2PID := ""
Global Waypoints := []
Global CurrentWaypoint := 0
Global CameraRadius := 900
Global PixelsPerGameUnitX := 100 / 89
Global PixelsPerGameUnitY := 100 / 43
Global CameraAngle := 0
Global SelectedRouteFile := ""
Global CameraFile := ""
Global IsTraveling := false
Global RouteStatus
global NavTargetGameWindow := ""
global NavTargetGamePID := ""
global NavWaypoints := []
global NavCurrentWaypoint := 0
global NavCameraRadius := 900
global NavPixelsPerGameUnitX := 100 / 89
global NavPixelsPerGameUnitY := 100 / 43
global NavCameraAngle := 0
global NavSelectedRouteFile := ""
global NavCameraFile := ""
global NavIsTraveling := false
global NavWaypointCount := 0
global NavCameraLocked := false
; DPS Navigation variables
global dpsNavEnabled := false
global dpsNavTargetX := ""
global dpsNavTargetY := ""
global dpsNavRadius := 50
; Pylon positioning variables
global pylonPos1X := ""
global pylonPos1Y := ""
global pylonPos2X := ""
global pylonPos2Y := ""
; Coordinate variables for checkweight and snapshot (shared coordinates)
global checkweightX1 := 880
global checkweightY1 := 472
global checkweightX2 := 981
global checkweightY2 := 488
global pylonresetlocationset := false
; ; Define skill bar search area (bottom portion of screen)
; global SkillBarX1 := 92
; global SkillBarY1 := 594
; global SkillBarX2 := 953
; global SkillBarY2 := 755
global SequentialDPSEnabled := false
global CurrentSequentialIndex := 1

; ========= KeyPresser Variables =========
; Global variables

global win1 := ""
global SettingsFile := "keypresser_settings.ini"
global SkipInitial1 := false

; Sequence 1 variables
global KeyCombination1 := ""
global KeyDelay1 := 0.1
global TimerInterval1 := 1
global IsRunning1 := false
global KeySequence1 := []
global NextExecutionTime1 := 0

; Sequence 2 variables
global KeyCombination2 := ""
global KeyDelay2 := 0.1
global TimerInterval2 := 2
global IsRunning2 := false
global KeySequence2 := []
global NextExecutionTime2 := 0

; Sequence 3 variables
global KeyCombination3 := ""
global KeyDelay3 := 0.1
global TimerInterval3 := 3
global IsRunning3 := false
global KeySequence3 := []
global NextExecutionTime3 := 0

; Sequence 4 variables
global KeyCombination4 := ""
global KeyDelay4 := 0.1
global TimerInterval4 := 4
global IsRunning4 := false
global KeySequence4 := []
global NextExecutionTime4 := 0

; Sequence 5 variables
global KeyCombination5 := ""
global KeyDelay5 := 0.1
global TimerInterval5 := 5
global IsRunning5 := false
global KeySequence5 := []
global NextExecutionTime5 := 0

; Sequence 6 variables
global KeyCombination6 := ""
global KeyDelay6 := 0.1
global TimerInterval6 := 6
global IsRunning6 := false
global KeySequence6 := []
global NextExecutionTime6 := 0

; Timer execution flags for waypoint-based execution
global gnollBuffNeeded := false
global dtBuffNeeded := false
global sequence1Needed := false
global sequence2Needed := false
global sequence3Needed := false
global potionDestroyNeeded := false
global duraRepairNeeded := false
global signalCheckCounter := 0

; GUI control variables

global KeyCombinationEdit1 := ""
global KeyDelayEdit1 := ""
global TimerIntervalEdit1 := ""
global KeyCombinationEdit2 := ""
global KeyDelayEdit2 := ""
global TimerIntervalEdit2 := ""
global KeyCombinationEdit3 := ""
global KeyDelayEdit3 := ""
global TimerIntervalEdit3 := ""
global farming := false
global returnafterheal
global CurrentChar := 1
global selectedChars := []
;templar globals
;global iniFile := "templarpuller.ini"
global pullAreas := 3
global clickLocations := 4
global randomOffsetX := 5
global randomOffsetY := 5
global returnSleepTime := 4500
global mouseMoveDelay := 90
global mouseClickDelay := 50
global movementAreaSet := false
global movementX1 := 0, movementY1 := 0, movementX2 := 0, movementY2 := 0
global movementArea2Set := false
global movement2X1 := 0, movement2Y1 := 0, movement2X2 := 0, movement2Y2 := 0
global clickCoords := []
global pullingActive := false
global currentPullArea := 1
global currentClickIndex := 1
global selectedWindow := ""
global PullAreasEdit
global ClickLocationsEdit
global OffsetXEdit
global OffsetYEdit
global SleepTimeEdit
global MovementStatus
global WindowStatus
global StatusText
global MouseMoveDelayEdit
global MouseClickDelayEdit
global MainTabs
Global refreshScrollEndTime := 0
global lastPressTimes := {}
; Add these with your other global variables at the top of your script
; Add these at the very top of your script with other globals
global dpsEnabled := false
global dpsHotkey := "2"
global dpsDuration := 3000
global dpsStatusText
; Key delay variables for randomization
global KeyDelayPress := 100
global KeyDelayDuration := 90
global MonitorWindowID := ""
global BaselineImage := ""
global MonitorActive := false
global movingg := false
global autofolloww := false
global randomdelaymax := 250
global randomdelaymin := 80
global pullHotkey := "1" ; Default value
global templardps := false
; Live calibration variables
Global CalibrationActive := false
Global CalibrationClicks := []
Global CalibrationStartX := 0
Global CalibrationStartY := 0
Global NavigationIniFile := A_ScriptDir "\AdvancedNavigation.ini"
; NEW VARIABLES FOR ENHANCED FEATURES
Global DistanceToleranceX := 50 ; Distance tolerance X
Global DistanceToleranceY := 50 ; Distance tolerance Y
Global MovementMode := "click" ; "click" or "wasd"
Global MaxClickDistance := 140 ; Maximum click distance in pixels
Global WASDKeys := {w: false, a: false, s: false, d: false} ; Track key states
Global WaypointCommands := {} ; Store commands for each waypoint
Global SingleWaypointMode := false ; Track if going to single waypoint vs full route
;Global Farming := false ; Track farming mode status

; Visual nodes for click targeting (multiple nodes)
Global TargetNodes := [] ; Array of node objects {id, worldX, worldY, guiID}
Global NodeGUIs := {} ; Map of node IDs to GUI names
Global NodeSize := 15
Global PlacingNodeMode := false
Global NextNodeID := 1
Global AvailableNodeIDs := [] ; Stack of deleted node IDs to reuse
Global ShowTargetNodes := true ; Show/hide target nodes
Global LastPlayerX := 0 ; Track last position for optimization
Global LastPlayerY := 0
Global NodeBeingDragged := false ; Track if a node is being dragged
Global DraggedNodeID := 0 ; Track which node is being dragged
Global NodeMoveMode := false ; Track if in interactive move mode
Global NodesMovedDuringSession := {} ; Track which nodes were moved during move mode
Global ResourcesINI := A_ScriptDir . "\resources.ini"

; Network client globals
Global Connected := False
Global ClientSocket := -1
Global LastServerAddress := ""
Global LastServerPort := ""

; ========= Initialization =========
; Load saved text patterns when script starts
LoadAllPatterns()
InitializePatternCounter() ; Initialize the counter based on existing patterns
; Load pet buff patterns and timers
LoadPetBuffPatterns()
LoadPetBuffTimers()
; Update GUI labels with loaded timer values
UpdatePetBuffLabels()
; Load auto-dura settings
LoadAutoDuraSettings()
; Load skillbar coordinates
LoadSkillbarCoordinates()
; Load QWERTZ keyboard setting
LoadQWERTZSetting()
; Load custom names into memory at startup
ReloadCustomNames()

; Load heal priorities and settings
LoadHealPriorities()
LoadHealSettings()

; Load DPS patterns and settings
LoadAllDPSPatterns()
LoadDPSPriorities()
LoadAllCCPatterns()
LoadCCPriorities()
;LoadTemplarSettings()
LoadImageClickerSettings()

LoadSettings()
; NOTE: LoadAllCheckboxStates() and GUI control initialization is now called AFTER GUI is created (see line ~809)
CheckPreviousSettings()
LoadWaypoints()
CoordMode, Pixel, Screen
coordmode, mouse, screen

; Auto-load keypresser settings on startup
Gosub, LoadKeypresserSettings

; Load pet buff image settings
Gosub, LoadPetBuffImageSettings

; Load game window settings
LoadGameWindowSettings()

; Load default profile  
LoadDefaultProfile()

; Create the combined GUI
Gosub, CreateCombinedGUI

; Auto-start network server (DISABLED - use GUI button instead)
; SetTimer, AutoStartServer, -1000
return

AutoStartServer:
    ; Auto-start server on port 12345
    hostPort := 12345
    GuiControl,, hostPort, %hostPort%
    If (i := AHKsock_Listen(hostPort, "ServerEvents")) {
        AddLog("ERROR: Auto-start server failed: " i)
    } Else {
        GuiControl,, btnListen, Stop Listening (%hostPort%)
        AddLog("Server auto-started on port " hostPort)
    }
return

AutoConnectToServer:
    ; Auto-connect to server as client
    global Connected, ClientSocket, LastServerAddress, LastServerPort

    ; Only connect if not already connected
    If (Connected || ClientSocket != -1) {
        return
    }

    srvAddress := "localhost"
    srvPort := 12345

    GuiControl,, srvAddress, %srvAddress%
    GuiControl,, srvPort, %srvPort%
    GuiControl,, btnConnect, Connect (%srvAddress%:%srvPort%)

    ; Save for auto-reconnect
    LastServerAddress := srvAddress
    LastServerPort := srvPort

    ; Connect to server
    If (i := AHKsock_Connect(srvAddress, srvPort, "ClientEvents")) {
        AddClientLog("ERROR: Auto-connect failed: " i)
    } Else {
        AddClientLog("Auto-connecting to " srvAddress ":" srvPort "...")
        GuiControl, Disable, btnConnect
    }
return

CreateCombinedGUI:
    ; Create main GUI with tabs (added Templar tab)
    Gui, Add, Tab3, x10 y10 w520 h630 vMainTabs, Setup|Healer|DPS|CC|Buffs|Settings|Navigation|Templar|Network

    ; ===== Setup tab =====
    Gui, Tab, Setup
    ; Window Setup Section
    Gui, Add, GroupBox, x20 y40 w470 h90, Game Setup
    Gui, Add, Button, x30 y60 w120 h30 gSelectWindow, Select Game Window
    Gui, Add, Button, x300 y60 w120 h30 gShowThumbnailView, Show Thumbnail View
    Gui, Add, Text, x160 y65 w130 h20 vWindowStatus, No window selected
    Gui, Add, Button, x30 y95 w80 h25 gLaunchGame, Launch Game
    Gui, Add, Button, x120 y95 w80 h25 gSelectGame, Select Game
    Gui, Add, Button, x210 y95 w80 h25 gCharacters, Characters
    Gui, Add, Button, x300 y95 w80 h25 gpasswordonly, Password

    ; Main Controls Section
    Gui, Add, GroupBox, x20 y140 w490 h125, Main Controls
    Gui, Add, Button, x30 y160 w100 h30 gStartDynamicHealing, Start Healer
    Gui, Add, Button, x140 y160 w100 h30 gCancelHealerScript, Stop Healer
    Gui, Add, Button, x250 y160 w100 h30 gStartDPSScript, Start DPS
    Gui, Add, Button, x360 y160 w100 h30 gStopDPSScript, Stop DPS
    Gui, Add, Checkbox, x30 y200 w170 vhealanddps ghealanddps, Enable DPS + Heal Combo
    Gui, Add, Checkbox, x200 y200 w130 vdpstargetedhealing gdpstargetedhealing, DPS + Targeted Heal
    Gui, Add, Checkbox, x200 y220 w120 vreturnafterheal greturnafterheal, Follow f2 after heal
    Gui, Add, Checkbox, x30 y220 w140 vfarming gfarming, Enable Farming Mode
    gui, add, checkbox, x340 y200 w140 vdestroyskypotionstimer gdestroyskypotionstimer, Destroy Potions (5 mins)
    gui, add, checkbox, x340 y220 w130 vinfinitemouse ginfinitemouse, Infinite Mouse
    Gui, Add, Checkbox, x30 y240 w140 h20 vrefreshscrollEnabled grefreshscrollToggle, Enable refresh scroll (1 Hr)
    Gui, Add, Text, x240 y240 w90 h20 vrefreshScrollTimer, Time left: --:--:--
    Gui, Add, Edit, x180 y240 w50 h20 vrefreshKey grefreshKeyChanged
    GuiControl, Hide, refreshKeyLabel
    GuiControl, Hide, refreshKey
    ; === Chat Buffs Checkbox ===
    Gui, Add, Checkbox, x340 y240 w110 vchatbuff gChatBuffToggle, Enable Chat Buffs
    Gui, Add, Text, x340 y265 w45 h20, Chat Buff 
    Gui, Add, Text, x400 y265 w40 h20 vchatBuffTimeLeft, --:--:--
    Gui, Add, Edit, x450 y240 w40 h20 vchatBuffTimerEdit, 63
    Gui, Add, Button, x450 y265 w40 h20 gSaveChatBuffTimer, Save

    ; Keyboard Layout Section
    ;Gui, Add, GroupBox, x20 y240 w200 h30, Keyboard Layout
    ;gui, add, checkbox, x30 y255 w150 vqwertzmode gqwertzmode, QWERTZ-Keys

    ; Auto-Resurrection Section
    Gui, Add, GroupBox, x20 y280 w470 h70, Auto-Resurrection
    Gui, Add, Checkbox, x30 y300 w150 vResurrectionEnabled gResurrectionEnabled, Enable Auto-Resurrection
    Gui, Add, Checkbox, x190 y300 w150 vhvout gHVout,HV if max res count met
    ;gui, add, button, x200 y270 w80 h20 gtestdeathdetection, Test
    Gui, Add, Text, x30 y320 w120 h20, Max Resurrections:
    Gui, Add, Edit, x150 y320 w50 h20 vMaxResurrectionsEdit
    Gui, Add, Button, x210 y320 w80 h20 gSaveResurrectionSettings, Save Settings
    Gui, Add, Button, x300 y320 w80 h20 gResetResurrections, Reset Count
    Gui, Add, Text, x390 y320 w80 h25 vResurrectionStatus, Count: 0/8

    ;aut dura Section Section
    Gui, Add, GroupBox, x20 y360 w470 h70, Auto-Dura
    Gui, Add, Checkbox, x30 y380 w150 vautodura gautodura, Enable Auto-Dura
    Gui, Add, Text, x190 y380 w90 h20, Timer (minutes):
    Gui, Add, Edit, x280 y380 w40 h20 vautoDuraIntervalEdit, %autoDuraInterval%
    Gui, Add, Button, x330 y380 w60 h20 gSaveAutoDuraInterval, Save
    Gui, Add, Button, x400 y380 w60 h20 gtestduradetection, Test

    ; DPS Navigation Section
    Gui, Add, GroupBox, x20 y440 w470 h80, DPS Navigation
    Gui, Add, Checkbox, x30 y460 w150 vdpsNavEnabled gdpsNavEnabled, Enable DPS Navigation
    Gui, Add, Text, x230 y460 w80 h20, Group Radius:
    Gui, Add, Edit, x300 y460 w40 h20 vdpsNavRadiusEdit, %dpsNavRadius%
    Gui, Add, Text, x30 y485 w20 h20, X:
    Gui, Add, Edit, x50 y485 w60 h20 vdpsNavTargetXEdit
    Gui, Add, Text, x120 y485 w20 h20, Y:
    Gui, Add, Edit, x140 y485 w60 h20 vdpsNavTargetYEdit
    Gui, Add, Button, x210 y485 w80 h20 gSetDPSNavCoords, Set Current
    Gui, Add, Button, x300 y485 w60 h20 gSaveDPSNavCoords, Save

    ; Text Input Section
    Gui, Add, GroupBox, x20 y530 w470 h80, Text Input
    Gui, Add, Edit, x30 y550 w300 h40 vTextInputBox
    Gui, Add, Button, x340 y550 w60 h40 gSendText, Send
    Gui, Add, Button, x410 y550 w60 h40 gClearText, Clear

    ; ===== HEALER TAB =====
    Gui, Tab, Healer
    ; Configuration Section
    Gui, Add, GroupBox, x20 y40 w470 h120, Healing Configuration
    ;Gui, Add, Text, x30 y60 w85 h20, Check Rate (ms):
    ;Gui, Add, Edit, x120 y60 w60 h20 vHealIntervalInput gValidateHealInterval, %healCheckInterval%
    ;Gui, Add, Button, x190 y60 w50 h20 gSaveHealInterval, Save
    Gui, Add, Button, x30 y60 w100 h20 gTestPartyDetection, Test Detection
    ;Gui, Add, Button, x360 y60 w100 h20 gStartDynamicHealing, Auto Healing

    Gui, Add, Text, x30 y85 w100 h20, Heal at Health `%:
    Gui, Add, Edit, x130 y85 w50 h20 vHealThresholdInput gValidateHealThreshold, %healThresholdPercent%
    Gui, Add, Button, x190 y85 w50 h20 gSaveHealThreshold, Save

    ; Manual healing controls
    Gui, Add, Text, x30 y110 w50 h20, Players:
    Gui, Add, Edit, x80 y110 w30 h20 vPlayerCountEdit, 0
    Gui, Add, Text, x120 y110 w30 h20, Pets:
    Gui, Add, Edit, x150 y110 w30 h20 vPetCountEdit, 0
    Gui, Add, Button, x190 y110 w80 h20 gSetManualCoords, Set Coords
    Gui, Add, Button, x280 y110 w80 h20 gStartManualHealing, Manual Heal
    Gui, Add, Button, x370 y110 w80 h20 gStopManualHealing, Stop Manual

    Gui, Add, Text, x30 y135 w450 h20 vHealerSkillbarCoords, Skillbar: Not set - use Tools tab
    Gui, Add, Text, x30 y130 w450 h20 vManualHealStatus, Manual: Not configured

    ; Skill Management Section
    Gui, Add, GroupBox, x20 y170 w470 h140, Skill Management
    Gui, Add, Button, x30 y190 w130 h30 gAddHealingSkill, Add Heal Skill
    Gui, Add, Button, x170 y190 w130 h30 gfindhealingskill, Test Skills
    Gui, Add, Button, x310 y190 w130 h30 gclearskills, Clear All
    Gui, Add, Button, x30 y230 w130 h30 gAssignHealKeys, Assign Keys
    Gui, Add, Button, x170 y230 w130 h30 gRenameHealSkills, Rename Skills
    ;Gui, Add, Button, x310 y230 w130 h30 gShowHealKeysStatus, Show Status
    Gui, Add, Button, x310 y230 w130 h30 gModifyHealSkill, Modify Skill

    ; Priority Management Section
    Gui, Add, GroupBox, x20 y320 w470 h160, Priority Order
    Gui, Add, ListBox, x30 y340 w350 h140 vHealPriorityList gHealPrioritySelect VScroll
    Gui, Add, Button, x390 y340 w80 h25 gMoveHealUp, Move Up
    Gui, Add, Button, x390 y370 w80 h25 gMoveHealDown, Move Down
    Gui, Add, Button, x390 y400 w80 h25 gRemoveFromHealPriority, Remove
    Gui, Add, Button, x390 y430 w80 h25 gAddToHealPriority, Add

    ; Status Section
    Gui, Add, GroupBox, x20 y490 w470 h120, Healer Status
    Gui, Add, Edit, x30 y510 w450 h90 vHealerStatusEdit ReadOnly VScroll

    ; ===== DPS TAB =====
    Gui, Tab, DPS

    ; Hotkey to hold for continuous DPS + DynamicHealthCheck
    Gui, Add, Text, x50 y350 w220 h20, Hold key to loop DPS + Dynamic Heal:
    Gui, Add, Hotkey, x240 y348 w60 h20 vDPSHoldHotkey gDPSHoldHotkey, % DPSHoldHotkey
    Gui, Add, Text, x320 y350 w60 h20, (hold to run)

    ; DPS Start/Stop Toggle Hotkey
    Gui, Add, Text, x50 y372 w180 h20, Start/Stop DPS Toggle Hotkey:
    Gui, Add, Hotkey, x240 y370 w60 h20 vDPSToggleHotkey gDPSToggleHotkeyChanged, %DPSToggleHotkey%
    Gui, Add, Text, x320 y372 w160 h20, (press to start/stop DPS)

    ; Auto Follow Hotkey
    Gui, Add, Text, x50 y394 w180 h20, Auto Follow Hotkey (e.g. F2):
    gui, add, hotkey, x240 y392 w60 h20 vautofollowhotkey gautofollowhotkey, Auto Follow, %autofollowhotkey%
    gui, add, text, x320 y394 w70 h20, Follow Who?
    Gui, Add, DropDownList, x390 y392 w60 h120 vselectedKey gUpdateFollowKey, F2||F3|F4|F5|F6|F7|F8

    ; Melee Attack After Skill Cast
    Gui, Add, Checkbox, x50 y416 w250 h20 vmeleeAttackEnabled gMeleeAttackToggle, Enable Melee After Skill Cast (dps/heal/cc)
    ;ui, Add, Text, x240 y418 w90 h20 vMeleeKeyLabel, Melee Key:
    Gui, Add, Edit, x330 y416 w50 h20 vmeleeAttackKey gMeleeKeyChanged
    GuiControl, Hide, MeleeKeyLabel
    GuiControl, Hide, meleeAttackKey

    ; Force Sequential Mode Checkbox
    Gui, Add, Checkbox, x50 y438 w200 vSequentialDPSMode gSequentialDPSMode, Force Sequential Skill Order

    ; Skill Management Section
    Gui, Add, GroupBox, x20 y40 w470 h110, DPS Skill Management
    Gui, Add, Button, x30 y60 w130 h30 gAddDPSSkill, Add DPS Skill
    Gui, Add, Button, x170 y60 w130 h30 gTestDPSSkills, Test Skills
    Gui, Add, Button, x310 y60 w130 h30 gClearDPSSkills, Clear All
    Gui, Add, Button, x30 y100 w130 h30 gAssignDPSKeys, Assign Keys
    Gui, Add, Button, x170 y100 w130 h30 gRenameDPSSkills, Rename Skills
    Gui, Add, Button, x310 y100 w130 h30 gModifyDPSSkill, Modify Skill

    ; Priority Management Section
    Gui, Add, GroupBox, x20 y160 w470 h140, DPS Priority Order
    Gui, Add, ListBox, x30 y190 w350 h150 vDPSPriorityList gDPSPrioritySelect VScroll
    Gui, Add, Button, x390 y210 w80 h25 gMoveDPSUp, Move Up
    Gui, Add, Button, x390 y240 w80 h25 gMoveDPSDown, Move Down
    Gui, Add, Button, x390 y270 w80 h25 gRemoveFromDPSPriority, Remove
    Gui, Add, Button, x390 y300 w80 h25 gAddToDPSPriority, Add

    ; Status Section
    Gui, Add, GroupBox, x20 y470 w470 h150, DPS Status
    Gui, Add, Edit, x30 y490 w450 h120 vDPSStatusEdit ReadOnly VScroll

    ; ===== CC TAB =====
    gui, tab, CC
    Gui, Add, GroupBox, x20 y40 w470 h100, crowd control
    Gui, Add, Button, x30 y60 w130 h30 gAddCCskill, Add CC Skill
    Gui, Add, Button, x170 y60 w130 h30 gTestCCSkills, Test Skills
    Gui, Add, Button, x310 y60 w130 h30 gClearCCSkills, Clear All
    Gui, Add, Button, x30 y100 w130 h30 gAssignCCKeys, Assign Keys
    Gui, Add, Button, x170 y100 w130 h30 gRenameCCSkills, Rename Skills

    ; Priority Management Section
    Gui, Add, GroupBox, x20 y150 w470 h250, CC Priority Order
    Gui, Add, ListBox, x30 y170 w350 h180 vCCPriorityList gCCPrioritySelect VScroll
    Gui, Add, Button, x390 y170 w80 h25 gMoveCCUp, Move Up
    Gui, Add, Button, x390 y200 w80 h25 gMoveCCDown, Move Down
    Gui, Add, Button, x390 y230 w80 h25 gRemoveFromCCPriority, Remove
    Gui, Add, Button, x390 y260 w80 h25 gAddToCCPriority, Add

    ; Status Section
    Gui, Add, GroupBox, x20 y410 w470 h130, CC Status
    Gui, Add, Edit, x30 y430 w450 h100 vCCStatusEdit ReadOnly VScroll

    ; ===== BUFFS TAB =====
    Gui, Tab, Buffs

    ; Profile Management Section
    Gui, Add, GroupBox, x20 y40 w470 h90, Profile Management
    Gui, Add, Text, x30 y60 w80 h20, Active Profile:
    Gui, Add, DropDownList, x110 y60 w160 h120 vCurrentProfile gProfileChanged, % CurrentProfileName
    Gui, Add, Button, x270 y60 w60 h25 gSaveProfile, Save
    Gui, Add, Button, x340 y60 w60 h25 gLoadProfile, Load 
    Gui, Add, Button, x410 y60 w60 h25 gNewProfile, New
    Gui, Add, Text, x30 y85 w100 h20, Profile Name:
    Gui, Add, Edit, x110 y85 w220 h20 vProfileNameEdit
    Gui, Add, Button, x340 y85 w60 h25 gRenameProfile, Rename
    Gui, Add, Button, x410 y85 w60 h25 gDeleteProfile, Delete

    ; Settings Section
    Gui, Add, GroupBox, x20 y140 w470 h60, Settings
    Gui, Add, Checkbox, x30 y160 w160 vSkipInitial1, Skip initial execution
    Gui, Add, Button, x200 y155 w80 h25 gStopAll, Stop Timers
    Gui, Add, Button, x290 y155 w100 h25 gStartAllTimers, Start All Timers

    ; Sequence 1
    Gui, Add, GroupBox, x20 y210 w470 h80, Sequence 1 (Blue)
    Gui, Add, Text, x30 y230 w80, Keys:
    Gui, Add, Edit, x110 y230 w180 h20 vKeyCombinationEdit1, %KeyCombination1%
    Gui, Add, Text, x30 y255 w50, Delay (sec):
    Gui, Add, Edit, x80 y255 w50 h20 vKeyDelayEdit1, %KeyDelay1%
    Gui, Add, Text, x140 y255 w50, Timer (min):
    Gui, Add, Edit, x190 y255 w50 h20 vTimerIntervalEdit1, %TimerInterval1%
    Gui, Add, Button, x290 y230 w50 h30 gStartStop1, Start
    Gui, Add, Button, x350 y230 w50 h30 gStop1, Stop
    Gui, Add, Text, x410 y230 w70 vCountdownText1, Next: --
    Gui, Add, Text, x410 y255 w70 vStatusText1, Ready

    ; Sequence 2
    Gui, Add, GroupBox, x20 y300 w470 h80, Sequence 2 (Red)
    Gui, Add, Text, x30 y320 w80, Keys:
    Gui, Add, Edit, x110 y320 w180 h20 vKeyCombinationEdit2, %KeyCombination2%
    Gui, Add, Text, x30 y345 w50, Delay (sec):
    Gui, Add, Edit, x80 y345 w50 h20 vKeyDelayEdit2, %KeyDelay2%
    Gui, Add, Text, x140 y345 w50, Timer (min):
    Gui, Add, Edit, x190 y345 w50 h20 vTimerIntervalEdit2, %TimerInterval2%
    Gui, Add, Button, x290 y320 w50 h30 gStartStop2, Start
    Gui, Add, Button, x350 y320 w50 h30 gStop2, Stop
    Gui, Add, Text, x410 y320 w70 vCountdownText2, Next: --
    Gui, Add, Text, x410 y345 w70 vStatusText2, Ready

    ; Sequence 3
    Gui, Add, GroupBox, x20 y390 w470 h80, Sequence 3 (Green)
    Gui, Add, Text, x30 y410 w80, Keys:
    Gui, Add, Edit, x110 y410 w180 h20 vKeyCombinationEdit3, %KeyCombination3%
    Gui, Add, Text, x30 y435 w50, Delay (sec):
    Gui, Add, Edit, x80 y435 w50 h20 vKeyDelayEdit3, %KeyDelay3%
    Gui, Add, Text, x140 y435 w50, Timer (min):
    Gui, Add, Edit, x190 y435 w50 h20 vTimerIntervalEdit3, %TimerInterval3%
    Gui, Add, Button, x290 y410 w50 h30 gStartStop3, Start
    Gui, Add, Button, x350 y410 w50 h30 gStop3, Stop
    Gui, Add, Text, x410 y410 w70 vCountdownText3, Next: --
    Gui, Add, Text, x410 y435 w70 vStatusText3, Ready

    ; Help Section
    Gui, Add, GroupBox, x20 y480 w470 h60, Help
    Gui, Add, Text, x30 y500 w450 h30, Example: !1|+2|^c means Alt+1, then Shift+2, then Ctrl+C`nModifiers: ! = Alt, + = Shift, ^ = Ctrl

    ; Pet Buff Section
    Gui, Add, GroupBox, x20 y550 w230 h100, Pet Buff

    ; Calculate initial timer display values
    gnollMins := Round(gnollBuffInterval / 60000)
    dtMins := Round(dtBuffInterval / 60000)

    Gui, Add, Checkbox, x30 y570 w200 vgnollbuff ggnollbuff, Enable Gnoll Buff (%gnollMins% mins)
    Gui, Add, Checkbox, x30 y590 w200 vdtbuff gdtbuff, Enable Death Tyrant Buff (%dtMins% mins)
    Gui, Add, Button, x30 y606 w130 h30 gPetBuffSettings, Pet Buff Pattern Settings
    Gui, Add, GroupBox, x250 y550 w240 h100, Additional-Settings
    Gui, Add, Button, x270 y570 w200 h30 gShowAdditionalBuffSequences, Additional Buff Sequences
    ;Gui, Add, Button, x270 y610 w200 h30 gImageClickerSettings, Image Clicker

    ; ===== Settings Tab ======
    Gui, Tab, Settings

    ; Coordinate Settings Section
    Gui, Add, GroupBox, x20 y40 w470 h120, Coordinate Settings
    Gui, Add, Button, x30 y60 w140 h30 gSetSkillbarArea, Set Skillbar Area
    Gui, Add, Button, x180 y60 w180 h30 gSetCheckSnapshotCoords, Set CheckWeight/Snapshot Area
    Gui, Add, Text, x30 y100 w450 h25 vToolsSkillbarCoords, Skillbar: Not set
    Gui, Add, Text, x30 y120 w450 h25 vCheckSnapshotCoordsText, CheckWeight/Snapshot: Not set

    ; File Editor Section
    Gui, Add, GroupBox, x20 y170 w470 h100, File Editor
    Gui, Add, Button, x30 y190 w100 h25 gSelectFile, Select File
    Gui, Add, Text, x140 y190 w320 h20 vSelectedFilePath, No file selected
    Gui, Add, Text, x30 y220 w60 h20, RADIUS:
    Gui, Add, Edit, x90 y220 w100 h20 vRadiusValue
    Gui, Add, Button, x200 y220 w60 h25 gSaveRadius, Save

    ; ===== Navigation Tab =====

    Gui, Tab, Navigation

    ; Window & Coordinate Controls
    Gui, Add, GroupBox, x20 y40 w470 h80, Window & Coordinates
    Gui, Add, Button, x30 y60 w110 h25 gSelectcam, Select Camera
    Gui, Add, Button, x150 y60 w110 h25 gActivateCoordinates, Get Coords
    Gui, Add, Button, x270 y60 w110 h25 gShowSearchArea, Show Area
    Gui, Add, Text, x30 y90 w450 h20 vNavCurrentCoords, Current: X: --- Y: ---
    Gui, Add, Button, x390 y60 w70 h25 gBD5Cam, BD5 Cam
    ; Route Management
    Gui, Add, GroupBox, x20 y130 w470 h80, Route Management
    Gui, Add, Button, x30 y150 w80 h25 gSelectRoute, Select Route
    Gui, Add, Button, x120 y150 w80 h25 gNewPath, New Path
    Gui, Add, Button, x210 y150 w80 h25 gWaypointCmds vCommandsButton, Commands
    Gui, Add, Text, x30 y180 w450 h20 vNavRouteStatus, No route selected
    Gui, Add, Button, x300 y150 w80 h25 gCapturePattern, Capture Pattern 
    ; Travel Controls
    Gui, Add, GroupBox, x20 y220 w470 h80, Travel Controls
    Gui, Add, Button, x30 y240 w170 h25 gStartTravel vStartBtn, Start Travel
    Gui, Add, Button, x210 y240 w170 h25 gStopTravel vStopBtn Disabled, Stop Travel
    Gui, Add, Checkbox, x30 y270 w100 h20 vNavCameraLockCheck gToggleCameraLock Checked, Camera Lock

    ; Movement Settings
    Gui, Add, GroupBox, x20 y310 w470 h80, Movement Settings
    Gui, Add, Radio, x30 y330 w120 h20 vClickMode gSetMovementMode Checked, Click-to-Move
    ;Gui, Add, Radio, x160 y330 w120 h20 vWASDMode gSetMovementMode, WASD Keys
    Gui, Add, Text, x140 y330 w100 h15, Max Click Distance:
    Gui, Add, Edit, x245 y330 w50 h20 vMaxClickEdit, %MaxClickDistance%
    Gui, Add, Button, x300 y330 w50 h20 gSaveClickDistance, Save
    Gui, Add, Text, x30 y360 w80 h15, Tolerance X:
    Gui, Add, Edit, x110 y360 w50 h20 vToleranceX, %DistanceToleranceX%
    Gui, Add, Text, x170 y360 w20 h15, Y:
    Gui, Add, Edit, x190 y360 w50 h20 vToleranceY, %DistanceToleranceY%
    Gui, Add, Button, x250 y360 w60 h20 gSaveTolerance, Save

    ; Waypoint Navigation
    Gui, Add, GroupBox, x20 y400 w470 h120, Waypoint Navigation
    Gui, Add, Button, x30 y420 w80 h25 gPrevWaypoint vPrevWaypointBtn Disabled, Prev
    Gui, Add, Button, x120 y420 w80 h25 gNextWaypoint vNextWaypointBtn Disabled, Next
    Gui, Add, Button, x210 y420 w80 h25 gAddWaypoint, Add Point
    Gui, Add, Button, x300 y420 w80 h25 gClearWaypoints, Clear All

    Gui, Add, Text, x30 y450 w50 h15, Go to:
    Gui, Add, Edit, x85 y450 w50 h20 vGotoWaypoint
    Gui, Add, Button, x140 y450 w80 h25 gGotoSpecificWaypoint vGotoBtn Disabled, Go
    Gui, Add, Text, x230 y450 w80 h15, Delete WP:
    Gui, Add, Edit, x315 y450 w50 h20 vDeleteWaypointID
    Gui, Add, Button, x370 y450 w80 h25 gDeleteWaypoint, Delete

    Gui, Add, Button, x30 y480 w150 h25 gMoveWaypointByNumber, Move Waypoint
    Gui, Add, Checkbox, x190 y480 w120 h15 vShowWaypointsCheck gToggleWaypoints Checked, Show Waypoints
    Gui, Add, Text, x320 y480 w150 h15 vWaypointStatus, Waypoints: 0 placed

    ; Function Blocking
    ; Gui, Add, Button, x20 y510 w150 h30 gOpenFunctionBlockingGUI, Function Blocking Settings

    ; Target Nodes
    Gui, Add, GroupBox, x20 y520 w470 h120, Target Nodes

    Gui, Add, Button, x210 y540 w80 h25 gAddTargetNode, Add Node
    Gui, Add, Button, x300 y540 w80 h25 gClearAllNodes, Clear All

    Gui, Add, Text, x230 y570 w80 h15, Delete Node:
    Gui, Add, Edit, x315 y570 w50 h20 vDeleteNodeID
    Gui, Add, Button, x370 y570 w80 h25 gDeleteNode, Delete

    Gui, Add, Button, x30 y600 w150 h25 gMoveNode, Move Node
    Gui, Add, Checkbox, x190 y600 w120 h15 vShowTargetNodesCheck gToggleTargetNodes Checked, Show Nodes
    Gui, Add, Text, x320 y600 w150 h15 vNodeStatus, Nodes: 0 placed

    ; Gui, Tab, Navigation

    ; ; Window & Coordinate Controls
    ; Gui, Add, GroupBox, x20 y40 w470 h80, Window & Coordinates
    ; Gui, Add, Button, x30 y60 w110 h25 gNavSelectWindow, Select Window
    ; Gui, Add, Button, x150 y60 w110 h25 gActivateCoordinates, Activate Coords
    ; Gui, Add, Button, x270 y60 w110 h25 gShowSearchArea, Show Area
    ; Gui, Add, Text, x30 y90 w450 h20 vNavCurrentCoords, Current: X: --- Y: ---

    ; ; Route Management
    ; Gui, Add, GroupBox, x20 y130 w470 h80, Route Management
    ; Gui, Add, Button, x30 y150 w80 h25 gSelectRoute, Select Route
    ; Gui, Add, Button, x120 y150 w80 h25 gNewPath, New Path
    ; Gui, Add, Button, x210 y150 w80 h25 gAddWaypoint, Add Waypoint
    ; Gui, Add, Button, x300 y150 w80 h25 gClearWaypoints, Clear Points
    ; Gui, Add, Text, x30 y180 w450 h20 vNavRouteStatus, No route selected

    ; ; Travel Controls
    ; Gui, Add, GroupBox, x20 y220 w470 h80, Travel Controls
    ; Gui, Add, Button, x30 y240 w170 h25 gStartTravel, Start Travel
    ; Gui, Add, Button, x210 y240 w170 h25 gStopTravel, Stop Travel
    ; Gui, Add, Checkbox, x30 y270 w100 h20 vNavCameraLockCheck gToggleCameraLock Checked, Camera Lock

    ; ; Camera Settings
    ; Gui, Add, GroupBox, x20 y310 w470 h80, Camera Settings
    ; Gui, Add, Text, x30 y330 w50 h20, Radius:
    ; Gui, Add, Edit, x85 y330 w60 h20 vNavRadiusEdit
    ; Gui, Add, Button, x155 y330 w50 h20 gSaveNavRadius, Save
    ; Gui, Add, Text, x30 y360 w450 h20 vNavCameraFile, No camera file loaded

    ; ===== TEMPLAR TAB =====
    Gui, Tab, Templar

    ; Configuration Section
    Gui, Add, GroupBox, x20 y40 w470 h90, Configuration
    Gui, Add, Text, x30 y60 w80 h20, Pull Areas:
    Gui, Add, Edit, x120 y60 w50 h20 vPullAreasEdit gUpdatePullAreas, %pullAreas%
    Gui, Add, Text, x180 y60 w80 h20, Click Locations:
    Gui, Add, Edit, x270 y60 w50 h20 vClickLocationsEdit gUpdateClickLocations, %clickLocations%

    Gui, Add, Text, x30 y85 w85 h20, Random Offset X:
    Gui, Add, Edit, x120 y85 w50 h20 vOffsetXEdit gUpdateOffsetX, %randomOffsetX%
    Gui, Add, Text, x180 y85 w85 h20, Random Offset Y:
    Gui, Add, Edit, x270 y85 w50 h20 vOffsetYEdit gUpdateOffsetY, %randomOffsetY%

    Gui, Add, Button, x330 y60 w120 h25 gSetMovementArea, Set Movement Area
    Gui, Add, Text, x330 y85 w140 h15 vMovementStatus, Area: Not Set

    ; Window Selection
    Gui, Add, GroupBox, x20 y140 w470 h50, Anti-town spam monitor
    ;Gui, Add, Button, x30 y160 w120 h25 gSelectTemplarWindow, Select Game Window
    ;windowText := selectedWindow != "" ? "Window: Selected" : "Window: None"
    ;Gui, Add, Text, x160 y165 w140 h15 vTemplarWindowStatus, %windowText%
    Gui, Add, Button, x30 y160 w80 h25 gStartWindowMonitor, Start Monitor
    Gui, Add, Button, x110 y160 w80 h25 gStopWindowMonitor, Stop Monitor

    ; Setup Actions
    Gui, Add, GroupBox, x20 y200 w470 h50, Setup Actions
    Gui, Add, Button, x30 y220 w120 h25 gSetClickLocations, Set Click Locations
    Gui, Add, Button, x160 y220 w120 h25 gReturnToCharacter, Return to Character
    gui, add, text, x300 y225 w180 h15 , Holyground hotkey:
    Gui, Add, Hotkey, x400 y220 w50 h20 vHotkeyEdit gHotkeyChanged, %pullHotkey%
    ; Timing Settings
    Gui, Add, GroupBox, x20 y260 w470 h120, Timing Settings
    Gui, Add, Text, x30 y280 w120 h20, Mouse Move Delay (ms):
    Gui, Add, Edit, x160 y280 w50 h20 vMouseMoveDelayEdit gUpdateMouseMoveDelay, %mouseMoveDelay%

    Gui, Add, Text, x30 y305 w120 h20, Mouse Click Delay (ms):
    Gui, Add, Edit, x160 y305 w50 h20 vMouseClickDelayEdit gUpdateMouseClickDelay, %mouseClickDelay%

    Gui, Add, Text, x30 y330 w120 h20, Sleep After Area (ms):
    Gui, Add, Edit, x160 y330 w50 h20 vSleepTimeEdit gUpdateSleepTime, %returnSleepTime%

    Gui, Add, Text, x240 y280 w120 h20, Random Delay Min (ms):
    Gui, Add, Edit, x370 y280 w50 h20 vrandomdelaymin, %randomdelaymin%
    Gui, Add, Text, x240 y305 w120 h20, Random Delay Max (ms):
    Gui, Add, Edit, x370 y305 w50 h20 vrandomdelaymax, %randomdelaymax%

    Gui, Add, Checkbox, x30 y355 w150 h20 gautofollow, Enable Autofollow
    Gui, Add, Checkbox, x200 y355 w200 h20 gamimovingg, Enable Movement Detection
    gui, add, checkbox, x30 y385 w150 h20 gtemplardpsing, Enable templar dps

    ; ; DPS Configuration
    ; Gui, Add, GroupBox, x20 y390 w470 h120, DPS Configuration

    ; ; DPS Enable Checkbox
    ; Gui, Add, Checkbox, x30 y410 w200 h20 vDpsEnabledCheckbox gUpdateDpsEnabled Checked%dpsEnabled%, Enable DPS after Return to Character

    ; ; DPS Hotkey Input
    ; Gui, Add, Text, x30 y435 w100 h20, DPS Hotkey:
    ; Gui, Add, Edit, x140 y435 w50 h20 vDpsHotkeyEdit gUpdateDpsHotkey, %dpsHotkey%
    ; Gui, Add, Text, x200 y435 w80 h20, (e.g., 2, f, space)

    ; ; DPS Duration Input
    ; Gui, Add, Text, x30 y460 w100 h20, Hold Duration (ms):
    ; Gui, Add, Edit, x140 y460 w50 h20 vDpsDurationEdit gUpdateDpsDuration, %dpsDuration%
    ; Gui, Add, Text, x200 y460 w80 h20, (e.g., 3000 = 3sec)

    ; ; DPS Test Button
    ; Gui, Add, Button, x300 y435 w100 h25 gTestDpsHotkey, Test DPS Hotkey

    ; ; DPS Status
    ; dpsStatusText := dpsEnabled ? "DPS: Enabled" : "DPS: Disabled"
    ; Gui, Add, Text, x300 y465 w150 h20 vDpsStatusText, %dpsStatusText%

    ; Control Section
    Gui, Add, GroupBox, x20 y520 w470 h50, Control
    Gui, Add, Button, x30 y540 w80 h25 gStartPulling, Start Templar
    Gui, Add, Button, x120 y540 w60 h25 gStopPulling, Stop
    Gui, Add, Button, x190 y540 w60 h25 gSaveCoords, Save
    ;Gui, Add, Button, x260 y540 w60 h25 gLoadCoords, Load
    ;Gui, Add, Button, x330 y540 w100 h25 gSaveDpsSettings, Save DPS Settings

    ; Status Section - moved to bottom to fit within GUI height
    statusText := "Status: Ready. Set movement area and click locations first."
    if (movementAreaSet) {
        GuiControl,, MovementStatus, Area: Set
        coordsCount := clickCoords.Length()
        if (coordsCount > 0) {
            statusText := "Status: Ready to start pulling!"
        }
    }
    Gui, Add, Text, x30 y580 w440 h20 vTemplarStatusText, %statusText%

    gui,tab, Network
    Clients := []

    ; ==================== NETWORK TAB ====================
    ; SERVER MODE - Host a server that other clients connect to
    Gui, Add, GroupBox, x15 y35 w490 h130, SERVER MODE - Host
    Gui, Add, Text, x25 y58 w460 h15, Run as server to allow other game clients to connect and receive commands

    Gui, Add, Text, x25 y80 w60 h20, Listen Port:
    Gui, Add, Edit, x90 y80 w60 h20 vhostPort gUpdateListenButton, 27016
    Gui, Add, Text, x160 y80 w340 h20, (Port number for other clients to connect to)

    Gui, Add, Button, x25 y105 w200 h25 gbtnListen vbtnListen, Start Listening (27016)
    Gui, Add, Text, x235 y105 w120 h25 vlblClients cBlue +0x200, 0 clients connected

    Gui, Add, Button, x25 y135 w150 h25 gbtnCustom, Send Custom Command
    Gui, Add, Text, x185 y138 w315 h20, (Send commands to all connected clients)
    Gui, Add, Button, x370 y135 w130 h25 gTestAutoFollow, Test AutoFollow
    Gui, Add, Button, x370 y105 w130 h25 gTestCharSelect, Char Select

    ; SERVER LOG
    Gui, Add, GroupBox, x15 y170 w490 h95, Server Activity Log
    Gui, Add, Edit, x25 y190 w470 h65 vtxtLog ReadOnly VScroll, Waiting to start server...`n

    ; CLIENT MODE - Connect to another server
    Gui, Add, GroupBox, x15 y275 w490 h150, CLIENT MODE - Connect to Server
    Gui, Add, Text, x25 y298 w460 h15, Run as client to connect to another game instance (server) and receive commands

    Gui, Add, Text, x25 y320 w100 h20, Server Address:
    Gui, Add, Edit, x130 y320 w150 h20 vsrvAddress gUpdateConnectButton, localhost
    Gui, Add, Text, x290 y320 w30 h20, Port:
    Gui, Add, Edit, x325 y320 w60 h20 vsrvPort gUpdateConnectButton, 12345

    Gui, Add, Button, x25 y350 w200 h25 gbtnConnect vbtnConnect, Connect (localhost:27016)
    Gui, Add, Checkbox, x235 y350 w250 h25 vchkAutoReconnect Checked, Auto-reconnect every 15s

    Gui, Add, Text, x25 y380 w150 h25 vlblStatus, Status: Not Connected
    Gui, Add, Text, x185 y380 w315 h20 cGray, (Connection status will appear here)

    ; CLIENT LOG
    Gui, Add, GroupBox, x15 y435 w490 h95, Client Activity Log
    Gui, Add, Edit, x25 y455 w470 h65 vtxtClientLog ReadOnly VScroll, Not connected to any server...`n

    ; QUICK REFERENCE
    Gui, Add, GroupBox, x15 y540 w490 h90, Quick Reference
    Gui, Add, Text, x25 y560 w460 h60, • SERVER: Start listening to receive connections from other clients`n• CLIENT: Connect to another server to receive commands`n• Use waypoint commands (netskill, netcombat, netnav, etc.) to control multiple clients`n• See Commands tab for full list of network commands

    ; ===== GLOBAL CONTROLS =====
    Gui, Tab
    Gui, Add, Button, x30 y640 w60 h25 gMinimizeToTray, Minimize
    Gui, Add, Button, x150 y640 w60 h25 gSaveAllSettings, Save All
    Gui, Add, Button, x220 y640 w60 h25 gCloseApp, Close
    Gui, Add, Button, x290 y640 w60 h25 greload, Reload

    ; Populate profile dropdown from INI so renamed/new profiles appear
    RefreshProfileDropdown()
    LoadProfile()
    GuiControl,, AutoFollowHotkey, %autofollowhotkeydefault%

    ; Show GUI
    Gui, Show, x1024 y30 w540 h680, Rappelz Automation Nexus WIN1
    gui, +AlwaysOnTop
    UpdateWindowStatusDisplay()

    ; Auto-connect to server after 1 second
    SetTimer, AutoConnectToServer, -1000
    ;SetTimer, CheckWindowActivity, 500

    ; Start timer signal checking immediately
    ;SetTimer, TimerSignalCheck, 100

    ; Ensure default patterns exist in CapturedText.ini
    EnsureDefaultPatterns()

    ; Load heal/DPS patterns from CapturedText.ini
    LoadPatternsFromINI()

    ; Update skillbar display
    UpdateSkillbarDisplay()

    ; Update GUI status if a route is already selected
    if (SelectedRouteFile && FileExist(SelectedRouteFile)) {
        SplitPath, SelectedRouteFile, fileName
        waypointCount := Waypoints.Length()
        nodeCount := TargetNodes.Length()
        GuiControl,, RouteStatus, Route: %fileName% (%waypointCount% waypoints)
        GuiControl,, NodeStatus, Nodes: %nodeCount% placed

        ; Enable navigation buttons if waypoints exist
        if (waypointCount > 0) {
            GuiControl, Enable, PrevWaypointBtn
            GuiControl, Enable, NextWaypointBtn
            GuiControl, Enable, GotoBtn
        }
    }
    ; Load and display existing heal skills after GUI is shown
    SetTimer, LoadHealSkillsDelayed, -100
    ; Load and display existing DPS skills after GUI is shown
    SetTimer, LoadDPSSkillsDelayed, -150
    setTimer, LoadCCSkillsDelayed, -200
    ; Load last selected file
    SetTimer, LoadLastFile, -250
    ; Load all checkbox states after GUI is created
    SetTimer, LoadCheckboxStatesDelayed, -50
    SetTimer, ChangeKeyDelay, 1000
    ; Load max resurrections from INI on startup
    LoadMaxResurrections()
    ; Initialize navigation variables
    ;InitializeNavigation()
return
LoadGameWindowSettings() {
    global TargetGameWindow, TargetGameTitle, TargetGamePID, iniFile, win1, NavTargetGameWindow, NavTargetGamePID, selectedWindow

    ; Auto-detect window based on script folder name
    SplitPath, A_ScriptDir, folderName
    expectedWindowTitle := folderName ; win1, win2, win3, etc.

    ; Check if window with expected title exists
    WinGet, win1ID, ID, %expectedWindowTitle%
    if (win1ID) {
        win1 := win1ID
        selectedWindow := win1ID
        ; Get the actual window title (not just folder name)
        WinGetTitle, actualTitle, ahk_id %win1ID%
        TargetGameTitle := actualTitle
        WinGet, win1PID, PID, ahk_id %win1ID%
        TargetGamePID := win1PID
        NavTargetGameWindow := win1ID
        NavTargetGamePID := win1PID
        TargetGameWindow := win1ID

        FindText().BindWindow(win1ID)
        ;ToolTip, Selected window: %actualTitle% (ID: %win1ID%)
        ; SetTimer, RemoveToolTip, -2000
        SetTimer, UpdateWindowDisplayDelayed, -200
        UpdateWindowStatusDisplay()
        sleep 500
        ;MsgBox, 0, Auto-Selected, Window "%expectedWindowTitle%" automatically selected!, 2
    }

    IniRead, loadedWindowID, %iniFile%, GameWindow, WindowID, 
    IniRead, loadedWindowTitle, %iniFile%, GameWindow, WindowTitle, 
    IniRead, loadedPID, %iniFile%, GameWindow, WindowPID,
    IniRead, savedNavCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
    IniRead, savedMainCameraFile, pathingsettings.ini, Settings, CameraFile, ERROR

    ; Check if we have a saved PID
    if (loadedPID != "" && loadedPID != "ERROR") {
        ; Try to find the window by PID
        WinGet, winIDFromPID, ID, ahk_pid %loadedPID%
        if (winIDFromPID) {
            WinMove, ahk_id %winIDFromPID%, , 0, 0
            ; Set up for healing system
            FindText().BindWindow(winIDFromPID)
            global TargetGameWindow := winIDFromPID
            global TargetGameTitle := loadedWindowTitle
            global TargetGamePID := loadedPID
            global windowWasClosed := false
            global win1 := winIDFromPID
            ; Set up for navigation system
            global NavTargetGameWindow := winIDFromPID
            global NavTargetGamePID := loadedPID

            ; Handle camera file selection for both systems
            selectedCameraFile := ""
            if (savedNavCameraFile != "ERROR" && FileExist(savedNavCameraFile)) {
                selectedCameraFile := savedNavCameraFile
            }
            else if (savedMainCameraFile != "ERROR" && FileExist(savedMainCameraFile)) {
                selectedCameraFile := savedMainCameraFile
            }

            ; If no saved file or user declined, ask for new file
            if (selectedCameraFile = "") {
                FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
            }

            ; Apply camera file to both systems if selected
            if (selectedCameraFile != "") {
                ; Set up navigation camera
                NavCameraFile := selectedCameraFile
                LoadNavCameraSettings(NavCameraFile)
                GuiControl,, NavCameraFile, Camera: %NavCameraFile%
                GuiControl,, NavRadiusEdit, %NavCameraRadius%

                ; Set up main camera
                CameraFile := selectedCameraFile
                LoadCameraSettings(CameraFile)

                MsgBox, Camera file loaded for both systems: %selectedCameraFile%
                SaveNavSettings()
                SaveSettings()
            }
            ; Move the selected window to 0,0 (top-left corner of the screen)
            UpdateHealerStatus("Selected window: " . loadedWindowTitle)
            SaveGameWindowSettings()
            UpdateWindowStatusDisplay()
            sleep, 500
        }
    }
}
templardpsing:
    if (templardps)
    {
        templardps := False
        return
    }
    else if (!templardps)
    {
        templardps := True
        return
    }
HotkeyChanged:
    Gui, Submit, NoHide
    pullHotkey := HotkeyEdit
    if (pullHotkey = "")
        pullHotkey := "1" ; Default to "1" if empty

    ; Save the hotkey to INI file
    IniWrite, %pullHotkey%, %INIFILE%, Hotkeys, PullHotkey
return

; ===== MINIMIZE/RESTORE GUI FUNCTIONS =====
MinimizeToTray:
    global SavedMiniX, SavedMiniY, SavedGuiX, SavedGuiY, MiniGuiID

    ; Save current main GUI position before hiding
    WinGetPos, SavedGuiX, SavedGuiY,,, Buff & Heal - Game Automation Tool

    ; Hide the main GUI
    Gui, Hide

    ; Create mini GUI - draggable window with button to restore
    Gui, Mini:New, +AlwaysOnTop +ToolWindow
    Gui, Mini:Color, 0x2E4C2E
    Gui, Mini:Font, s5 cWhite Bold
    Gui, Mini:Add, Button, x0 y0 w50 h50 gRestoreFromTray, SHOW

    ; Show mini GUI at last known position (or centered if first time)
    if (SavedMiniX != "" && SavedMiniY != "" && SavedMiniX != "ERROR") {
        Gui, Mini:Show, x%SavedMiniX% y%SavedMiniY% w50 h50, Mini Control
    } else {
        Gui, Mini:Show, w50 h50, Mini Control
    }

    ; Get the window ID immediately after showing
    MiniGuiID := WinExist("Mini Control")
return

RestoreFromTray:
    global SavedGuiX, SavedGuiY, SavedMiniX, SavedMiniY, MiniGuiID

    ; Get the mini GUI window ID if not set
    if (!MiniGuiID)
        MiniGuiID := WinExist("Mini Control")

    ; Save mini GUI position before destroying it
    WinGetPos, SavedMiniX, SavedMiniY,,, ahk_id %MiniGuiID%

    ; Destroy mini GUI first
    Gui, Mini:Destroy

    ; Restore main GUI at saved position (or default if not set)
    if (SavedGuiX != "" && SavedGuiY != "")
        Gui, 1:Show, x%SavedGuiX% y%SavedGuiY% w540 h680, Buff & Heal - Game Automation Tool
    else
        Gui, 1:Show, x1394 y0 w540 h680, Buff & Heal - Game Automation Tool
return

infinitemouse:
    Gui, Submit, NoHide
    if (infinitemouse) {
        Hotkey, ~RButton, RButtonDown, On
        Hotkey, ~RButton up, RButtonUp, On
    } else {
        Hotkey, ~RButton, Off
        Hotkey, ~RButton up, Off
    }
    msgbox, % (infinitemouse ? "Infinite Mouse Active `nRight-click and hold to keep mouse centered" : "Infinite Mouse Deactivated") 
return

RButtonDown:
    MouseGetPos, centerX, centerY
    SetTimer, InfiniteMouseMove, 5
return

RButtonUp:
    SetTimer, InfiniteMouseMove, Off
return
; ===== Pet Buff Timers =====
gnollbuff:
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return
    }
    if (win1 = "" || !WinExist("ahk_id " . win1)) {
        GuiControl,, gnollbuff, 0
        gnollbuff := false
        tooltip, Please select a window first.
        SetTimer, RemoveTooltip, -3000
        return
    }
    if (gnollbuff = false)
    {
        gnollbuff := true
        gnoll()
        SetTimer, gnoll, %gnollBuffInterval%
    }
    else if (gnollbuff = true)
    {
        gnollbuff := false
        SetTimer, gnoll, Off
    }
Return

; ===== Auto-Dura Functions =====
autodura:
    Gui, Submit, NoHide
    autoDuraEnabled := autodura ; Update autoDuraEnabled from checkbox state

    if (win1 = "" || !WinExist("ahk_id " . win1)) {
        GuiControl,, autodura, 0
        autoDuraEnabled := false
        MsgBox, Please select a window first.
        return
    }

    if (autoDuraEnabled) {
        ; Calculate interval in milliseconds
        autoDuraTimerInterval := autoDuraInterval * 60000
        SetTimer, AutoRepairDura, %autoDuraTimerInterval%
        MsgBox, Auto-Dura enabled - will repair every %autoDuraInterval% minutes.
    } else {
        SetTimer, AutoRepairDura, Off
        MsgBox, Auto-Dura disabled.
    }
return
selectcam:
    FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
    if (selectedCameraFile != "") {
        NavCameraFile := selectedCameraFile
        LoadNavCameraSettings(NavCameraFile)
        ; Save to navpathingsettings.ini
        IniWrite, %NavTargetGamePID%, navpathingsettings.ini, Settings, WindowPID
        IniWrite, %NavCameraFile%, navpathingsettings.ini, Settings, CameraFile
        MsgBox, Camera file loaded: %NavCameraFile%
    }
return
SaveAutoDuraInterval:
    Gui, Submit, NoHide
    autoDuraInterval := autoDuraIntervalEdit
    ; if (autoDuraInterval < 1) {
    ;     autoDuraInterval := 1
    ;     GuiControl,, autoDuraIntervalEdit, 1
    ;     MsgBox, Minimum interval is 1 minute.
    ; }
    IniWrite, %autoDuraInterval%, %SettingsFile%, AutoDura, Interval
    MsgBox, Auto-Dura interval set to %autoDuraInterval% minutes and saved.

    ; Restart timer if it's currently running
    if (autoDuraEnabled) {
        autoDuraTimerInterval := autoDuraInterval * 60000
        SetTimer, AutoRepairDura, Off
        SetTimer, AutoRepairDura, %autoDuraTimerInterval%
    }
return

testduradetection:
    PerformDuraRepair()
return

AutoRepairDura:
    PerformDuraRepair()
return


ShowAdditionalBuffSequences:
    Gui, 2:New
    Gui, 2:Add, GroupBox, x10 y10 w480 h150, Sequence 4
    Gui, 2:Add, Text, x20 y35 w100 h20, Keys:
    Gui, 2:Add, Edit, x130 y35 w150 h20 vKeyCombinationEdit4, %KeyCombination4%
    Gui, 2:Add, Text, x20 y65 w100 h20, Key Delay (sec):
    Gui, 2:Add, Edit, x130 y65 w60 h20 vKeyDelayEdit4, %KeyDelay4%
    Gui, 2:Add, Text, x20 y95 w100 h20, Timer Interval (min):
    Gui, 2:Add, Edit, x130 y95 w60 h20 vTimerIntervalEdit4, %TimerInterval4%
    Gui, 2:Add, Button, x20 y125 w100 h25 gSaveSequence4, Save Sequence 4
    Gui, 2:Add, Button, x130 y125 w100 h25 gToggleSequence4, Toggle Sequence 4
    status4Text := IsRunning4 ? "Status: Running" : "Status: Stopped"
    Gui, 2:Add, Text, x240 y125 w200 h25 vSequence4Status, %status4Text%

    Gui, 2:Add, GroupBox, x10 y170 w480 h150, Sequence 5
    Gui, 2:Add, Text, x20 y195 w100 h20, Keys:
    Gui, 2:Add, Edit, x130 y195 w150 h20 vKeyCombinationEdit5, %KeyCombination5%
    Gui, 2:Add, Text, x20 y225 w100 h20, Key Delay (sec):
    Gui, 2:Add, Edit, x130 y225 w60 h20 vKeyDelayEdit5, %KeyDelay5%
    Gui, 2:Add, Text, x20 y255 w100 h20, Timer Interval (min):
    Gui, 2:Add, Edit, x130 y255 w60 h20 vTimerIntervalEdit5, %TimerInterval5%
    Gui, 2:Add, Button, x20 y285 w100 h25 gSaveSequence5, Save Sequence 5
    Gui, 2:Add, Button, x130 y285 w100 h25 gToggleSequence5, Toggle Sequence 5
    status5Text := IsRunning5 ? "Status: Running" : "Status: Stopped"
    Gui, 2:Add, Text, x240 y285 w200 h25 vSequence5Status, %status5Text%

    Gui, 2:Add, GroupBox, x10 y330 w480 h150, Sequence 6
    Gui, 2:Add, Text, x20 y355 w100 h20, Keys:
    Gui, 2:Add, Edit, x130 y355 w150 h20 vKeyCombinationEdit6, %KeyCombination6%
    Gui, 2:Add, Text, x20 y385 w100 h20, Key Delay (sec):
    Gui, 2:Add, Edit, x130 y385 w60 h20 vKeyDelayEdit6, %KeyDelay6%
    Gui, 2:Add, Text, x20 y415 w100 h20, Timer Interval (min):
    Gui, 2:Add, Edit, x130 y415 w60 h20 vTimerIntervalEdit6, %TimerInterval6%
    Gui, 2:Add, Button, x20 y445 w100 h25 gSaveSequence6, Save Sequence 6
    Gui, 2:Add, Button, x130 y445 w100 h25 gToggleSequence6, Toggle Sequence 6
    status6Text := IsRunning6 ? "Status: Running" : "Status: Stopped"
    Gui, 2:Add, Text, x240 y445 w200 h25 vSequence6Status, %status6Text%

    Gui, 2:Show, w500 h490, Additional Buff Sequences
    
return

SaveSequence4:
    Gui, 2:Submit, NoHide
    KeyCombination4 := KeyCombinationEdit4
    KeyDelay4 := KeyDelayEdit4
    TimerInterval4 := TimerIntervalEdit4
    KeySequence4 := StrSplit(KeyCombination4, "|")
    IniWrite, %KeyCombination4%, %SettingsFile%, Sequence4, KeyCombination
    IniWrite, %KeyDelay4%, %SettingsFile%, Sequence4, KeyDelay
    IniWrite, %TimerInterval4%, %SettingsFile%, Sequence4, TimerInterval
    MsgBox, Sequence 4 saved!
return

SaveSequence5:
    Gui, 2:Submit, NoHide
    KeyCombination5 := KeyCombinationEdit5
    KeyDelay5 := KeyDelayEdit5
    TimerInterval5 := TimerIntervalEdit5
    KeySequence5 := StrSplit(KeyCombination5, "|")
    IniWrite, %KeyCombination5%, %SettingsFile%, Sequence5, KeyCombination
    IniWrite, %KeyDelay5%, %SettingsFile%, Sequence5, KeyDelay
    IniWrite, %TimerInterval5%, %SettingsFile%, Sequence5, TimerInterval
    MsgBox, Sequence 5 saved!
return

SaveSequence6:
    Gui, 2:Submit, NoHide
    KeyCombination6 := KeyCombinationEdit6
    KeyDelay6 := KeyDelayEdit6
    TimerInterval6 := TimerIntervalEdit6
    KeySequence6 := StrSplit(KeyCombination6, "|")
    IniWrite, %KeyCombination6%, %SettingsFile%, Sequence6, KeyCombination
    IniWrite, %KeyDelay6%, %SettingsFile%, Sequence6, KeyDelay
    IniWrite, %TimerInterval6%, %SettingsFile%, Sequence6, TimerInterval
    MsgBox, Sequence 6 saved!
return

ToggleSequence4:
    IsRunning4 := !IsRunning4
    if (IsRunning4) {
        KeySequence4 := StrSplit(KeyCombination4, "|")
        NextExecutionTime4 := A_TickCount
        Gosub, SendKeys4
        NextExecutionTime4 := A_TickCount + (TimerInterval4 * 60 * 1000)
        GuiControl, 2:, Sequence4Status, Status: Running
    } else {
        GuiControl, 2:, Sequence4Status, Status: Stopped
    }
    if (IsRunning4 || IsRunning5 || IsRunning6)
        SetTimer, CheckExecutions456, 50
    else
        SetTimer, CheckExecutions456, Off
return

ToggleSequence5:
    IsRunning5 := !IsRunning5
    if (IsRunning5) {
        KeySequence5 := StrSplit(KeyCombination5, "|")
        NextExecutionTime5 := A_TickCount
        Gosub, SendKeys5
        NextExecutionTime5 := A_TickCount + (TimerInterval5 * 60 * 1000)
        GuiControl, 2:, Sequence5Status, Status: Running
    } else {
        GuiControl, 2:, Sequence5Status, Status: Stopped
    }
    if (IsRunning4 || IsRunning5 || IsRunning6)
        SetTimer, CheckExecutions456, 50
    else
        SetTimer, CheckExecutions456, Off
return

ToggleSequence6:
    IsRunning6 := !IsRunning6
    if (IsRunning6) {
        KeySequence6 := StrSplit(KeyCombination6, "|")
        NextExecutionTime6 := A_TickCount
        Gosub, SendKeys6
        NextExecutionTime6 := A_TickCount + (TimerInterval6 * 60 * 1000)
        GuiControl, 2:, Sequence6Status, Status: Running
    } else {
        GuiControl, 2:, Sequence6Status, Status: Stopped
    }
    if (IsRunning4 || IsRunning5 || IsRunning6)
        SetTimer, CheckExecutions456, 50
    else
        SetTimer, CheckExecutions456, Off
return

CheckExecutions456:
    CurrentTime := A_TickCount

    if (IsRunning4 && CurrentTime >= NextExecutionTime4) {
        Gosub, SendKeys4
        NextExecutionTime4 := CurrentTime + (TimerInterval4 * 60 * 1000)
    }
    if (IsRunning5 && CurrentTime >= NextExecutionTime5) {
        Gosub, SendKeys5
        NextExecutionTime5 := CurrentTime + (TimerInterval5 * 60 * 1000)
    }
    if (IsRunning6 && CurrentTime >= NextExecutionTime6) {
        Gosub, SendKeys6
        NextExecutionTime6 := CurrentTime + (TimerInterval6 * 60 * 1000)
    }

    ; Update status with time remaining for each sequence
    if (IsRunning4) {
        TimeRemaining := NextExecutionTime4 - CurrentTime
        if (TimeRemaining <= 0) {
            MinutesLeft := 0
        } else {
            MinutesLeft := Round(TimeRemaining / 60000, 2)
        }
        GuiControl, 2:, Sequence4Status, Status: Running (%MinutesLeft%m left)
    }
    if (IsRunning5) {
        TimeRemaining := NextExecutionTime5 - CurrentTime
        if (TimeRemaining <= 0) {
            MinutesLeft := 0
        } else {
            MinutesLeft := Round(TimeRemaining / 60000, 2)
        }
        GuiControl, 2:, Sequence5Status, Status: Running (%MinutesLeft%m left)
    }
    if (IsRunning6) {
        TimeRemaining := NextExecutionTime6 - CurrentTime
        if (TimeRemaining <= 0) {
            MinutesLeft := 0
        } else {
            MinutesLeft := Round(TimeRemaining / 60000, 2)
        }
        GuiControl, 2:, Sequence6Status, Status: Running (%MinutesLeft%m left)
    }

    if (!IsRunning4 && !IsRunning5 && !IsRunning6) {
        SetTimer, CheckExecutions456, Off
    }
return

SendKeys4:
    IfWinNotExist, ahk_id %win1%
        return
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    Loop % KeySequence4.Length()
    {
        CurrentKey := Trim(KeySequence4[A_Index])
        if (CurrentKey != "") {
            ; Check for modifier keys
            hasCtrl := InStr(CurrentKey, "^")
            hasAlt := InStr(CurrentKey, "!")
            hasShift := InStr(CurrentKey, "+")

            ; Extract base key
            baseKey := CurrentKey
            if (hasCtrl)
                baseKey := StrReplace(baseKey, "^")
            if (hasAlt)
                baseKey := StrReplace(baseKey, "!")
            if (hasShift)
                baseKey := StrReplace(baseKey, "+")

            ; Send modifiers down
            if (hasCtrl)
                ControlSend,, {Ctrl down}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt down}, ahk_id %win1%
            if (hasShift)
                ControlSend,, {Shift down}, ahk_id %win1%

            ; Send base key
            ControlSend,, {%baseKey% down}, ahk_id %win1%
            Sleep, % KeyDelay4 * 1000
            ControlSend,, {%baseKey% up}, ahk_id %win1%

            ; Release modifiers
            if (hasShift)
                ControlSend,, {Shift up}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt up}, ahk_id %win1%
            if (hasCtrl)
                ControlSend,, {Ctrl up}, ahk_id %win1%

            Sleep, 100
        }
    }
    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
return

SendKeys5:
    IfWinNotExist, ahk_id %win1%
        return
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    Loop % KeySequence5.Length()
    {
        CurrentKey := Trim(KeySequence5[A_Index])
        if (CurrentKey != "") {
            hasCtrl := InStr(CurrentKey, "^")
            hasAlt := InStr(CurrentKey, "!")
            hasShift := InStr(CurrentKey, "+")

            baseKey := CurrentKey
            if (hasCtrl)
                baseKey := StrReplace(baseKey, "^")
            if (hasAlt)
                baseKey := StrReplace(baseKey, "!")
            if (hasShift)
                baseKey := StrReplace(baseKey, "+")

            if (hasCtrl)
                ControlSend,, {Ctrl down}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt down}, ahk_id %win1%
            if (hasShift)
                ControlSend,, {Shift down}, ahk_id %win1%

            ControlSend,, {%baseKey% down}, ahk_id %win1%
            Sleep, % KeyDelay5 * 1000
            ControlSend,, {%baseKey% up}, ahk_id %win1%

            if (hasShift)
                ControlSend,, {Shift up}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt up}, ahk_id %win1%
            if (hasCtrl)
                ControlSend,, {Ctrl up}, ahk_id %win1%

            Sleep, 100
        }
    }
    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
return

SendKeys6:
    IfWinNotExist, ahk_id %win1%
        return
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    Loop % KeySequence6.Length()
    {
        CurrentKey := Trim(KeySequence6[A_Index])
        if (CurrentKey != "") {
            hasCtrl := InStr(CurrentKey, "^")
            hasAlt := InStr(CurrentKey, "!")
            hasShift := InStr(CurrentKey, "+")

            baseKey := CurrentKey
            if (hasCtrl)
                baseKey := StrReplace(baseKey, "^")
            if (hasAlt)
                baseKey := StrReplace(baseKey, "!")
            if (hasShift)
                baseKey := StrReplace(baseKey, "+")

            if (hasCtrl)
                ControlSend,, {Ctrl down}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt down}, ahk_id %win1%
            if (hasShift)
                ControlSend,, {Shift down}, ahk_id %win1%

            ControlSend,, {%baseKey% down}, ahk_id %win1%
            Sleep, % KeyDelay6 * 1000
            ControlSend,, {%baseKey% up}, ahk_id %win1%

            if (hasShift)
                ControlSend,, {Shift up}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt up}, ahk_id %win1%
            if (hasCtrl)
                ControlSend,, {Ctrl up}, ahk_id %win1%

            Sleep, 100
        }
    }
    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
return

2GuiClose:
    Gui, 2:Destroy
return

PerformDuraRepair(force := false) {
    global win1, repairPattern, duraRepairNeeded

    if (CriticalModeEnabled) {
        return false
    }

    ; Check if currently navigating and waypoint doesn't have executewaypoint flag
    if ((NavIsTraveling || IsTraveling) && !force) {
        duraRepairNeeded := true
        return
    }

    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    WinGetPos, winX, winY,,, ahk_id %win1%
    inventorytext := "|<>E8E9E9-0.90$29.0001000022FC/C+WWN8Yd4WF9Ht4WGY294W8YG94C8aA"

    ; Press U up to 6 times to open inventory and find repair button
    Loop, 6 {
        ControlSend, , {u down}, ahk_id %win1%
        Sleep, 50
        ControlSend, , {u up}, ahk_id %win1%
        Sleep, 150

        if (FindText(foundX, foundY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, repairPattern)) {
            ; Convert screen coordinates to window-relative and click center
            WinGetPos, winX, winY,,, ahk_id %win1%
            relX := foundX - winX
            relY := foundY - winY
            ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1
            Sleep, 200

            ; Press U up to 6 times to close inventory
            Loop, 6 {
                if (!FindText(foundX, foundY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, repairPattern)) {
                    ; Verify inventory is closed
                    Loop, 3 {
                        if (!FindText(invX, invY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, inventorytext)) {
                            break, 2

                        }
                        ControlSend, , {u down}, ahk_id %win1%
                        Sleep, 50
                        ControlSend, , {u up}, ahk_id %win1%
                        Sleep, 150
                    }

                    if (NavigationPausedForBuff) {
                        ResumeNavigationAfterBuff()
                    }
                    return
                }

                ControlSend, , {u down}, ahk_id %win1%
                Sleep, 50
                ControlSend, , {u up}, ahk_id %win1%
                Sleep, 150
            }

            if (NavigationPausedForBuff) {
                ResumeNavigationAfterBuff()
            }
            return
        }
    }

    ; Repair button not found - ensure inventory is closed
    Loop, 6 {
        if (!FindText(invX, invY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, inventorytext)) {
            Break
        }
        ControlSend, , {u down}, ahk_id %win1%
        Sleep, 50
        ControlSend, , {u up}, ahk_id %win1%
        Sleep, 150
    }

    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
}

reload:
    Reload
return

; ===== FILE EDITOR FUNCTIONS =====
SelectFile:
    FileSelectFile, SelectedFile, 1, , Select file to edit, Text Files (*.txt)
    if (SelectedFile != "") {
        GuiControl,, SelectedFilePath, %SelectedFile%
        ; Save file path to INI
        IniWrite, %SelectedFile%, settings.ini, FileEditor, LastFile
        ; Load current RADIUS value
        LoadRadiusValue()
    }
return

LoadRadiusValue() {
    GuiControlGet, FilePath,, SelectedFilePath
    if (FilePath = "No file selected" || FilePath = "")
        return

    FileRead, FileContent, %FilePath%
    if (ErrorLevel) {
        GuiControl,, RadiusValue, Error reading file
        return
    }

    ; Extract RADIUS value using regex
    if (RegExMatch(FileContent, "RADIUS\|([0-9.]+)\|", Match)) {
        GuiControl,, RadiusValue, %Match1%
    } else {
        GuiControl,, RadiusValue, RADIUS not found
    }
}

SaveRadius:
    GuiControlGet, FilePath,, SelectedFilePath
    GuiControlGet, NewRadius,, RadiusValue

    if (FilePath = "No file selected" || FilePath = "") {
        MsgBox, Please select a file first.
        return
    }

    if (NewRadius = "") {
        MsgBox, Please enter a RADIUS value.
        return
    }

    FileRead, FileContent, %FilePath%
    if (ErrorLevel) {
        MsgBox, Error reading file: %FilePath%
        return
    }

    ; Replace RADIUS value
    NewContent := RegExReplace(FileContent, "RADIUS\|[0-9.]+\|", "RADIUS|" . NewRadius . "|")

    FileDelete, %FilePath%
    FileAppend, %NewContent%, %FilePath%

    if (ErrorLevel) {
        MsgBox, Error saving file.
    } else {
        MsgBox, RADIUS value saved successfully!
    }
return

LoadLastFile:
    IniRead, LastFile, settings.ini, FileEditor, LastFile, %A_Space%
    if (LastFile != "" && FileExist(LastFile)) {
        GuiControl,, SelectedFilePath, %LastFile%
        LoadRadiusValue()
    }
return
dtbuff:
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return
    }
    ; Do nothing if no target window selected or window doesn't exist
    if (win1 = "" || !WinExist("ahk_id " . win1)) {
        GuiControl,, dtbuff, 0
        dtbuff := false
        tooltip, Please select a window first.
        SetTimer, RemoveTooltip, -3000
        return
    }

    if (dtbuff = false)
    {
        dtbuff := true
        deathtyrant()
        SetTimer, deathtyrant, %dtBuffInterval%
    }
    else if (dtbuff = true)
    {
        dtbuff := false
        SetTimer, deathtyrant, Off
    }
Return

SendText:
    ; Get text from input box
    GuiControlGet, inputText, , TextInputBox
    WinActivate, ahk_id %win1%
    ; Check if text is empty
    if (inputText = "") {
        return
    }

    ; Check if win1 is selected
    if (win1 = "" || !WinExist("ahk_id " . win1)) {
        ToolTip, Please select a window first.
        SetTimer, RemoveTooltip, -3000
        return
    }

    ; Activate window and wait until active

    ;WinWaitActive, ahk_id %win1%
    sleep, 90
    ; Copy text to clipboard
    Clipboard := inputText

    ; Send Ctrl+Enter to win1
    Send, {Enter}
    Sleep, 90

    ; Paste text
    Send, ^v
    Sleep, 90

    ; Send Ctrl+Enter again
    Send, {Enter}

return

ClearText:
    GuiControl, , TextInputBox,
return

gnoll(force := false) {
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return false
    }

    ; If navigation is running, set flag instead of executing, unless forced
    if ((NavIsTraveling || IsTraveling) && !force) {
        gnollBuffNeeded := true
        return false
    }
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    ; Pause navigation while executing pet buff

    global gnollPatterns, gnollBuffImagePattern, customSummonPattern, summonKeybind

    ; Default patterns (fallback if custom not set)
    defaultReflectingShieldPattern := "|<>##0.90$0/0/F2D561,-14/17/C5E9FF,7/16/43EFFF,-3/21/426EAD,-15/-2/FEE530,-2/-2/CAB348,3/-2/847329,0/-2/D4C447"
    defaultSummonPattern := "|<>*156$30.zzzzzzy1zzjs0Tzzc01zy000Tw000DE0001E001Cs000bk003DFU00W3U01kDU01s/000Q2U01kNUATyQsRSCQyxTyHazsy7nQzwTtxjyLOTLw3PAy00000DVPfyNkPAy1sE6GRw0bUBT060RU"

    ; Use custom patterns if available, otherwise use defaults
    reflectingShieldPattern := (gnollBuffImagePattern != "") ? gnollBuffImagePattern : defaultReflectingShieldPattern
    summonPattern := (customSummonPattern != "") ? customSummonPattern : defaultSummonPattern

    ; ensure target window exists
    IfWinNotExist, ahk_id %win1%
        return false

    WinGetPos, winX, winY, winW, winH, ahk_id %win1%

    ; pre-check if gnoll buff already exists (if so, skip)
    if (FindText(rx, ry, winX, winY, winX + winW, winY + winH, 0, 0, reflectingShieldPattern))
    {
        ; Click at 10,10 to ensure game window is ready before casting skill
        lParam := (10 << 16) | (10 & 0xFFFF)
        SendMessage, 0x201, 1, %lParam%,, ahk_id %win1% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %win1% ; WM_LBUTTONUP
        Sleep, 100

        ; Inline replacement for SendMessageClick(rx, ry) to avoid calling another function
        winId := win1
        WinGetPos, winX, winY,,, ahk_id %winId%
        relativeX := rx - winX
        relativeY := ry - winY
        ; Adjust for typical window borders/title bar
        relativeX -= 8
        relativeY -= 31
        lParam := (relativeY << 16) | (relativeX & 0xFFFF)
        ; Send mouse down/up twice (matches SendMessageClick behavior)
        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
        Sleep, 50
        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
        Sleep, 200
        if (NavigationPausedForBuff) {
            ResumeNavigationAfterBuff()
        }
        return
    }

    ; 1) Find gnoll on screen with fallback recovery - try all patterns
    gx := ""
    gy := ""
    foundGnoll := false

    ; Try to find gnoll with any of the stored patterns
    for index, gnollPattern in gnollPatterns {
        if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, gnollPattern)) {
            foundGnoll := true
            break
        }
    }

    if (!foundGnoll) {
        ; Gnoll not found - try pressing ESC 3 times
        Loop, 3 {
            ControlSend, , {Escape}, ahk_id %win1%
            Sleep, 100
        }
        Sleep, 300

        ; Check again for gnoll with all patterns
        WinGetPos, winX, winY, winW, winH, ahk_id %win1%
        foundGnoll := false
        for index, gnollPattern in gnollPatterns {
            if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, gnollPattern)) {
                foundGnoll := true
                break
            }
        }

        if (!foundGnoll) {
            ; Still not found - try pressing R
            ControlSend, , r, ahk_id %win1%
            Sleep, 500

            ; Check again with all patterns
            WinGetPos, winX, winY, winW, winH, ahk_id %win1%
            foundGnoll := false
            for index, gnollPattern in gnollPatterns {
                if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, gnollPattern)) {
                    foundGnoll := true
                    break
                }
            }

            if (!foundGnoll) {
                ; Still not found - try pressing R again
                ControlSend, , r, ahk_id %win1%
                Sleep, 500

                ; Final check with all patterns
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                foundGnoll := false
                for index, gnollPattern in gnollPatterns {
                    if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, gnollPattern)) {
                        foundGnoll := true
                        break
                    }
                }

                if (!foundGnoll) {
                    ; Abandon the process
                    tooltipX := winX + (winW / 2)
                    tooltipY := winY + (winH * 0.70)
                    ToolTip, Gnoll Buff Failed: Creature not found`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                    SetTimer, RemoveGnollFailTooltip, -5000
                    SetTimer, gnollRetry, -65000
                    return false
                }
            }
        }
    }

    ; 2) ControlClick the gnoll inside the game window
    WinGetPos, winX, winY,,, ahk_id %win1%
    relX := gx - winX
    relY := gy - winY
    ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1
    Sleep, 150
    ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1
    ; 3) Check if summon skill appears - if not, try recovery steps
    Sleep, 500
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
    if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
        ; Summon not found - try pressing ESC 3 times
        Loop, 3 {
            ControlSend, , {Escape}, ahk_id %win1%
            Sleep, 100
        }
        Sleep, 300

        ; Check again for summon
        if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
            ; Still not found - try pressing R
            ControlSend, , r, ahk_id %win1%
            Sleep, 500

            ; Final check
            if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
                ; Abandon the process
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Gnoll Buff Failed: Summon skill not found`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveGnollFailTooltip, -5000
                SetTimer, gnollRetry, -65000
                return false
            }
        }
    }

    ; 4) While "summon" icon/pattern exists, send custom summon keybind
    start := A_TickCount
    Loop {
        if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern))
            break

        ; Send custom summon keybind with proper modifier handling
        SendKeybind(summonKeybind, "ahk_id " . win1)

        Sleep, 200

        ; safety timeout (15s)
        if (A_TickCount - start > 15000)
            break
    }

    Sleep, 1000

    ; Click at 10,10 to ensure game window is ready before casting skill
    lParam := (10 << 16) | (10 & 0xFFFF)
    SendMessage, 0x201, 1, %lParam%,, ahk_id %win1% ; WM_LBUTTONDOWN
    Sleep, 50
    SendMessage, 0x202, 0, %lParam%,, ahk_id %win1% ; WM_LBUTTONUP
    Sleep, 100

    ; 5) Click reflecting shield until it is no longer found (use SendMessageClick for reliability)
    ; 9 second timeout - if skill never disappears, retry in 30 seconds
    start := A_TickCount
    skillFound := false
    lastSkillSeen := A_TickCount
    Loop {
        ; First check if we can find the skill
        if (FindText(rx, ry, winX, winY, winX + winW, winY + winH, 0, 0, reflectingShieldPattern)) {
            skillFound := true
            lastSkillSeen := A_TickCount

            ; Check timeout - if skill has been visible for 9+ seconds, give up
            if (A_TickCount - start > 9000) {
                ; Skill never disappeared within 9 seconds - retry in 1 minute 5 seconds
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Gnoll Buff Failed: Skill timed out (9s)`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveGnollFailTooltip, -5000
                SetTimer, gnollRetry, -65000
                return false
            }

            ; Inline replacement for SendMessageClick(rx, ry) to avoid calling another function
            winId := win1
            WinGetPos, winX, winY,,, ahk_id %winId%
            relativeX := rx - winX
            relativeY := ry - winY
            ; Adjust for typical window borders/title bar
            relativeX -= 8
            relativeY -= 31
            lParam := (relativeY << 16) | (relativeX & 0xFFFF)
            ; Send mouse down/up twice (matches SendMessageClick behavior)
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
            Sleep, 50
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
            Sleep, 200
        } else {
            ; Skill not found - if we saw it before, it disappeared (success)
            if (skillFound) {
                break
            }
            ; If we never saw the skill and more than 2 seconds passed, it's a failure
            if (A_TickCount - start > 2000) {
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Gnoll Buff Failed: Skill never appeared`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveGnollFailTooltip, -5000
                SetTimer, gnollRetry, -65000
                ResumeNavigationAfterBuff()
                return false
            }
            ; Otherwise wait a bit and check again
            Sleep, 100
        }
    }

    ResumeNavigationAfterBuff()
return true
}

; Retry gnoll buff after failed attempt or blocked during navigation
gnollRetry:
    SetTimer, gnollRetry, Off
    gnoll()
return

DeathTyrant(force := false) {
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return false
    }

    ; If navigation is running, set flag instead of executing, unless forced
    if ((NavIsTraveling || IsTraveling) && !force) {
        dtBuffNeeded := true
        return false
    }

    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }

    global deathTyrantPatterns, dtBuffImagePattern, customSummonPattern, summonKeybind

    ; Default patterns (fallback if custom not set)
    defaultMonarchPattern := "|<>1F2024-0.74$20.zgMkPgPmwTwlDQ4Ta07V01sLsQDwT367Xk3szVwykTTU7zY3zy1zzkTzxzzzzzzzzzzzzyU"
    defaultMonarchPattern .= "|<>2E9AC1-0.77$21.y001zU00C000s3078s3vi0bMLYM46U00nU0TM2Dy0szED8A3d30E6k60y00NU06A01rU00y004"
    defaultSummonPattern := "|<>*156$30.zzzzzzy1zzjs0Tzzc01zy000Tw000DE0001E001Cs000bk003DFU00W3U01kDU01s/000Q2U01kNUATyQsRSCQyxTyHazsy7nQzwTtxjyLOTLw3PAy00000DVPfyNkPAy1sE6GRw0bUBT060RU"

    ; Use custom patterns if available, otherwise use defaults
    monarch := (dtBuffImagePattern != "") ? dtBuffImagePattern : defaultMonarchPattern
    summonPattern := (customSummonPattern != "") ? customSummonPattern : defaultSummonPattern

    ; Get window position first before any checks
    IfWinNotExist, ahk_id %win1%
    {
        ResumeNavigationAfterBuff()
        return false
    }
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%

    ; pre-check if DT buff already exists (if so, skip)
    if (FindText(rx, ry, winX, winY, winX + winW, winY + winH, 0, 0, monarch))
    {
        ; Click at 10,10 to ensure game window is ready before casting skill
        lParam := (10 << 16) | (10 & 0xFFFF)
        SendMessage, 0x201, 1, %lParam%,, ahk_id %win1% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %win1% ; WM_LBUTTONUP
        Sleep, 100

        ; Inline replacement for SendMessageClick(rx, ry) to avoid calling another function
        winId := win1
        WinGetPos, winX, winY,,, ahk_id %winId%
        relativeX := rx - winX
        relativeY := ry - winY
        ; Adjust for typical window borders/title bar
        relativeX -= 8
        relativeY -= 31
        lParam := (relativeY << 16) | (relativeX & 0xFFFF)
        ; Send mouse down/up twice (matches SendMessageClick behavior)
        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
        Sleep, 50
        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
        Sleep, 200 
        if (NavigationPausedForBuff) {
            ResumeNavigationAfterBuff()
        }
        return
    }

    ; 1) Find Death Tyrant on screen with fallback recovery - try all patterns
    gx := ""
    gy := ""
    foundDT := false

    ; Try to find Death Tyrant with any of the stored patterns
    for index, DeathTyrantPattern in deathTyrantPatterns {
        if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, DeathTyrantPattern)) {
            foundDT := true
            break
        }
    }

    if (!foundDT) {
        ; Death Tyrant not found - try pressing ESC 3 times
        Loop, 3 {
            ControlSend, , {Escape}, ahk_id %win1%
            Sleep, 100
        }
        Sleep, 300

        ; Check again for Death Tyrant with all patterns
        WinGetPos, winX, winY, winW, winH, ahk_id %win1%
        foundDT := false
        for index, DeathTyrantPattern in deathTyrantPatterns {
            if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, DeathTyrantPattern)) {
                foundDT := true
                break
            }
        }

        if (!foundDT) {
            ; Still not found - try pressing R
            ControlSend, , r, ahk_id %win1%
            Sleep, 500

            ; Check again with all patterns
            WinGetPos, winX, winY, winW, winH, ahk_id %win1%
            foundDT := false
            for index, DeathTyrantPattern in deathTyrantPatterns {
                if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, DeathTyrantPattern)) {
                    foundDT := true
                    break
                }
            }

            if (!foundDT) {
                ; Still not found - try pressing R again
                ControlSend, , r, ahk_id %win1%
                Sleep, 500

                ; Final check with all patterns
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                foundDT := false
                for index, DeathTyrantPattern in deathTyrantPatterns {
                    if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, DeathTyrantPattern)) {
                        foundDT := true
                        break
                    }
                }

                if (!foundDT) {
                    ; Abandon the process
                    tooltipX := winX + (winW / 2)
                    tooltipY := winY + (winH * 0.70)
                    ToolTip, Death Tyrant Buff Failed: Creature not found`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                    SetTimer, RemoveDTFailTooltip, -5000
                    SetTimer, deathTyrantRetry, -65000
                    ResumeNavigationAfterBuff()
                    return false
                }
            }
        }
    }

    ; 2) ControlClick the Death Tyrant inside the game window
    WinGetPos, winX, winY,,, ahk_id %win1%
    relX := gx - winX
    relY := gy - winY
    ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1
    Sleep, 150
    ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1
    ; 3) Check if summon skill appears - if not, try recovery steps
    Sleep, 500
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
    if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
        ; Summon not found - try pressing ESC 3 times
        Loop, 3 {
            ControlSend, , {Escape}, ahk_id %win1%
            Sleep, 100
        }
        Sleep, 300

        ; Check again for summon
        if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
            ; Still not found - try pressing R
            ControlSend, , r, ahk_id %win1%
            Sleep, 500

            ; Final check
            if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
                ; Abandon the process
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Death Tyrant Buff Failed: Summon skill not found`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveDTFailTooltip, -5000
                SetTimer, deathTyrantRetry, -65000
                ResumeNavigationAfterBuff()
                return false
            }
        }
    }

    ; 4) While "summon" icon/pattern exists, send custom summon keybind
    start := A_TickCount
    Loop {
        if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern))
            break

        ; Send custom summon keybind (default: Shift+=)
        SendKeybind(summonKeybind, "ahk_id " . win1)

        Sleep, 200

        ; safety timeout (15s)
        if (A_TickCount - start > 15000)
            break
    }

    Sleep, 1000

    ; Click at 10,10 to ensure game window is ready before casting skill
    lParam := (10 << 16) | (10 & 0xFFFF)
    SendMessage, 0x201, 1, %lParam%,, ahk_id %win1% ; WM_LBUTTONDOWN
    Sleep, 50
    SendMessage, 0x202, 0, %lParam%,, ahk_id %win1% ; WM_LBUTTONUP
    Sleep, 100

    ; 5) Click monarch until it is no longer found (use SendMessageClick for reliability)
    ; 9 second timeout - if skill never disappears, retry in 30 seconds
    start := A_TickCount
    skillFound := false
    lastSkillSeen := A_TickCount
    Loop {
        ; First check if we can find the skill
        if (FindText(rx, ry, winX, winY, winX + winW, winY + winH, 0, 0, monarch)) {
            skillFound := true
            lastSkillSeen := A_TickCount

            ; Check timeout - if skill has been visible for 9+ seconds, give up
            if (A_TickCount - start > 9000) {
                ; Skill never disappeared within 9 seconds - retry in 1 minute 5 seconds
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Death Tyrant Buff Failed: Skill timed out (9s)`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveDTFailTooltip, -5000
                SetTimer, deathTyrantRetry, -65000
                ResumeNavigationAfterBuff()
                return false
            }

            ; Inline replacement for SendMessageClick(rx, ry) to avoid calling another function
            winId := win1
            WinGetPos, winX, winY,,, ahk_id %winId%
            relativeX := rx - winX
            relativeY := ry - winY
            ; Adjust for typical window borders/title bar
            relativeX -= 8
            relativeY -= 31
            lParam := (relativeY << 16) | (relativeX & 0xFFFF)
            ; Send mouse down/up twice (matches SendMessageClick behavior)
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
            Sleep, 50
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
            Sleep, 200
        } else {
            ; Skill not found - if we saw it before, it disappeared (success)
            if (skillFound) {
                break
            }
            ; If we never saw the skill and more than 2 seconds passed, it's a failure
            if (A_TickCount - start > 2000) {
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Death Tyrant Buff Failed: Skill never appeared`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveDTFailTooltip, -5000
                SetTimer, deathTyrantRetry, -65000
                ResumeNavigationAfterBuff()
                return false
            }
            ; Otherwise wait a bit and check again
            Sleep, 100
        }
    }

    ResumeNavigationAfterBuff()
return true
}

; Retry Death Tyrant buff after failed attempt or blocked during navigation
deathTyrantRetry:
    SetTimer, deathTyrantRetry, Off
    DeathTyrant()
return

; Pet Buff Pattern Settings GUI
PetBuffSettings:
    Gui, PetBuff:New
    Gui, PetBuff:+AlwaysOnTop
    Gui, PetBuff:Font, s10

    ; Calculate pattern counts and timer intervals in minutes
    gnollPatternCount := gnollPatterns.Length()
    dtPatternCount := deathTyrantPatterns.Length()
    gnollMinutes := Round(gnollBuffInterval / 60000)
    dtMinutes := Round(dtBuffInterval / 60000)

    ; Gnoll Pattern Section
    Gui, PetBuff:Add, GroupBox, x10 y10 w580 h280, Gnoll Patterns & Buff Detection
    Gui, PetBuff:Add, Text, x20 y35 w560 h20, Capture additional Gnoll or Event pet appearance patterns. Current patterns: %gnollPatternCount%
    Gui, PetBuff:Add, Button, x20 y60 w140 h30 gCaptureGnollPattern, Capture Gnoll Pattern
    Gui, PetBuff:Add, Button, x170 y60 w140 h30 gListGnollPatterns, View Gnoll Patterns
    Gui, PetBuff:Add, Button, x320 y60 w140 h30 gClearGnollPatterns, Reset Gnoll Patterns
    Gui, PetBuff:Add, Button, x470 y60 w100 h30 gTestGnollPatterns, Test Patterns

    ; Gnoll Buff Image Detection
    Gui, PetBuff:Add, Text, x20 y100 w560 h20, Reflecting Shield Buff Detection (detects if buff already exists)
    Gui, PetBuff:Add, Button, x20 y125 w140 h30 gCaptureGnollBuff, Capture Shield Image
    Gui, PetBuff:Add, Button, x170 y125 w140 h30 gTestGnollBuff, Test Shield Detection
    Gui, PetBuff:Add, Button, x320 y125 w140 h30 gRemoveGnollBuff, Remove Shield Image

    ; Summon Pattern and Keybind
    Gui, PetBuff:Add, Text, x20 y165 w560 h20, Summon Pattern & Keybind Settings
    Gui, PetBuff:Add, Button, x20 y190 w140 h30 gCaptureSummonPattern, Capture Summon Pattern
    Gui, PetBuff:Add, Button, x170 y190 w140 h30 gTestSummonPattern, Test Summon Pattern
    Gui, PetBuff:Add, Button, x320 y190 w140 h30 gRemoveSummonPattern, Remove Summon Pattern
    Gui, PetBuff:Add, Text, x20 y230 w80 h20, Summon Key:
    Gui, PetBuff:Add, Edit, x105 y230 w100 h20 vSummonKeybindEdit, %summonKeybind%
    Gui, PetBuff:Add, Button, x210 y228 w100 h24 gSaveSummonKeybind, Save Keybind

    ; Timer Setting
    Gui, PetBuff:Add, Text, x20 y260 w120 h20, Buff Timer (minutes):
    Gui, PetBuff:Add, Edit, x145 y260 w60 h20 vGnollTimerInput, %gnollMinutes%
    Gui, PetBuff:Add, Button, x210 y258 w100 h24 gSaveGnollTimer, Save Timer

    ; Death Tyrant Pattern Section
    Gui, PetBuff:Add, GroupBox, x10 y300 w580 h280, Death Tyrant Patterns & Buff Detection
    Gui, PetBuff:Add, Text, x20 y325 w560 h20, Capture additional Death Tyrant or Event pet patterns. Current patterns: %dtPatternCount%
    Gui, PetBuff:Add, Button, x20 y350 w140 h30 gCaptureDTPattern, Capture DT Pattern
    Gui, PetBuff:Add, Button, x170 y350 w140 h30 gListDTPatterns, View DT Patterns
    Gui, PetBuff:Add, Button, x320 y350 w140 h30 gClearDTPatterns, Reset DT Patterns
    Gui, PetBuff:Add, Button, x470 y350 w100 h30 gTestDTPatterns, Test Patterns

    ; DT Buff Image Detection
    Gui, PetBuff:Add, Text, x20 y390 w560 h20, Monarch Buff Detection (detects if buff already exists)
    Gui, PetBuff:Add, Button, x20 y415 w140 h30 gCaptureDTBuff, Capture Monarch Image
    Gui, PetBuff:Add, Button, x170 y415 w140 h30 gTestDTBuff, Test Monarch Detection
    Gui, PetBuff:Add, Button, x320 y415 w140 h30 gRemoveDTBuff, Remove Monarch Image

    ; Timer Setting
    Gui, PetBuff:Add, Text, x20 y455 w120 h20, Buff Timer (minutes):
    Gui, PetBuff:Add, Edit, x145 y455 w60 h20 vDTTimerInput, %dtMinutes%
    Gui, PetBuff:Add, Button, x210 y453 w100 h24 gSaveDTTimer, Save Timer

    ; Status Area
    Gui, PetBuff:Add, GroupBox, x10 y590 w580 h80, Status
    Gui, PetBuff:Add, Text, x20 y615 w560 h45 vPetBuffStatus, Ready to capture patterns and images...

    ; Close button
    Gui, PetBuff:Add, Button, x245 y680 w110 h30 gPetBuffSettingsClose, Close

    Gui, PetBuff:Show, w600 h725, Pet Buff Pattern Settings
return

PetBuffSettingsClose:
    Gui, PetBuff:Destroy
return

PetBuffGuiClose:
    Gui, PetBuff:Destroy
return

; Save Gnoll Timer
SaveGnollTimer:
    Gui, PetBuff:Submit, NoHide

    ; Validate input
    if (GnollTimerInput < 1 || GnollTimerInput > 999) {
        GuiControl, PetBuff:, PetBuffGnollStatus, Invalid timer! Please enter 1-999 minutes.
        return
    }

    ; Convert minutes to milliseconds and save
    gnollBuffInterval := GnollTimerInput * 60000
    SavePetBuffTimers()

    ; Update the timer if gnoll buff is already active
    if (gnollbuff = true) {
        SetTimer, gnoll, %gnollBuffInterval%
    }

    ; Update the main GUI checkbox label
    Gui, 1:Default
    GuiControl,, gnollbuff, Enable Gnoll Buff (%GnollTimerInput% mins)

    GuiControl, PetBuff:, PetBuffGnollStatus, Gnoll timer set to %GnollTimerInput% minutes.
return
; Function to load max resurrections from INI
LoadMaxResurrections() {
    IniRead, loadedMaxRes, %iniFile%, Settings, MaxResurrections, 8
    MaxResurrections := loadedMaxRes
    ; Update GUI display
    GuiControl,, MaxResurrectionsEdit, %MaxResurrections%
    GuiControl,, ResurrectionStatus, Count: %CurrentResurrections%/%MaxResurrections%
}

; Function to save max resurrections to INI
SaveMaxResurrections(newMaxRes) {
    MaxResurrections := newMaxRes
    IniWrite, %newMaxRes%, %iniFile%, Settings, MaxResurrections
    ; Update GUI display before reload
    GuiControl,, ResurrectionStatus, Count: %CurrentResurrections%/%MaxResurrections%
    ; Reload script to apply new setting
    Reload
}
; Save Death Tyrant Timer
SaveDTTimer:
    Gui, PetBuff:Submit, NoHide

    ; Validate input
    if (DTTimerInput < 1 || DTTimerInput > 999) {
        GuiControl, PetBuff:, PetBuffDTStatus, Invalid timer! Please enter 1-999 minutes.
        return
    }

    ; Convert minutes to milliseconds and save
    dtBuffInterval := DTTimerInput * 60000
    SavePetBuffTimers()

    ; Update the timer if DT buff is already active
    if (dtbuff = true) {
        SetTimer, DeathTyrant, %dtBuffInterval%
    }

    ; Update the main GUI checkbox label
    Gui, 1:Default
    GuiControl,, dtbuff, Enable Death Tyrant Buff (%DTTimerInput% mins)

    GuiControl, PetBuff:, PetBuffDTStatus, Death Tyrant timer set to %DTTimerInput% minutes.
return

; Capture new gnoll pattern
CaptureGnollPattern:
    GuiControl, PetBuff:, PetBuffGnollStatus, Hover over gnoll and press 1 to capture...
    KeyWait, 1, D
    capturedPattern := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedPattern != "") {
        gnollPatterns.Push(capturedPattern)
        SavePetBuffPatterns()
        gnollPatternCount := gnollPatterns.Length()
        GuiControl, PetBuff:, PetBuffGnollStatus, Gnoll pattern captured! Total patterns: %gnollPatternCount%
        ; Update the count in the groupbox text
        Gui, PetBuff:Destroy
        Goto, PetBuffSettings
    } else {
        GuiControl, PetBuff:, PetBuffGnollStatus, Failed to capture pattern. Try again.
    }
return

; Capture new Death Tyrant pattern
CaptureDTPattern:
    GuiControl, PetBuff:, PetBuffDTStatus, Hover over Death Tyrant and press 1 to capture...
    KeyWait, 1, D
    capturedPattern := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedPattern != "") {
        deathTyrantPatterns.Push(capturedPattern)
        SavePetBuffPatterns()
        dtPatternCount := deathTyrantPatterns.Length()
        GuiControl, PetBuff:, PetBuffDTStatus, Death Tyrant pattern captured! Total patterns: %dtPatternCount%
        ; Update the count in the groupbox text
        Gui, PetBuff:Destroy
        Goto, PetBuffSettings
    } else {
        GuiControl, PetBuff:, PetBuffDTStatus, Failed to capture pattern. Try again.
    }
return

; List all gnoll patterns
ListGnollPatterns:
    if (gnollPatterns.Length() = 0) {
        MsgBox, No gnoll patterns captured yet.
        return
    }

    patternList := "=== GNOLL PATTERNS ===`n`n"
    for index, pattern in gnollPatterns {
        ; Show first 60 characters of each pattern
        patternPreview := SubStr(pattern, 1, 60)
        if (StrLen(pattern) > 60)
            patternPreview .= "..."
        patternList .= index . ". " . patternPreview . "`n`n"
    }

    MsgBox, 0, Gnoll Patterns, %patternList%
return

; List all Death Tyrant patterns
ListDTPatterns:
    if (deathTyrantPatterns.Length() = 0) {
        MsgBox, No Death Tyrant patterns captured yet.
        return
    }

    patternList := "=== DEATH TYRANT PATTERNS ===`n`n"
    for index, pattern in deathTyrantPatterns {
        ; Show first 60 characters of each pattern
        patternPreview := SubStr(pattern, 1, 60)
        if (StrLen(pattern) > 60)
            patternPreview .= "..."
        patternList .= index . ". " . patternPreview . "`n`n"
    }

    MsgBox, 0, Death Tyrant Patterns, %patternList%
return

; Clear all gnoll patterns
ClearGnollPatterns:
    MsgBox, 4, Clear Gnoll Patterns, Are you sure you want to reset to the default gnoll pattern?`n`nThis will remove all additional patterns you captured.
    IfMsgBox Yes
    {
        ; Reset to default pattern
        defaultGnollPattern := "|<>9E9F85-0.66$32.nzsPGAzy4xbTwzTNrzaBkxyw0k6TC6Nhj270u3H74T4y237yNk1Xz6w0Fzxj08TyEw47zAj23zznk0ztyM0TzLk07zsTU1zysTUT7c"
        gnollPatterns := []
        gnollPatterns.Push(defaultGnollPattern)
        SavePetBuffPatterns()
        GuiControl, PetBuff:, PetBuffGnollStatus, Reset to default gnoll pattern.
        ; Refresh the GUI
        Gui, PetBuff:Destroy
        Goto, PetBuffSettings
    }
return

; Clear all Death Tyrant patterns
ClearDTPatterns:
    MsgBox, 4, Clear DT Patterns, Are you sure you want to reset to the default Death Tyrant patterns?`n`nThis will remove all additional patterns you captured.
    IfMsgBox Yes
    {
        ; Reset to default patterns
        defaultDTPattern1 := "|<>E5A657-0.52$19.rTszTwPjz5vzurzVv0sTUxD0ya2ML0CHCDDj3azW0Tk0hk1bU1rk0nw0vDsxwzWk1z0000001"
        defaultDTPattern2 := "|<>*94$16.QbRbnqTiNvz7rwjznTrSztwTbwuTzfzrBzwDzkTzU"
        deathTyrantPatterns := []
        deathTyrantPatterns.Push(defaultDTPattern1)
        deathTyrantPatterns.Push(defaultDTPattern2)
        SavePetBuffPatterns()
        GuiControl, PetBuff:, PetBuffDTStatus, Reset to default Death Tyrant patterns.
        ; Refresh the GUI
        Gui, PetBuff:Destroy
        Goto, PetBuffSettings
    }
return

; Test gnoll patterns on screen
TestGnollPatterns:
    if (gnollPatterns.Length() = 0) {
        GuiControl, PetBuff:, PetBuffGnollStatus, No gnoll patterns to test!
        return
    }

    GuiControl, PetBuff:, PetBuffGnollStatus, Testing gnoll patterns on screen...

    foundCount := 0
    for index, pattern in gnollPatterns {
        if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, pattern)) {
            foundCount++
            GuiControl, PetBuff:, PetBuffGnollStatus, Found gnoll with pattern %index% at (%X%, %Y%)

            ; Highlight the found gnoll with MouseTip
            Try {
                For i, v in ok {
                    if (i <= 2)
                        FindText().MouseTip(ok[i].x, ok[i].y)
                }
            }
            Sleep, 2000
        }
    }

    if (foundCount = 0) {
        GuiControl, PetBuff:, PetBuffGnollStatus, No gnoll found on screen with any pattern.
    } else {
        GuiControl, PetBuff:, PetBuffGnollStatus, Test complete! Found %foundCount% gnoll(s).
    }
return

; Test Death Tyrant patterns on screen
TestDTPatterns:
    if (deathTyrantPatterns.Length() = 0) {
        GuiControl, PetBuff:, PetBuffDTStatus, No Death Tyrant patterns to test!
        return
    }

    GuiControl, PetBuff:, PetBuffDTStatus, Testing Death Tyrant patterns on screen...

    foundCount := 0
    for index, pattern in deathTyrantPatterns {
        if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, pattern)) {
            foundCount++
            GuiControl, PetBuff:, PetBuffDTStatus, Found DT with pattern %index% at (%X%, %Y%)

            ; Highlight the found Death Tyrant with MouseTip
            Try {
                For i, v in ok {
                    if (i <= 2)
                        FindText().MouseTip(ok[i].x, ok[i].y)
                }
            }
            Sleep, 2000
        }
    }

    if (foundCount = 0) {
        GuiControl, PetBuff:, PetBuffDTStatus, No Death Tyrant found on screen with any pattern.
    } else {
        GuiControl, PetBuff:, PetBuffDTStatus, Test complete! Found %foundCount% Death Tyrant(s).
    }
return

; Remove gnoll failure tooltip
RemoveGnollFailTooltip:
    ToolTip,,,,1
return

; ========= NEW BUFF IMAGE CAPTURE FUNCTIONS =========

; Capture Gnoll Reflecting Shield buff image
CaptureGnollBuff:
    GuiControl, PetBuff:, PetBuffStatus, Press 1 when the Reflecting Shield buff icon is visible on screen.
    KeyWait, 1, D
    capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedText) {
        gnollBuffImagePattern := capturedText
        Clipboard := capturedText
        ; Save to settings
        FileEncoding, UTF-8
        IniWrite, %gnollBuffImagePattern%, %SettingsFile%, PetBuffImages, GnollBuffPattern
        FileEncoding

        GuiControl, PetBuff:, PetBuffStatus, Reflecting Shield buff image captured successfully!
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Failed to capture Reflecting Shield buff image. Try again.
    }
return

CheckGnollBuffCapture:
    ; This timer will be stopped when F1 is pressed
return

; Test Gnoll buff detection
TestGnollBuff:
    if (gnollBuffImagePattern = "") {
        GuiControl, PetBuff:, PetBuffStatus, No Reflecting Shield image captured yet! Please capture first.
        return
    }

    GuiControl, PetBuff:, PetBuffStatus, Testing Reflecting Shield detection on screen...

    if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, gnollBuffImagePattern)) {
        GuiControl, PetBuff:, PetBuffStatus, Reflecting Shield buff found at (%X%, %Y%)!

        ; Highlight the found buff
        Try {
            For i, v in ok {
                if (i <= 1)
                    FindText().MouseTip(ok[i].x, ok[i].y)
            }
        }
        Sleep, 3000
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Reflecting Shield buff not found on screen.
    }
return

; Remove Gnoll buff image
RemoveGnollBuff:
    gnollBuffImagePattern := ""
    IniDelete, %SettingsFile%, PetBuffImages, GnollBuffPattern
    GuiControl, PetBuff:, PetBuffStatus, Reflecting Shield buff image removed.
return

; Capture DT Monarch buff image
CaptureDTBuff:
    GuiControl, PetBuff:, PetBuffStatus, Press 1 when the Monarch buff icon is visible on screen.
    KeyWait, 1, D
    capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedText) {
        dtBuffImagePattern := capturedText
        Clipboard := capturedText
        ; Save to settings
        FileEncoding, UTF-8
        IniWrite, %dtBuffImagePattern%, %SettingsFile%, PetBuffImages, DTBuffPattern
        FileEncoding

        GuiControl, PetBuff:, PetBuffStatus, Monarch buff image captured successfully!
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Failed to capture Monarch buff image. Try again.
    }
return

CheckDTBuffCapture:
    ; This timer will be stopped when F1 is pressed
return

; Test DT buff detection
TestDTBuff:
    if (dtBuffImagePattern = "") {
        GuiControl, PetBuff:, PetBuffStatus, No Monarch image captured yet! Please capture first.
        return
    }

    GuiControl, PetBuff:, PetBuffStatus, Testing Monarch detection on screen...

    if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, dtBuffImagePattern)) {
        GuiControl, PetBuff:, PetBuffStatus, Monarch buff found at (%X%, %Y%)!

        ; Highlight the found buff
        Try {
            For i, v in ok {
                if (i <= 1)
                    FindText().MouseTip(ok[i].x, ok[i].y)
            }
        }
        Sleep, 3000
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Monarch buff not found on screen.
    }
return

; Remove DT buff image
RemoveDTBuff:
    dtBuffImagePattern := ""
    IniDelete, %SettingsFile%, PetBuffImages, DTBuffPattern
    GuiControl, PetBuff:, PetBuffStatus, Monarch buff image removed.
return

; Capture custom summon pattern
CaptureSummonPattern:
    GuiControl, PetBuff:, PetBuffStatus, Press 1 when the summon skill icon is visible on screen.
    KeyWait, 1, D
    capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedText) {
        customSummonPattern := capturedText
        Clipboard := capturedText
        ; Save to settings
        FileEncoding, UTF-8
        IniWrite, %customSummonPattern%, %SettingsFile%, PetBuffImages, SummonPattern
        FileEncoding

        GuiControl, PetBuff:, PetBuffStatus, Custom summon pattern captured successfully!
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Failed to capture summon pattern. Try again.
    }
return

CheckSummonCapture:
    ; This timer will be stopped when F1 is pressed
return

; Test summon pattern detection
TestSummonPattern:
    if (customSummonPattern = "") {
        GuiControl, PetBuff:, PetBuffStatus, No custom summon pattern captured yet! Please capture first.
        return
    }

    GuiControl, PetBuff:, PetBuffStatus, Testing custom summon pattern on screen...

    if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, customSummonPattern)) {
        GuiControl, PetBuff:, PetBuffStatus, Custom summon pattern found at (%X%, %Y%)!

        ; Highlight the found pattern
        Try {
            For i, v in ok {
                if (i <= 1)
                    FindText().MouseTip(ok[i].x, ok[i].y)
            }
        }
        Sleep, 3000
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Custom summon pattern not found on screen.
    }
return

; Remove custom summon pattern
RemoveSummonPattern:
    customSummonPattern := ""
    IniDelete, %SettingsFile%, PetBuffImages, SummonPattern
    GuiControl, PetBuff:, PetBuffStatus, Custom summon pattern removed.
return

; Save custom summon keybind
SaveSummonKeybind:
    Gui, PetBuff:Submit, NoHide
    summonKeybind := SummonKeybindEdit

    ; Save to settings
    FileEncoding, UTF-8
    IniWrite, %summonKeybind%, %SettingsFile%, PetBuffImages, SummonKeybind
    FileEncoding

    GuiControl, PetBuff:, PetBuffStatus, Summon keybind saved as: %summonKeybind%
return

; ========= END NEW BUFF IMAGE FUNCTIONS =========

; Helper function to send keybind with proper modifier handling
SendKeybind(keybind, targetWindow) {
    ; Parse AutoHotkey keybind syntax: +1 (Shift+1), ^1 (Ctrl+1), !1 (Alt+1), etc.

    ; Debug output
    ToolTip, SendKeybind called with: %keybind% to %targetWindow%, 100, 100, 2
    SetTimer, RemoveDebugTooltip, -2000

    ; Check for modifiers at the start of the string
    hasShift := InStr(keybind, "+") = 1
    hasCtrl := InStr(keybind, "^") = 1 
    hasAlt := InStr(keybind, "!") = 1

    ; Extract base key by removing modifier symbols from the beginning
    baseKey := keybind
    modifierCount := 0

    ; Remove modifiers one by one
    if (hasShift) {
        baseKey := SubStr(baseKey, 2)
        modifierCount++
    }
    if (hasCtrl) {
        baseKey := SubStr(baseKey, 2)
        modifierCount++
    }
    if (hasAlt) {
        baseKey := SubStr(baseKey, 2)
        modifierCount++
    }

    ; Debug what we parsed
    ToolTip, Parsed - Shift:%hasShift% Ctrl:%hasCtrl% Alt:%hasAlt% BaseKey:%baseKey%, 100, 120, 3
    SetTimer, RemoveDebugTooltip2, -3000

    ; Send modifiers down
    if (hasShift)
        ControlSend, , {Shift down}, %targetWindow%
    if (hasCtrl)
        ControlSend, , {Ctrl down}, %targetWindow%
    if (hasAlt)
        ControlSend, , {Alt down}, %targetWindow%

    Sleep, 25

    ; Send base key
    ControlSend, , {%baseKey% down}, %targetWindow%
    Sleep, 25
    ControlSend, , {%baseKey% up}, %targetWindow%

    Sleep, 25

    ; Send modifiers up (reverse order)
    if (hasAlt)
        ControlSend, , {Alt up}, %targetWindow%
    if (hasCtrl)
        ControlSend, , {Ctrl up}, %targetWindow%
    if (hasShift)
        ControlSend, , {Shift up}, %targetWindow%
}

RemoveDebugTooltip:
    ToolTip, , , , 2
return

RemoveDebugTooltip2:
    ToolTip, , , , 3
return

; Navigation pause/resume functions for pet buff execution
PauseNavigationForBuff() {
    global PetBuffExecuting, NavigationPausedForBuff, IsTraveling, NavIsTraveling

    ; Debug: Always show that function is called
    ;ToolTip, PAUSE called - IsTraveling:%IsTraveling% NavIsTraveling:%NavIsTraveling%, 100, 50, 5
    SetTimer, RemoveDebugPause, -3000

    ; Always pause navigation timers when this function is called
    PetBuffExecuting := true
    NavigationPausedForBuff := true

    ; Stop navigation timers but keep signal detection running
    SetTimer, NavTravelLoop, Off
    SetTimer, UpdateNavCoordinatesDisplay, Off
    SetTimer, TravelLoop, Off
    ; Keep TimerSignalCheck running so it can detect waypoint commands during pauses

    ; Visual feedback
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
    if (winX != "" && winY != "" && winW != "" && winH != "") {
        tooltipX := winX + (winW / 2)
        tooltipY := winY + (winH * 0.10)
        ToolTip, Navigation paused for pet buff..., %tooltipX%, %tooltipY%, 4
        }

}

RemoveDebugPause:
    ToolTip, , , , 5
return

ResumeNavigationAfterBuff() {
    global PetBuffExecuting, NavigationPausedForBuff, IsTraveling, NavIsTraveling

    ; Debug: Always show that function is called  
    ToolTip, RESUME called - IsTraveling:%IsTraveling% NavIsTraveling:%NavIsTraveling%, 100, 80, 6
    SetTimer, RemoveDebugResume, -3000

    PetBuffExecuting := false
    NavigationPausedForBuff := false

    ; Always restart navigation timers when this function is called
    SetTimer, NavTravelLoop, 100
    SetTimer, UpdateNavCoordinatesDisplay, 500
    SetTimer, TravelLoop, 50
    ;SetTimer, TimerSignalCheck, 100 ; Start signal checking timer

    ; Clear visual feedback
    ToolTip, , , , 4
}
return
; Separate timer for signal detection that doesn't get paused
; TimerSignalCheck:
;     ; Debug: Show that signal checking is running (only every 50 cycles = 5 seconds)
;     signalCheckCounter++
;     if (Mod(signalCheckCounter, 50) = 0) {
;         ;ToolTip, TimerSignalCheck running (%signalCheckCounter%), 500, 400, 8
;         SetTimer, RemoveSignalRunningDebug, -2000
;     }

;     ; Check for timer execution signal from waypoint scripts
;     signalFile := A_ScriptDir . "\timer_signal.tmp"
;     if (FileExist(signalFile)) {
;         FileDelete, %signalFile%
;         ;ToolTip, Signal detected - executing timer flags, 300, 300, 9
;         SetTimer, RemoveSignalDebug, -3000
;         CheckAndExecuteTimerFlags()
;     }
; return

RemoveSignalRunningDebug:
    ToolTip, , , , 8
return

RemoveDebugResume:
    ToolTip, , , , 6
return

; Remove Death Tyrant failure tooltip
RemoveDTFailTooltip:
    ToolTip,,,,1
return

DestroyskyPotionstimer:
    GuiControlGet, destroyskypotionstimer

    if (destroyskypotionstimer = 1)
    {
        ; Ask if user wants to destroy essences too
        MsgBox, 4, Destroy Essences?, Do you want to destroy essences too?
        IfMsgBox Yes
        {
            destroyessences := true
        }
        Else
        {
            destroyessences := false
        }

        destroypotions := true
        SetTimer, DestroyskyPotions, 1200000
        DestroySkyPotions()
    }
    else
    {
        destroypotions := false
        destroyessences := false
        SetTimer, DestroyskyPotions, Off
    }
Return 

DestroySkyPotions(force := false) {
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return
    }

    ; If navigation is running, set flag instead of executing
    if ((NavIsTraveling || IsTraveling) && !force) {
        potionDestroyNeeded := true
        return false
    }

    ; Pause navigation during potion destruction
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    sleep, 3000
    lvl3pot:="|<>*117$26.7wwE1z/20zqM0Dyb1rrds33tDzsqSTu933zWMTzMW0zrjvzxtzzzLTrzonwzwaTjz9nvy3yDw2"
    lvl3pot.="|<>*118$29.z7bc7wTD07tyS07Xww0CDtsUQTmkUlzgk1XzdkTjjHk4kyHztlgwzyWEmzz4kzy68UDwDTrzsSTzzkizjzd4DDz143Ty2A2zw2QTs47wTk8"
    lvl3pot.="|<>*127$14.nUQw7D0twDDXNzLAqsQnTDzszwDz7zvzyzzTzzzzzzzzzzzzzU"
    lvl3pot.="|<>*126$29.zlnw7z7bc7wTD07tyS0DXww0SDtsUwTmkVlzgk3XzdkTjjHkAkyHzllgszyWEkyz4kzy68UDsDTrzkSTzzk"

    ; Add essences patterns if user selected to destroy them
    if (destroyessences) {
        lvl3pot.="|<essences>*118$15.zzzzzzzzzzzzzzzzzzzzzkjs7s8s1hMUQ0703w"
        lvl3pot.="|<essences>*105$15.zzzzzzzzzzzzzzzztzy3zFykTk7sELw3w0T0qw"
        lvl3pot.="|<essences>*122$15.zzzzzzzzzzzzzzzziTr0s060EE06070SEsUc04"
    }

    inventory:="|<>*124$13.y3ySwzgztDwvuAx/K6f/YJuPQnqrx7zDw"
    inventory.="|<>*137$13.y3ySwzgztDwluAx/K6f/YJuPQnqrx7zDw"

    inventorytext:="|<>E8E9E9-0.90$29.0001000022FC/C+WWN8Yd4WF9Ht4WGY294W8YG94C8aA"

    destroytab:="|<>3F3F3F-0.86$20.zzzzzzzU03vzyyjyjhzPvjiyxrjjfvvxyyyjjjRvvjiyrxjfzfvzyy00Dzzzzzzs"
    destroytab.="|<>334356-0.90$26.000040011000EHzzY400117zwEFTx44Pyl17TQEFvj44TLl17vwEFxT44Svl17TQEFjv44LzF17zwEE0044zzt1000ETzzw00002"

    destroybutton:="|<>B92C36-0.90$29.s040080800/rvT0IsZZ0zN++VkOIT5U4grlzhD80000E0001c"

    ; Ensure win1 is valid
    IfWinNotExist, ahk_id %win1%
        Return

    ;WinActivate, ahk_id %win1%
    Sleep, 100

    ; Work only inside the game window bounds
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
    if (!winW || !winH)
        Return

    ; Main processing loop
    Loop {
        ; Open inventory with error handling
        ControlSend,, {i}, ahk_id %win1%
        Sleep, 100

        ; Verify inventory opened (wait up to 2 seconds)
        inventoryOpened := false
        Loop, 20 {
            if (FindText(invTextX, invTextY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                inventoryOpened := true
                Sleep, 10
                Break
            }
            Sleep, 100
        }

        ; If inventory didn't open, try again
        if (!inventoryOpened) {
            ControlSend,, {i}, ahk_id %win1%
            Sleep, 200
            ; Final check
            if !(FindText(invTextX, invTextY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                ; If still not open, exit
                Break
            }
        }

        ; 1) Find inventorytext and calculate potions tab position
        ; Original coordinates: inventorytext at 735,174 and potionstab at 918,373
        ; Offset: 183 right, 199 down
        if (FindText(invTextX, invTextY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
            ; Calculate potions tab position
            potionsTabX := invTextX + 183
            potionsTabY := invTextY + 199

            ; Click the potions tab
            winId := win1
            WinGetPos, winX, winY,,, ahk_id %winId%
            relativeX := potionsTabX - winX - 8
            relativeY := potionsTabY - winY - 31
            lParam := (relativeY << 16) | (relativeX & 0xFFFF)
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
            Sleep, 500
        } else {
            ; If inventory text not found, break
            Break
        }
        destroyTabClicked := false
        if (FindText(invTextX, invTextY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
            ; Calculate potions tab position
            DESTROYX := invTextX + 16
            DESTROYY := invTextY + 25

            ; Click the potions tab
            winId := win1
            WinGetPos, winX, winY,,, ahk_id %winId%
            relativeX := DESTROYX - winX - 8
            relativeY := DESTROYY - winY - 31
            lParam := (relativeY << 16) | (relativeX & 0xFFFF)
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
            Sleep, 80
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
            destroyTabClicked := true
            SLEEP, 200

        } else {
            ; If inventory text not found, break
            Break
        }
        ; 2) Click Destroy tab with retry logic
        ; W
        ; Loop, 3 {
        ;     if (FindText(dTabX, dTabY, winX, winY, winX + winW, winY + winH, 0, 0, destroytab)) {
        ;         winId := win1
        ;         WinGetPos, winX, winY,,, ahk_id %winId%
        ;         relativeX := dTabX - winX - 8
        ;         relativeY := dTabY - winY - 31
        ;         lParam := (relativeY << 16) | (relativeX & 0xFFFF)
        ;         SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
        ;         Sleep, 50
        ;         SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
        ;         Sleep, 50
        ;         SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
        ;         Sleep, 50
        ;         SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
        ;         Sleep, 300
        ;         destroyTabClicked := true
        ;         Break
        ;     }
        ;     Sleep, 200
        ; }

        ; If destroy tab wasn't found, continue to next iteration
        if (!destroyTabClicked) {
            BREAK
        }

        ; 3) Find all lvl3pot inside the window and Alt+Click each one
        lvl3Results := FindText()
        lvl3Results := FindText(xp, yp, winX, winY, winX + winW, winY + winH, 0, 0, lvl3pot)
        if (lvl3Results) {
            ; Hold Alt down
            ControlSend,, {Alt down}, ahk_id %win1%

            ;Send, {Alt down}
            Sleep, 50

            ; Click each potion found
            for idx, entry in lvl3Results {
                X := entry.x
                Y := entry.y

                ; Click with Alt held
                SendMessageClick2(X, Y, WIN1)
                ;FindText().Click(X, Y, "L")
                Sleep, 100
            }

            ; Release Alt
            ControlSend,, {Alt UP}, ahk_id %win1%
            Sleep, 100

            ; 4) Click destroy button (if present)
            destroyClicked := false
            Loop, 3 {
                if (FindText(destX, destY, winX, winY, winX + winW, winY + winH, 0, 0, destroybutton)) {
                    winId := win1
                    WinGetPos, winX, winY,,, ahk_id %winId%
                    relativeX := destX - winX - 8
                    relativeY := destY - winY - 31
                    lParam := (relativeY << 16) | (relativeX & 0xFFFF)
                    SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
                    Sleep, 50
                    SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
                    Sleep, 50
                    SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
                    Sleep, 50
                    SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
                    destroyClicked := true
                    Break
                }
                Sleep, 100
            }
        }

        ; 5) Wait and refresh inventory
        Sleep, 1000

        ; ; Click inventory button to refresh
        ; if (FindText(bInvX2, bInvY2, winX, winY, winX + winW, winY + winH, 0, 0, inventory)) {
        ;     winId := win1
        ;     WinGetPos, winX, winY,,, ahk_id %winId%
        ;     relativeX := bInvX2 - winX - 8
        ;     relativeY := bInvY2 - winY - 31
        ;     lParam := (relativeY << 16) | (relativeX & 0xFFFF)
        ;     SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
        ;     Sleep, 50
        ;     SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
        ;     Sleep, 50
        ;     SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
        ;     Sleep, 50
        ;     SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
        ; } 

        Sleep, 400

        ; Check if inventory needs to be closed or reopened
        Loop, {
            ; Check if inventory is still open
            if !(FindText(iX, iY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                ; Inventory closed - verify it's actually closed
                Sleep, 200
                if !(FindText(iX2, iY2, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                    ; Confirmed closed, exit inner loop
                    Break
                }
            }
            ; Inventory is still open, try to close/reopen it
            else if (FindText(bInvX, bInvY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                ControlSend,, {i}, ahk_id %win1%
                Sleep, 500

                ; Wait for inventory to close
                Loop, 10 {
                    if !(FindText(iX3, iY3, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                        Break
                    }
                    Sleep, 200
                }
                Break
            }
            Break
        }

        ; Final check - ensure inventory is closed before next iteration
        Sleep, 200
        if (FindText(finalCheckX, finalCheckY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
            ; Inventory still open, force close with 'i' key
            ControlSend,, {i}, ahk_id %win1%
            Sleep, 300
        }

        Break
    }
    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
Return
}

Farming:
    if (Farming = False)
    {
        ; Ask user to right-click pylon location
        MsgBox, 4, Set Pylon Location, Right-click on the location where the pylon will spawn.
        IfMsgBox No
        return

        ; Wait for right-click to capture coordinates
        KeyWait, RButton, D
        MouseGetPos, tempPylonX, tempPylonY
        KeyWait, RButton

        ; Convert to window-relative coordinates
        WinGetPos, winX, winY,,, ahk_id %win1%
        pylonX := tempPylonX - winX
        pylonY := tempPylonY - winY

        MsgBox, Pylon location set to: %pylonX%, %pylonY% (relative to window)

        Farming := True
        LoadCoordinateSettings()
        settimer, capchacheck, 500
        SetTimer, essences, 30000
        SetTimer, buffdaddystone, 2000000
        SetTimer, buffpetscroll, 2017000
        settimer, checkweight, 250
        SetTimer, snapshot, 5000
        ;SetTimer, farmzone, 100
    }
    else if (Farming = True)
    {
        Farming := False
        settimer, capchacheck, off
        SetTimer, essences, off
        SetTimer, buffdaddystone, off
        SetTimer, buffpetscroll, off
        SetTimer, PylonClicker, off
    }
Return
Farmzone:

    mobhealth:="|<>C6053F-0.79$101.zzzzzzzzzzzzzzzzy0000000000000000Tzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzk"
    WinGetPos, winX, winY,,, ahk_id %winId%

    ; Calculate relative coordinates (simple screen to window conversion)
    relativeX := 255 - winX
    relativeY := 322 - winY
    relativex2 := 820 - winX
    relativey2 := 760 - winY

    ; Adjust for title bar and borders (typical Windows offset)
    relativeX := relativeX - 8
    relativeY := relativeY - 31
    if (ok:=FindText(X, Y, %relativeX%, %relativeY%, %relativex2%, %relativey2%, 0, 0, mobhealth))
    {
        ;SendMessageClick3(X, Y+40, win1)
        ;MouseClick, left, %X%, %Y%+30
        TryCastDPSSkills()
        sleep, 4000
    }
    ; FileRead, dpsEnabled, com.ini
    ; dpsEnabled := Trim(dpsEnabled)
    ; if (dpsEnabled = "1") {
    ;     TryCastDPSSkills()
    ; }
return
healanddps:
    Gui, Submit, NoHide
    if (healanddps) {
        ; Uncheck the other checkbox
        GuiControl,, dpstargetedhealing, 0
        dpstargetedhealing := false
    }
Return

returnafterheal:
    if (retrnafterheal = false)
    {
        returnafterheal := true
    }
    else if (returnafterheal = true)
    {
        retrnafterheal := false
    }
return

dpsNavEnabled:
    ; Get the actual checkbox state
    GuiControlGet, dpsNavEnabled

    if (dpsNavEnabled) {
        ; Checkbox is checked - turn ON
        MsgBox, DPS Navigation ENABLED. When using this feature, make sure to set your camera at 900 and change the angle to top down view for best results.
            ; Add any initialization code here for when navigation is enabled
        InitializeNavigation()
        dpsNavEnabled := true
    } else {
        ; Checkbox is unchecked - turn OFF  
        MsgBox, DPS Navigation DISABLED.
        ; Add any cleanup code here for when navigation is disabled
        SetTimer, UpdateNavCoordinatesDisplay, off
        dpsNavEnabled := false
    }
return

SetDPSNavCoords:
    if (!NavTargetGameWindow) {
        MsgBox, Please select a navigation window first!
        return
    }

    GetNavCurrentCoordinates(coordX, coordY)
    if (coordX = "" || coordY = "") {
        MsgBox, Could not get current coordinates!
        return
    }

    GuiControl,, dpsNavTargetXEdit, %coordX%
    GuiControl,, dpsNavTargetYEdit, %coordY%
    dpsNavTargetX := coordX
    dpsNavTargetY := coordY
    MsgBox, DPS Navigation coordinates set to X: %coordX% Y: %coordY%
return

SaveDPSNavCoords:
    Gui, Submit, NoHide
    dpsNavTargetX := dpsNavTargetXEdit
    dpsNavTargetY := dpsNavTargetYEdit
    dpsNavRadius := dpsNavRadiusEdit

    ; Validate radius (minimum 25)
    if (dpsNavRadius < 25) {
        dpsNavRadius := 25
        GuiControl,, dpsNavRadiusEdit, 25
        MsgBox, Radius cannot be less than 25. Set to minimum value.
    }

    ;IniWrite, %dpsNavEnabled%, dpsnavsettings.ini, Navigation, Enabled
    IniWrite, %dpsNavTargetX%, dpsnavsettings.ini, Navigation, TargetX
    IniWrite, %dpsNavTargetY%, dpsnavsettings.ini, Navigation, TargetY
    IniWrite, %dpsNavRadius%, dpsnavsettings.ini, Navigation, Radius

    MsgBox, DPS Navigation settings saved!
return

dpstargetedhealing:
    Gui, Submit, NoHide
    if (dpstargetedhealing) {
        ; Uncheck the other checkbox
        GuiControl,, healanddps, 0
        healanddps := false

        ; Ask for player and pet counts
        InputBox, playerCount, DPS Targeted Healing, Enter number of players (0-10):, , 300, 130, , , , , 0
        if (ErrorLevel)
            return

        InputBox, petCount, DPS Targeted Healing, Enter number of pets (0-10):, , 300, 130, , , , , 0
        if (ErrorLevel)
            return

        if (playerCount = 0 && petCount = 0) {
            MsgBox, Must have at least 1 player or pet
            GuiControl,, dpstargetedhealing, 0
            dpstargetedhealing := false
            return
        }

        ; Capture coordinates
        DPSTargetedPlayerCoords := []
        DPSTargetedPetCoords := []

        Gui, Hide

        if (playerCount > 0) {
            MsgBox, Right-click on %playerCount% player health bar locations
            Loop, %playerCount% {
                ToolTip, Right-click Player %A_Index% health bar, 100, 100
                KeyWait, RButton, D
                MouseGetPos, px, py
                DPSTargetedPlayerCoords.Push({x: px, y: py})
                KeyWait, RButton
                Sleep, 200
            }
        }

        if (petCount > 0) {
            MsgBox, Right-click on %petCount% pet health bar locations
            Loop, %petCount% {
                ToolTip, Right-click Pet %A_Index% health bar, 100, 100
                KeyWait, RButton, D
                MouseGetPos, px, py
                DPSTargetedPetCoords.Push({x: px, y: py})
                KeyWait, RButton
                Sleep, 200
            }
        }

        ToolTip
        Gui, Show

        MsgBox, DPS Targeted Healing configured: %playerCount% players, %petCount% pets
    }
Return
; Button handler for monitor selection
MonitorButton:
    monitorNum := A_GuiControl
    if (activeMonitors < maxMonitors) {
        GuiControl, Main:, MonitorStatus, Click on window %monitorNum% to monitor...
        KeyWait, LButton, D
        MouseGetPos,,, winId
        WinGetTitle, title, ahk_id %winId%

        ; Launch a new AHK process for this window
        Run, "%A_AhkPath%" "%A_ScriptDir%\MemoryMonitor%monitorNum%.ahk" "%winId%"

        activeMonitors++
        GuiControl, Main:, MonitorStatus, Monitoring %activeMonitors% window(s)
    } else {
        GuiControl, Main:, MonitorStatus, Maximum of %maxMonitors% windows reached
    }
return
Closemonitors:
    ; Close all monitor processes
    Loop, 8 {
        Process, Close, MemoryMonitor%A_Index%.ahk
    }
Return
Expmonitor:
    Run, %A_ScriptDir%\expperhour.ahk
return
altassist:
    Run, C:\Users\zombi\Desktop\ahk stuff\AA\AltAssistV2.exe
return
Rupeemonitor:
    Run, %A_ScriptDir%\rupeeperhour.ahk
return
SetSkillbarArea:
    ; Hide the GUI temporarily
    Gui, 1:Hide

    ; Instructions
    MsgBox, 4, Set Skillbar Area, Click OK then drag to select your skillbar area.`n`nPress ESC to cancel.
    IfMsgBox No
    {
        Gui, 1:Show
        return
    }

    ; Wait for left mouse button down to start dragging
    ToolTip, Click and drag to select the skillbar area (Press ESC to cancel), 100, 100

    ; Create overlay GUIs for the selection box (4 borders)
    borderThickness := 2

    ; Top border
    Gui, SelectionBoxTop:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
    Gui, SelectionBoxTop:Color, Red

    ; Bottom border
    Gui, SelectionBoxBottom:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
    Gui, SelectionBoxBottom:Color, Red

    ; Left border
    Gui, SelectionBoxLeft:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
    Gui, SelectionBoxLeft:Color, Red

    ; Right border
    Gui, SelectionBoxRight:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
    Gui, SelectionBoxRight:Color, Red

    ; Wait for left button down
    KeyWait, LButton, D

    ; Get starting position
    MouseGetPos, startX, startY

    ; Initialize tracking variables
    lastSelectionX := startX
    lastSelectionY := startY
    selectionBoxHwnd := ""

    ; Track mouse movement and draw selection box
    SetTimer, UpdateSelectionBox, 200

    ; Wait for left button release
    KeyWait, LButton

    ; Stop updating the box
    SetTimer, UpdateSelectionBox, Off

    ; Get ending position
    MouseGetPos, endX, endY

    ; Clean up all selection box GUIs
    Gosub, CleanupSelectionBox
    ToolTip

    ; Ensure we have valid coordinates (X1 < X2 and Y1 < Y2)
    tempX1 := (startX < endX) ? startX : endX
    tempX2 := (startX < endX) ? endX : startX
    tempY1 := (startY < endY) ? startY : endY
    tempY2 := (startY < endY) ? endY : startY

    ; Validate coordinates
    if (tempX1 >= tempX2 || tempY1 >= tempY2) {
        MsgBox, 16, Error, Invalid selection! Area is too small.
        Gosub, CleanupSelectionBox
        Gui, 1:Show
        return
    }

    ; Convert to window-relative coordinates
    WinGetPos, winX, winY,,, ahk_id %win1%
    SkillBarX1 := tempX1 - winX
    SkillBarY1 := tempY1 - winY
    SkillBarX2 := tempX2 - winX
    SkillBarY2 := tempY2 - winY

    ; Calculate dimensions
    width := SkillBarX2 - SkillBarX1
    height := SkillBarY2 - SkillBarY1

    ; Save to INI file
    SaveSkillbarCoordinates()

    ; Update the display
    UpdateSkillbarDisplay()

    ; Show the GUI again first
    Gui, 1:Show

    ; Show success message
    MsgBox, 64, Success, Skillbar area updated successfully!`n`nNew coordinates:`nTop-left: %SkillBarX1%,%SkillBarY1%`nBottom-right: %SkillBarX2%,%SkillBarY2%`n`nArea size: %width%x%height% pixels
return

; Bounding box function for creating selection rectangles
bounding_box(color, x, y, w, h) {
    tc := 0x1 ; Transparent color
    Gui, New, -Caption +AlwaysOnTop +LastFound hwndgoo ; Make a gui with no caption (window features) and always on top
    opt := "x0 y0 w" w " h" h " c" tc " Background" color ; Progress bar options. Set bar color to tc and background to desired color
    Gui, Add, Progress, % opt, 100 ; Add progress bar to gui
    WinSet, TransColor, % tc ; Set the transparent color of the window
    Gui, Show, % "x" x " y" y " w" w " h" h ; Show the GUI. All that should show is the progress bar's outline box
return goo ; Return gui hwnd to further extend usability. Make a show/hide hotkey for example.
}

UpdateSelectionBox:
    ; Get current mouse position
    MouseGetPos, currentX, currentY

    ; Only update if mouse position has changed significantly (reduces flicker)
    if (Abs(currentX - lastSelectionX) < 3 && Abs(currentY - lastSelectionY) < 3)
        return

    lastSelectionX := currentX
    lastSelectionY := currentY

    ; Calculate box dimensions (handle dragging in any direction)
    boxX := (startX < currentX) ? startX : currentX
    boxY := (startY < currentY) ? startY : currentY
    boxW := Abs(currentX - startX)
    boxH := Abs(currentY - startY)

    ; Skip if box is too small
    if (boxW < 5 || boxH < 5)
        return

    ; Destroy existing selection box if it exists
    if (selectionBoxHwnd)
        Gui, %selectionBoxHwnd%:Destroy

    ; Create new selection box using the bounding_box function
    selectionBoxHwnd := bounding_box("Red", boxX, boxY, boxW, boxH)
return

CleanupSelectionBox:
    ; Destroy the selection box GUI
    if (selectionBoxHwnd)
        Gui, %selectionBoxHwnd%:Destroy
    selectionBoxHwnd := ""
return

; Function to save skillbar coordinates to INI
SaveSkillbarCoordinates() {
    global iniFile, SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2

    FileEncoding, UTF-8
    IniWrite, %SkillBarX1%, %iniFile%, SkillbarArea, X1
    IniWrite, %SkillBarY1%, %iniFile%, SkillbarArea, Y1
    IniWrite, %SkillBarX2%, %iniFile%, SkillbarArea, X2
    IniWrite, %SkillBarY2%, %iniFile%, SkillbarArea, Y2
    FileEncoding
}

; Function to load skillbar coordinates from INI
LoadSkillbarCoordinates() {
    global iniFile, SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2

    FileEncoding, UTF-8
    IniRead, loadedX1, %iniFile%, SkillbarArea, X1, %SkillBarX1%
    IniRead, loadedY1, %iniFile%, SkillbarArea, Y1, %SkillBarY1%
    IniRead, loadedX2, %iniFile%, SkillbarArea, X2, %SkillBarX2%
    IniRead, loadedY2, %iniFile%, SkillbarArea, Y2, %SkillBarY2%
    FileEncoding

    ; Only update if valid coordinates were loaded
    if (loadedX1 != "ERROR" && loadedY1 != "ERROR" && loadedX2 != "ERROR" && loadedY2 != "ERROR") {
        SkillBarX1 := loadedX1
        SkillBarY1 := loadedY1
        SkillBarX2 := loadedX2
        SkillBarY2 := loadedY2
    }
}

; Function to load QWERTZ mode setting from INI
LoadQWERTZSetting() {
    global iniFile, qwertzModeEnabled

    ; Load QWERTZ mode setting (default: false)
    IniRead, loadedQWERTZ, %iniFile%, Settings, QWERTZMode, 0
    if (loadedQWERTZ != "ERROR") {
        qwertzModeEnabled := (loadedQWERTZ = "1" || loadedQWERTZ = "true")
        ; Set the checkbox state in the GUI
        GuiControl,, qwertzmode, %qwertzModeEnabled%
    }
}

; Function to update the skillbar display
UpdateSkillbarDisplay() {
    global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2

    width := SkillBarX2 - SkillBarX1
    height := SkillBarY2 - SkillBarY1
    displayText := "Current Skillbar Area: X1=" . SkillBarX1 . " Y1=" . SkillBarY1 . " X2=" . SkillBarX2 . " Y2=" . SkillBarY2 . " (Size: " . width . "x" . height . ")"
    GuiControl,, HealerSkillbarCoords, %displayText%
    GuiControl,, ToolsSkillbarCoords, %displayText%
}
LoadHealSkillsDelayed:
    RefreshHealSkillsList()
    RefreshHealPriorityList()
    ; Update the heal interval display with loaded value
    GuiControl,, HealIntervalInput, %healCheckInterval%
    ; Update skillbar coordinates display
    UpdateSkillbarDisplay()
return

LoadccSkillsDelayed:
    RefreshccPriorityList()
return
LoadDPSSkillsDelayed:
    RefreshDPSPriorityList()
return
; ========= Quick Menu's =========
skillboxesnpc:
    Run, %A_ScriptDir%\openmasterboxes.ahk
return
buffheal2nd:
    Run, C:\Users\zombi\Desktop\New folder (2) - Copy\buff&heal.ahk
return
enchanter:
    Run, %A_ScriptDir%\gear_enchanter.ahk
return

LaunchScript:
    Gui, Submit, NoHide
    GuiControlGet, selectedScript,, ScriptListBox

    if (selectedScript = "Accessory Awakening") {
        scriptFile := A_ScriptDir "\Accessory awakening.ahk"
    } else if (selectedScript = "Citadel Store") {
        scriptFile := A_ScriptDir "\citadelstore.ahk"
    } else if (selectedScript = "Gear Enchanter") {
        scriptFile := A_ScriptDir "\gear_enchanter.ahk"
    } else if (selectedScript = "Rupee Monitor") {
        scriptFile := A_ScriptDir "\rupeesperhour.ahk"
    } else if (selectedScript = "Exp Monitor") {
        scriptFile := A_ScriptDir "\expperhour.ahk"
    } else if (selectedScript = "AltAssist v2") {
        scriptFile := A_ScriptDir "\AltAssistV2.exe"
    } else {
        MsgBox, 48, No Selection, Please select a script from the list first!
        return
    }

    if FileExist(scriptFile) {
        Run, %scriptFile%
    } else {
        MsgBox, 16, Error, Script file not found:`n%scriptFile%
    }
return

; ========= HEALER FUNCTIONS =========

; Calculate health check X position based on percentage threshold
; Health bar appears to start around portrait.x + 12
; Health bar width is approximately 108 pixels
CalculateHealthCheckX(baseHealthX, thresholdPercent) {
    healthBarWidth := 108
    ; The health bar starts at baseHealthX (portrait.x + 12)
    ; At 1%, we want to check near the start of the bar (baseHealthX + ~1)
    ; At 100%, we want to check near the end of the bar (baseHealthX + 108)
    ; Calculate offset: ((percent - 1) / 99) * width to map 1-100% to 0-108 pixels
    offset := ((thresholdPercent - 1) / 99.0) * healthBarWidth
return baseHealthX + offset
}

TestPartyDetection:
    DetectPartyMembers()
return

DetectPartyMembers() {
    ; Find the party window bar
    if (!(partyBar := FindText(0, 0, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindow))) {
        UpdateHealerStatus("Party window not found")
        return
    }

    ; Create search area: 15px left, 175px right, 430px down
    searchX1 := partyBar.1.x - 15
    searchY1 := partyBar.1.y
    searchX2 := partyBar.1.x + 175
    searchY2 := partyBar.1.y + 430

    playerPatterns := magus . "|" . Corruptor . "|" . voidmage . "|" . deadeye . "|" . beastmaster . "|" . slayer . "|" . berserker . "|" . overlord . "|" . masterbreeder . "|" . Marksman . "|" Templar
    petPatterns := windpixie . "|" . gnoll . "|" . etherealpixie

    playerCount := 0
    petCount := 0

    ; Find player portraits and show health check dots
    if (ok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, playerPatterns)) {
        playerCount := ok.Length()
        for i, portrait in ok {
            centerY := portrait.y - 1
            healthX := portrait.x + 12
            ; Create red dot at health check position (must match DynamicHealthCheck exactly)
            dotX := CalculateHealthCheckX(healthX, healThresholdPercent)
            dotY := centerY - 3
            ; Debug: Show calculation
            offset := dotX - healthX
            UpdateHealerStatus("Player " . i . ": healthX=" . healthX . " + offset=" . Round(offset, 1) . " = dotX=" . Round(dotX, 1) . " (Threshold: " . healThresholdPercent . "%)")
            Gui, HealthDot%i%:New, +AlwaysOnTop -Caption +ToolWindow, HealthCheck
            Gui, HealthDot%i%:Color, Red
            Gui, HealthDot%i%:Show, x%dotX% y%dotY% w3 h9 NoActivate
            SetTimer, RemoveHealthDot%i%, -3000
        }
    }

    ; Find pet portraits and show health check dots
    if (ok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, petPatterns)) {
        petCount := ok.Length()
        for i, portrait in ok {
            centerY := portrait.y - 1
            healthX := portrait.x + 54
            ; Create blue dot at health check position (must match DynamicHealthCheck exactly)
            dotIndex := i + 10 ; Offset to avoid conflicts with player dots
            petDotX := healthX - 18
            petDotY := centerY - 3
            Gui, HealthDot%dotIndex%:New, +AlwaysOnTop -Caption +ToolWindow, PetHealthCheck
            Gui, HealthDot%dotIndex%:Color, Blue
            Gui, HealthDot%dotIndex%:Show, x%petDotX% y%petDotY% w3 h9 NoActivate
            SetTimer, RemoveHealthDot%dotIndex%, -3000
        }
    }

    UpdateHealerStatus("Detected: " . playerCount . " players, " . petCount . " pets - Heal threshold: " . healThresholdPercent . "% - Dots shown for 3 seconds")
}
autofollow:
    if (autofolloww)
    {
        autofolloww := false
        GuiControl,, StatusText, Status: Autofollow Disabled
    }
    else
    {
        autofolloww := true
        GuiControl,, StatusText, Status: Autofollow Enabled
    }
return

amimovingg:
    if (movingg)
    {
        movingg := false
        GuiControl,, StatusText, Status: Movement Detection Disabled
    }
    else
    {
        movingg := true
        GuiControl,, StatusText, Status: Movement Detection Enabled
    }
return
ValidateHealThreshold:
    Gui, Submit, NoHide
    if (HealThresholdInput < 1)
    {
        HealThresholdInput := 1
        GuiControl,, HealThresholdInput, 1
    }
    else if (HealThresholdInput > 100)
    {
        HealThresholdInput := 100
        GuiControl,, HealThresholdInput, 100
    }
return

SaveHealThreshold:
    Gui, Submit, NoHide
    Gosub, ValidateHealThreshold
    healThresholdPercent := HealThresholdInput
    SaveHealSettings()
    UpdateHealerStatus("Heal threshold set to " . healThresholdPercent . "% and saved to INI")
return

ValidateHealInterval:
    Gui, Submit, NoHide
    if (HealIntervalInput < 100)
    {
        HealIntervalInput := 100
        GuiControl,, HealIntervalInput, 100
    }
    else if (HealIntervalInput > 10000)
    {
        HealIntervalInput := 10000
        GuiControl,, HealIntervalInput, 10000
    }
return

SaveHealInterval:
    Gui, Submit, NoHide
    Gosub, ValidateHealInterval
    healCheckInterval := HealIntervalInput
    SaveHealSettings()
    UpdateHealerStatus("Heal check interval set to " . healCheckInterval . "ms and saved to INI")

    ; Update the timer if healing is active
    SetTimer, CheckHealth, Off
    SetTimer, DynamicHealthCheck, Off
    SetTimer, ManualHealthCheck, Off
    if (PlayerCoords.Length() > 0 || PetCoords.Length() > 0) {
        SetTimer, CheckHealth, %healCheckInterval%
        UpdateHealerStatus("Heal timer updated - now checking every " . healCheckInterval . "ms")
    }
    ; Also update DynamicHealthCheck timer if it's running
    SetTimer, DynamicHealthCheck, %healCheckInterval%
    ; Update manual healing timer if active
    if (isManualHealingActive) {
        SetTimer, ManualHealthCheck, %healCheckInterval%
    }
return
CheckForDeath() {
    global usegodmotherbottle, win1

    if (!win1 || win1 = "") {
        return false
    }

    ; Get window position
    WinGetPos, winX, winY,,, ahk_id %win1%

    if (winX = "" || winY = "") {
        return false
    }

    ; Search for death patterns across the entire window
    WinGetPos, winX, winY, winWidth, winHeight, ahk_id %win1%

    ; Search for the god mother bottle patterns (indicating death screen)
    deathPattern := FindText(0, 0, winX, winY, winX + winWidth, winY + winHeight, 0, 0, usegodmotherbottle)

    if (deathPattern) {
        return true
    }

return false
}
; Checkbox toggle for hvout (HV if max res count met)
HVout:
    Gui, Submit, NoHide
    if (hvout) {
        hvout := true
        tooltip, HVout enabled: Will use HV if max resurrection count is met.
            Sleep, 3000
        tooltip
    } else {
        hvout := false
        tooltip, HVout disabled: Will NOT use HV if max resurrection count is met.
            Sleep, 3000
        tooltip
    }
    ; Optionally save to INI if you want persistence:
    IniWrite, %hvout%, %iniFile%, Settings, HVout
return
; Handle resurrection process
HandleResurrection() {
    global usegodmotherbottle, win1, CurrentResurrections, MaxResurrections
    global ResurrectionEnabled, HVpass

    if (!ResurrectionEnabled) {
        return false
    }
    if (CurrentResurrections >= MaxResurrections && hvout) {
        UpdateResurrectionStatus("Max resurrections reached!")
        tooltip, Auto-Resurrection, Maximum number of resurrections (%MaxResurrections%) reached!, 3
        ; Get window position
        WinGetPos, winX, winY,,, ahk_id %win1%

        if (winX = "" || winY = "") {
            return false
        }

        ; Search for and click the resurrection bottle
        WinGetPos, winX, winY, winWidth, winHeight, ahk_id %win1%
        deathPattern := FindText(0, 0, winX, winY, winX + winWidth, winY + winHeight, 0, 0, usegodmotherbottle)

        if (deathPattern && IsObject(deathPattern) && deathPattern.MaxIndex() >= 1) {
            ; Get click coordinates (center of found pattern)
            clickX := deathPattern.1.x
            clickY := deathPattern.1.y

            ; Validate coordinates
            if (clickX > 0 && clickY > 0 && clickX < A_ScreenWidth && clickY < A_ScreenHeight) {
                ; Convert screen coordinates to window-relative and click center
                WinGetPos, winX, winY,,, ahk_id %win1%
                relX := clickX - winX
                relY := clickY - winY
                ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1
                Sleep, 500

                ; Increment counter
                CurrentResurrections++
                UpdateResurrectionStatus("Resurrected! " . CurrentResurrections . "/" . MaxResurrections)

                ; Log the resurrection
                ToolTip, Character Resurrected (%CurrentResurrections%/%MaxResurrections%), 10, 10, 4
                SetTimer, ClearResurrectionTooltip, -3000
                ; Loop to find and click HVpass every 100ms for up to 2 minutes (120,000ms)
                startTime := A_TickCount
                while ((A_TickCount - startTime) < 120000) {
                    WinGetPos, winX, winY, winWidth, winHeight, ahk_id %win1%
                    if (FindText(foundX, foundY, winX, winY, winX + winWidth, winY + winHeight, 0, 0, HVpass)) {
                        relX := foundX - winX
                        relY := foundY - winY
                        ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1
                        Sleep, 100
                    } else {
                        break
                    }
                }
                return true
            }
        }
        return false
    }
    if (CurrentResurrections >= MaxResurrections) {
        UpdateResurrectionStatus("Max resurrections reached!")
        MsgBox, 0, Auto-Resurrection, Maximum number of resurrections (%MaxResurrections%) reached!, 3
        return false
    }

    ; Get window position
    WinGetPos, winX, winY,,, ahk_id %win1%

    if (winX = "" || winY = "") {
        return false
    }

    ; Search for and click the resurrection bottle
    WinGetPos, winX, winY, winWidth, winHeight, ahk_id %win1%
    deathPattern := FindText(0, 0, winX, winY, winX + winWidth, winY + winHeight, 0, 0, usegodmotherbottle)

    if (deathPattern && IsObject(deathPattern) && deathPattern.MaxIndex() >= 1) {
        ; Get click coordinates (center of found pattern)
        clickX := deathPattern.1.x
        clickY := deathPattern.1.y

        ; Validate coordinates
        if (clickX > 0 && clickY > 0 && clickX < A_ScreenWidth && clickY < A_ScreenHeight) {
            ; Convert screen coordinates to window-relative and click center
            WinGetPos, winX, winY,,, ahk_id %win1%
            relX := clickX - winX
            relY := clickY - winY
            ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1
            Sleep, 500

            ; Increment counter
            CurrentResurrections++
            UpdateResurrectionStatus("Resurrected! " . CurrentResurrections . "/" . MaxResurrections)

            ; Log the resurrection
            ToolTip, Character Resurrected (%CurrentResurrections%/%MaxResurrections%), 10, 10, 4
            SetTimer, ClearResurrectionTooltip, -3000

            return true
        }
    }

return false
}

; Clear resurrection tooltip
ClearResurrectionTooltip:
    ToolTip, , , , 4
return
ChangeKeyDelay:
    SetRandomKeyDelay()
return
; Main death detection timer function
DeathDetectionTimer:
    global DeathCheckActive, ResurrectionEnabled

    if (!DeathCheckActive || !ResurrectionEnabled) {
        return
    }

    if (CheckForDeath()) {
        ; Character died - attempt resurrection
        if (HandleResurrection()) {
            ; Successfully resurrected
            Sleep, 2000 ; Wait a bit before next check
        } else {
            ; Failed to resurrect or max reached
            DeathCheckActive := false
            SetTimer, DeathDetectionTimer, Off
        }
    }
return

; Start death detection
StartDeathDetection() {
    global DeathCheckActive, ResurrectionEnabled

    if (!ResurrectionEnabled) {
        MsgBox, 0, Death Detection, Please enable auto-resurrection first!, 2
        return
    }

    DeathCheckActive := true
    SetTimer, DeathDetectionTimer, 3000 ; Check every 3 seconds
    ;MsgBox, 0, Death Detection, Death detection started!, 1
}

; Stop death detection
StopDeathDetection() {
    global DeathCheckActive

    DeathCheckActive := false
    SetTimer, DeathDetectionTimer, Off
    ;MsgBox, 0, Death Detection, Death detection stopped!, 1
}

; Update resurrection status display
UpdateResurrectionStatus(message) {
    GuiControl,, ResurrectionStatus, %message%
}

; =============================================================================
; GUI EVENT HANDLERS
; =============================================================================

; Handle resurrection checkbox
ResurrectionEnabled:
    GuiControlGet, ResurrectionEnabled

    if (ResurrectionEnabled) {
        ; Load current settings
        GuiControlGet, MaxResurrectionsEdit
        if (MaxResurrectionsEdit > 0) {
            MaxResurrections := MaxResurrectionsEdit
        } else {
            MaxResurrections := 8
            GuiControl,, MaxResurrectionsEdit, 8
        }
        UpdateResurrectionStatus("Enabled - " . CurrentResurrections . "/" . MaxResurrections)
        StartDeathDetection()
    } else {
        UpdateResurrectionStatus("Disabled")
        StopDeathDetection()
    }
return

; Save resurrection settings
SaveResurrectionSettings:
    GuiControlGet, MaxResurrectionsEdit

    if (MaxResurrectionsEdit > 0 && MaxResurrectionsEdit <= 99) {
        MaxResurrections := MaxResurrectionsEdit
        ; Save to INI file
        IniWrite, %MaxResurrections%, %iniFile%, Settings, MaxResurrections
        UpdateResurrectionStatus("Settings saved - " . CurrentResurrections . "/" . MaxResurrections)
        MsgBox, 0, Settings, Max resurrections set to %MaxResurrections% and saved!, 2
    } else {
        MsgBox, 0, Error, Please enter a valid number (1-99)!, 2
        GuiControl,, MaxResurrectionsEdit, %MaxResurrections%
    }
return

; Reset resurrection counter
ResetResurrections:
    CurrentResurrections := 0
    UpdateResurrectionStatus("Count reset - " . CurrentResurrections . "/" . MaxResurrections)
    MsgBox, 0, Reset, Resurrection count reset to 0!, 1
return

; Manual test death detection
TestDeathDetection:
    if (CheckForDeath()) {
        MsgBox, 0, Test, Death screen detected!
        if (HandleResurrection()) {
            MsgBox, 0, Test, Resurrection attempted!
        }
    } else {
        MsgBox, 0, Test, No death screen found.
    }
return

SelectWindow:
    MsgBox, Now right click on the game window 
    KeyWait, RButton, D
    MouseGetPos,,, selectedWindow
    WinGetTitle, title, ahk_id %selectedWindow%
    WinGet, pid, PID, ahk_id %selectedWindow%
    MsgBox, You have selected: %title% (PID: %pid%)
    WinMove, ahk_id %selectedWindow%, , 0, 0
    ; Set up for healing system
    FindText().BindWindow(selectedWindow)
    global TargetGameWindow := selectedWindow
    global TargetGameTitle := title
    global TargetGamePID := pid
    global windowWasClosed := false
    global win1 := selectedWindow
    ; Set up for navigation system
    global NavTargetGameWindow := selectedWindow
    global NavTargetGamePID := pid

    ; Handle camera file selection for both systems
    ; Check if there's a saved navigation camera file
    IniRead, savedNavCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
    IniRead, savedMainCameraFile, pathingsettings.ini, Settings, CameraFile, ERROR

    selectedCameraFile := ""

    ; Auto-use navigation camera file, then main camera file (no prompts)
    if (savedNavCameraFile != "ERROR" && FileExist(savedNavCameraFile)) {
        selectedCameraFile := savedNavCameraFile
    }
    else if (savedMainCameraFile != "ERROR" && FileExist(savedMainCameraFile)) {
        selectedCameraFile := savedMainCameraFile
    }

    ; If no saved file or user declined, ask for new file
    if (selectedCameraFile = "") {
        FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
    }

    ; Apply camera file to both systems if selected
    if (selectedCameraFile != "") {
        ; Set up navigation camera
        NavCameraFile := selectedCameraFile
        LoadNavCameraSettings(NavCameraFile)
        GuiControl,, NavCameraFile, Camera: %NavCameraFile%
        GuiControl,, NavRadiusEdit, %NavCameraRadius%

        ; Set up main camera
        CameraFile := selectedCameraFile
        LoadCameraSettings(CameraFile)

        MsgBox, Camera file loaded for both systems: %selectedCameraFile%
        SaveNavSettings()
        SaveSettings()
    }
    ; Move the selected window to 0,0 (top-left corner of the screen)

    UpdateHealerStatus("Selected window: " . title)
    SaveGameWindowSettings()
    UpdateWindowStatusDisplay()
return

return
SelectWindow2:
    MsgBox, Now right click on the window 
    KeyWait, RButton, D
    MouseGetPos,,, win2
    WinGetTitle, title, ahk_id %win2%
    WinGet, pid, PID, ahk_id %win2%
    MsgBox, You have selected: %title%
    WinMove, ahk_id %win2%, , 0, 0

    ; Check if there's a saved camera file and ask user
    IniRead, savedCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
    selectedCameraFile := ""

    if (savedCameraFile != "ERROR" && FileExist(savedCameraFile)) {
        MsgBox, 4,, Use previous camera file?`n%savedCameraFile%
        IfMsgBox Yes
        {
            selectedCameraFile := savedCameraFile
        }
        else
        {
            FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
        }
    }
    else
    {
        FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
    }

    if (selectedCameraFile != "") {
        NavCameraFile := selectedCameraFile
        LoadNavCameraSettings(NavCameraFile)
        GuiControl,, NavCameraFile, Camera: %NavCameraFile%
        GuiControl,, NavRadiusEdit, %NavCameraRadius%
        MsgBox, Camera file loaded: %NavCameraFile%
        SaveNavSettings()
    }
    ; Store the window ID globally for healing activation
    global TargetGameWindow := win2
    global TargetGameTitle := title
    global windowWasClosed := false ; Reset the flag when new window is selected
    global navwin1 := win1
    UpdateHealerStatus("Selected window: " . title)
return

SelectDPSWindow:
    MsgBox, Now right click on the game window for DPS.
        KeyWait, RButton, D
    MouseGetPos,,, win1
    WinGetTitle, title, ahk_id %win1%
    WinGet, pid, PID, ahk_id %win1%
    MsgBox, You have selected: %title%
    WinMove, ahk_id %win1%, , 0, 0

    ; Store the window ID globally for DPS activation
    global TargetGameWindow := win1
    global TargetGameTitle := title
    UpdateDPSStatus("Selected window: " . title)
return

InfiniteMouseMove:
    MouseGetPos, currentX, currentY
    distance := Sqrt((currentX-centerX)**2 + (currentY-centerY)**2)
    if (distance > 10) {
        Click Up Right
        MouseMove, centerX, centerY, 0
        Click Down Right
    }
return

StartDynamicHealing:
    ; Use win1 if TargetGameWindow is not set
    if (TargetGameWindow = "" && win1 != "") {
        TargetGameWindow := win1
    }

    if (TargetGameWindow = "" && win1 = "") {
        UpdateHealerStatus("Please select a target window first.")
        return
    }

    SetTimer, DynamicHealthCheck, %healCheckInterval%
    UpdateHealerStatus("Dynamic healing started - auto-detecting party members")
return

DynamicHealthCheck:
    ; Find the party window bar
    if (!(partyBar := FindText(0, 0, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindow))) {
        return
    }

    ; Create search area: 15px left, 175px right, 430px down
    searchX1 := partyBar.1.x - 15
    searchY1 := partyBar.1.y
    searchX2 := partyBar.1.x + 175
    searchY2 := partyBar.1.y + 430

    playerPatterns := magus . "|" . Corruptor . "|" . voidmage . "|" . deadeye . "|" . beastmaster . "|" . slayer . "|" . berserker . "|" . overlord . "|" . masterbreeder . "|" . Marksman . "|" Templar
    petPatterns := windpixie . "|" . gnoll . "|" . etherealpixie

    ; Check players in party area
    if (ok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, playerinparty)) {
        for i, portrait in ok {
            centerY := portrait.y - 1
            healthX := portrait.x + 12

            ; Look for full health bar (green)
            healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
            checkX := CalculateHealthCheckX(healthX, healThresholdPercent)
            checkY := centerY - 3
            ; Search in a small area (3x9 pixels) matching the red dot size exactly
            healthFullFound := FindText(0, 0, checkX, checkY, checkX + 3, checkY + 9, 0, 0, healthFull)
            if (!healthFullFound) {
                ; FIXED: Add coordinate validation before clicking
                clickX := portrait.x + 9
                clickY := centerY

                ; Validate coordinates before clicking
                if (clickX > 0 && clickY > 0 && clickX < A_ScreenWidth && clickY < A_ScreenHeight) {
                    ;ToolTip, Dynamic Player Click at %clickX%`, %clickY%, , , 3
                    ControlClick, x%clickX% y%clickY%, ahk_id %win1%
                    TryCastHealingSkill()
                    Sleep, 25
                } else {
                    ;UpdateHealerStatus("⚠ Invalid dynamic player click coordinates: " . clickX . "," . clickY)
                }
            }
        }
    }

    ; Check pets in party area
    if (ok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, petsinparty)) {
        for i, portrait in ok {
            centerY := portrait.y - 1
            healthX := portrait.x + 54

            ; Look for full health bar (green)
            healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
            checkX := healthX - 18
            checkY := centerY - 3
            ; Search in a small area (3x9 pixels) matching the blue dot size exactly
            healthFullFound := FindText(0, 0, checkX, checkY, checkX + 3, checkY + 9, 0, 0, healthFull)
            if (!healthFullFound) {
                ; FIXED: Add coordinate validation before clicking
                clickX := portrait.x + 9
                clickY := centerY

                ; Validate coordinates before clicking
                if (clickX > 0 && clickY > 0 && clickX < A_ScreenWidth && clickY < A_ScreenHeight) {
                    ;;;;;ToolTip, Dynamic Pet Click at %clickX%`, %clickY%, , , 4
                    ControlClick, x%clickX% y%clickY%, ahk_id %win1%,, Left, 1
                    TryCastHealingSkill()
                    Sleep, 25
                } else {
                    ;UpdateHealerStatus("⚠ Invalid dynamic pet click coordinates: " . clickX . "," . clickY)
                }
            }
        }
    }
return

CancelHealerScript:
    SetTimer, CheckHealth, Off
    SetTimer, UpdateBoundingBoxes, Off
    SetTimer, DynamicHealthCheck, Off
    SetTimer, ManualHealthCheck, Off
    ClearBoundingBoxes()
    isManualHealingActive := false
    UpdateHealerStatus("All healer scripts stopped.")
return

clearskills:
    InputBox, patternToClear, Clear Heal Pattern, Enter the name of the heal pattern to clear (leave empty to clear all):, , 300, 130
    if (ErrorLevel)
        return

    if (patternToClear = "") {
        ; Clear only heal patterns
        healPatternsToDelete := []
        for patternName, patternText in patterns {
            if (SubStr(patternName, 1, 4) = "heal") {
                healPatternsToDelete.Push(patternName)
            }
        }

        for index, patternName in healPatternsToDelete {
            patterns.Delete(patternName)
            patternKeys.Delete(patternName)
            patternNames.Delete(patternName)
            IniDelete, %iniFile%, Patterns, %patternName%
            IniDelete, %iniFile%, PatternKeys, %patternName%
            IniDelete, %iniFile%, PatternNames, %patternName%
        }

        healPriorities := []
        IniDelete, %iniFile%, HealPriorities
        patternCounter := 1
        RefreshHealPriorityList()
        UpdateHealerStatus("All heal patterns have been cleared.")
    } else {
        ; Check both pattern name and custom name
        patternToDelete := ""
        for healPat, healText in patterns {
            if (SubStr(healPat, 1, 4) = "heal") {
                displayName := GetDisplayName(healPat)
                if (healPat = patternToClear || displayName = patternToClear) {
                    patternToDelete := healPat
                    break
                }
            }
        }

        if (patternToDelete != "") {
            patterns.Delete(patternToDelete)
            patternKeys.Delete(patternToDelete)
            patternNames.Delete(patternToDelete)

            ; Remove from priority list
            for index, priorityPattern in healPriorities {
                if (priorityPattern = patternToDelete) {
                    healPriorities.RemoveAt(index)
                    break
                }
            }

            IniDelete, %iniFile%, Patterns, %patternToDelete%
            IniDelete, %iniFile%, PatternKeys, %patternToDelete%
            IniDelete, %iniFile%, PatternNames, %patternToDelete%
            SaveHealPriorities()
            RefreshHealPriorityList()
            UpdateHealerStatus("Heal pattern '" . patternToClear . "' has been cleared.")
        } else {
            UpdateHealerStatus("Heal pattern '" . patternToClear . "' not found.")
        }
    }
return

findhealingskill:
    if (patterns.Count() = 0) {
        UpdateHealerStatus("No healing skills captured. Add some skills first.")
        return
    }

    UpdateHealerStatus("Testing healing skills - searching for patterns on screen...")

    foundCount := 0
    totalCount := 0

    ; Test each heal pattern
    for patternName, patternText in patterns {
        if (SubStr(patternName, 1, 4) = "heal") {
            totalCount++
            displayName := GetDisplayName(patternName)

            ; Search in the skill bar area - convert window-relative to screen coordinates
            WinGetPos, winX, winY,,, ahk_id %win1%
            screenX1 := winX + SkillBarX1
            screenY1 := winY + SkillBarY1
            screenX2 := winX + SkillBarX2
            screenY2 := winY + SkillBarY2
            if (ok := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)) {
                foundCount++
                UpdateHealerStatus("✓ FOUND: " . displayName . " at coordinates: " . X . ", " . Y)

                ; Highlight the found skill
                Try {
                    For i, v in ok {
                        if (i <= 2)
                            FindText().MouseTip(ok[i].x, ok[i].y)
                    }
                }
            } else {
                UpdateHealerStatus("✗ Not found: " . displayName)
            }
        }
    }

    UpdateHealerStatus("Test complete - Found " . foundCount . " out of " . totalCount . " healing skills on screen.")
return

AddHealingSkill:
    UpdateHealerStatus("Hover your mouse over the healing skill and press 1 to capture it")
    KeyWait, 1, D
    capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)
    Clipboard := capturedText
    patternName := "heal" . patternCounter

    ; Prompt for custom name and key assignment
    InputBox, customName, Name Healing Skill, Enter a name for this healing skill:, , 300, 130, , , , , %patternName%
        if (ErrorLevel)
        return

    if (customName = "")
        customName := patternName

    ; Ask if need to press key before cast
    MsgBox, 4, Press Key Before Cast?, Do you need to press a DIFFERENT key BEFORE the main skill key?`n`n(Example: Press Tab to swap weapon bar, then press the skill key)
    IfMsgBox, Yes
    {
        needsPreCastKey := true
        InputBox, preCastKey, Pre-Cast Key, Enter the key to press BEFORE the main skill key (e.g. Tab):, , 350, 150
        if (ErrorLevel)
            preCastKey := ""
    }
    IfMsgBox, No
    {
        needsPreCastKey := false
        preCastKey := ""
    }

    InputBox, assignedKey, Assign Key, Enter a key for this skill (leave empty to click with mouse):, , 300, 130
        if (ErrorLevel)
        return

    ; Ask if ground-targeted skill
    MsgBox, 4, Ground Target Skill?, Is this a ground-targeted skill that requires clicking a location AFTER the key is pressed?
    IfMsgBox, Yes
    {
        isGroundTarget := true
        MsgBox, 0, Right-Click to Set Location, Right-click on the location where the skill should be cast.`n`nPress OK first, then right-click the location.
        UpdateHealerStatus("Waiting for right-click to set ground target location...")
        KeyWait, RButton, D
        MouseGetPos, groundX, groundY
        ; Convert screen coords to window-relative coords for saving
        WinGetPos, winX, winY,,, ahk_id %win1%
        groundX := groundX - winX
        groundY := groundY - winY
        UpdateHealerStatus("Ground target location set (relative): " . groundX . ", " . groundY)
    }
    IfMsgBox, No
    {
        isGroundTarget := false
        groundX := ""
        groundY := ""
    }

    ; Save pattern with key, custom name, ground target info, and pre-cast key info
    SavePattern(patternName, capturedText, assignedKey, isGroundTarget, groundX, groundY, needsPreCastKey, preCastKey)
    SavePatternName(patternName, customName)

    UpdateHealerStatus("Healing skill captured and saved as '" . customName . "' [" . patternName . "]")
    patternCounter++

    ; Add to priority list at the end
    healPriorities.Push(patternName)
    SaveHealPriorities()
    RefreshHealSkillsList()
    RefreshHealPriorityList()
Return

CaptureCoordinates() {
    global PlayerCount, PetCount, PlayerCoords, PetCoords, partywindowlogo

    ; Find party window logo first
    if (!FindText(logoX, logoY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindowlogo)) {
        MsgBox, 16, Error, Party window logo not found! Make sure the party window is visible.
        return
    }

    PlayerCoords := []
    PetCoords := []
    ClearBoundingBoxes()

    MsgBox, 0, Coordinate Capture, Please click on the center of each player character (total: %PlayerCount%).`n`nPress F12 to cancel.

    Loop, %PlayerCount% {
        currentPlayer := A_Index
        ToolTip, Click on the center of Player %currentPlayer%, 100, 100

        KeyWait, LButton, D
        MouseGetPos, PlayerCenterX, PlayerCenterY

        ; Calculate relative position to party window logo
        relativeX := PlayerCenterX - logoX
        relativeY := PlayerCenterY - logoY

        PlayerCoords.Push({RelativeX: relativeX, RelativeY: relativeY})

        ; Draw rectangle at current position for visual feedback
        PlayerX1 := PlayerCenterX - 2
        PlayerX2 := PlayerCenterX + 3
        PlayerY1 := PlayerCenterY - 12
        PlayerY2 := PlayerCenterY + 13
        DrawHollowRectangle(PlayerX1, PlayerY1, PlayerX2, PlayerY2, "Player" . currentPlayer, "00FF00", "FFFF00")

        KeyWait, LButton
        Sleep, 500
    }

    ToolTip

    if (PetCount > 0) {
        MsgBox, 0, Coordinate Capture, Now please click on the center of each pet (total: %PetCount%).`n`nPress F12 to cancel.

        Loop, %PetCount% {
            currentPet := A_Index
            ToolTip, Click on the center of Pet %currentPet%, 100, 100

            KeyWait, LButton, D
            MouseGetPos, PetCenterX, PetCenterY

            ; Calculate relative position to party window logo
            relativeX := PetCenterX - logoX
            relativeY := PetCenterY - logoY

            PetCoords.Push({RelativeX: relativeX, RelativeY: relativeY})

            ; Draw rectangle at current position for visual feedback
            PetX1 := PetCenterX - 2
            PetX2 := PetCenterX + 3
            PetY1 := PetCenterY - 12
            PetY2 := PetCenterY + 13
            DrawHollowRectangle(PetX1, PetY1, PetX2, PetY2, "Pet" . currentPet, "0000FF", "FF00FF")

            KeyWait, LButton
            Sleep, 500
        }
    }

    ToolTip

    summaryText := "Captured coordinates for " . PlayerCount . " players and " . PetCount . " pets relative to party window.`n`n"
    summaryText .= "Player coordinates (relative to logo):`n"
    For index, coords in PlayerCoords {
        summaryText .= "Player " . index . ": Offset(" . coords.RelativeX . "," . coords.RelativeY . ")`n"
    }

    if (PetCount > 0) {
        summaryText .= "`nPet coordinates (relative to logo):`n"
        For index, coords in PetCoords {
            summaryText .= "Pet " . index . ": Offset(" . coords.RelativeX . "," . coords.RelativeY . ")`n"
        }
    }

    summaryText .= "`nPress F12 to clear all bounding boxes.`nDo you want to start monitoring these areas?"

    MsgBox, 4, Coordinates Captured, %summaryText%
    IfMsgBox Yes
    {
        StartMonitoring()
    }
}

StartMonitoring() {
    global PlayerCoords, PetCoords, HealthPattern, healCheckInterval
    SetTimer, CheckHealth, %healCheckInterval%
    SetTimer, UpdateBoundingBoxes, 2000
    UpdateHealerStatus("Health monitoring started - checking every " . healCheckInterval . "ms")
return
}

UpdateBoundingBoxes:
    global PlayerCoords, PetCoords, partywindowlogo, BoundingBoxes, lastLogoX, lastLogoY

    if (!FindText(logoX, logoY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindowlogo))
        return

    ; Only update if logo position changed
    if (logoX = lastLogoX && logoY = lastLogoY)
        return

    lastLogoX := logoX
    lastLogoY := logoY

    ClearBoundingBoxes()

    For index, coords in PlayerCoords {
        currentX := logoX + coords.RelativeX
        currentY := logoY + coords.RelativeY
        PlayerX1 := currentX - 2
        PlayerX2 := currentX + 3
        PlayerY1 := currentY - 4
        PlayerY2 := currentY + 5
        DrawHollowRectangle(PlayerX1, PlayerY1, PlayerX2, PlayerY2, "Player" . index, "00FF00", "FFFF00")
    }

    For index, coords in PetCoords {
        currentX := logoX + coords.RelativeX
        currentY := logoY + coords.RelativeY
        PetX1 := currentX - 2
        PetX2 := currentX + 3
        PetY1 := currentY - 4
        PetY2 := currentY + 5
        DrawHollowRectangle(PetX1, PetY1, PetX2, PetY2, "Pet" . index, "0000FF", "FF00FF")
    }
return

CheckHealth:
CheckHealthMain:
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return
    }
    global partywindowlogo

    ; Find current party window logo position
    if (!FindText(logoX, logoY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindowlogo)) {
        UpdateHealerStatus("Party window not found - healing paused")
        return
    }

    For index, coords in PlayerCoords {
        ; Calculate current position based on logo position
        currentX := logoX + coords.RelativeX
        currentY := logoY + coords.RelativeY

        ; Create health check area around current position
        PlayerX1 := currentX - 2
        PlayerX2 := currentX + 3
        PlayerY1 := currentY - 4
        PlayerY2 := currentY + 5

        healthpresent := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
        ok := FindText(0, 0, PlayerX1, PlayerY1, PlayerX2, PlayerY2, 0, 0, healthpresent)

        if (!ok) {
            if (PlayerCount > 1 || PetCount > 0) {
                Loop 5 {
                    SendMessageClick(currentX, currentY)
                    Sleep, 20
                } 
            }
            healResult := TryCastHealingSkill()
            if (healResult) {
                UpdateHealerStatus("→ Healed Player " . index)
            } else {
                UpdateHealerStatus("Targeted Player " . index . " but no healing skill available")
            }
            Sleep, 25
        }
    }

    For index, coords in PetCoords {
        ; Calculate current position based on logo position
        currentX := logoX + coords.RelativeX
        currentY := logoY + coords.RelativeY

        ; Create health check area around current position
        PetX1 := currentX - 2
        PetX2 := currentX + 3
        PetY1 := currentY - 4
        PetY2 := currentY + 5

        healthpresent := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
        ok := FindText(0, 0, PetX1, PetY1, PetX2, PetY2, 0, 0, healthpresent)

        if (!ok) {
            Loop 5 {
                SendMessageClick(currentX, currentY)
                Sleep, 20
            }
            Sleep, 25
            healResult := TryCastHealingSkill()
            if (healResult) {
                UpdateHealerStatus("→ Healed Pet " . index)
            } else {
                UpdateHealerStatus("Targeted Pet " . index . " but no healing skill available")
            }
            Sleep, 25
        }
    }
return

TryCastHealingSkill() {
    global patterns, patternKeys, healPriorities, partywindowlogo
    global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2
    global TargetGameWindow, TargetGameTitle
    global healGroundTargetSkills, healGroundTargetCoords
    global healPressKeyBeforeCast, healPreCastKeys

    ; Find current party window logo position for skill bar search
    if (!FindText(logoX, logoY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindowlogo)) {
        ;UpdateHealerStatus("Party window not found - cannot cast healing skills")
        return false
    }

    ; Go through heal priority order
    for index, priorityPattern in healPriorities {
        if (!patterns.HasKey(priorityPattern) || SubStr(priorityPattern, 1, 4) != "heal")
            continue

        patternText := patterns[priorityPattern]

        ; Convert window-relative coords to screen coords
        WinGetPos, winX, winY,,, ahk_id %win1%

        ; Validate window position first
        if (winX = "" || winY = "" || winX < 0 || winY < 0) {
            ;UpdateHealerStatus("⚠ Invalid window position detected - skipping heal cycle")
            return false
        }

        screenX1 := winX + SkillBarX1
        screenY1 := winY + SkillBarY1
        screenX2 := winX + SkillBarX2
        screenY2 := winY + SkillBarY2

        ; For 4K monitors, search the entire screen width but constrain to skill bar height
        ; This ensures skills on left side are found even if coordinates are slightly off
        healingSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

        if (healingSkill) {
            displayName := GetDisplayName(priorityPattern)

            ; Show both ID and custom name if different
            healInfo := (displayName != priorityPattern) ? priorityPattern . " = " . displayName : priorityPattern

            ; Spam protection
            spamCount := 0
            maxSpam := 3
            success := false
            skillCastSuccessfully := false

            Loop {
                spamCount++

                ; Press pre-cast key if needed (only on first spam attempt)
                if (spamCount = 1 && healPressKeyBeforeCast.HasKey(priorityPattern) && (healPressKeyBeforeCast[priorityPattern] = true || healPressKeyBeforeCast[priorityPattern] = "1" || healPressKeyBeforeCast[priorityPattern] = "true") && healPreCastKeys.HasKey(priorityPattern) && healPreCastKeys[priorityPattern] != "") {
                    preCastKey := healPreCastKeys[priorityPattern]
                    ControlSend,, {%preCastKey% down}, ahk_id %win1%
                    Sleep, 25
                    ControlSend,, {%preCastKey% up}, ahk_id %win1%
                    Sleep, 150
                }

                if (patternKeys.HasKey(priorityPattern) && patternKeys[priorityPattern] != "") {
                    assignedKey := patternKeys[priorityPattern]

                    ; Check for modifier keys
                    hasCtrl := InStr(assignedKey, "^")
                    hasAlt := InStr(assignedKey, "!")
                    hasShift := InStr(assignedKey, "+")

                    ; Extract base key
                    baseKey := StrReplace(assignedKey, "^", "")
                    baseKey := StrReplace(baseKey, "!", "")
                    baseKey := StrReplace(baseKey, "+", "")

                    ; Apply QWERTZ conversion if enabled
                    baseKey := ConvertQwertyToQwertz(baseKey)

                    ; Send modifiers down
                    if (hasCtrl)
                        ControlSend,, {Ctrl down}, ahk_id %win1%
                    if (hasAlt)
                        ControlSend,, {Alt down}, ahk_id %win1%
                    if (hasShift)
                        ControlSend,, {Shift down}, ahk_id %win1%
                    Sleep, 25

                    ; Send base key
                    ControlSend,, {%baseKey% down}, ahk_id %win1%
                    Sleep, 25
                    ControlSend,, {%baseKey% up}, ahk_id %win1%
                    Sleep, 25

                    ; Release modifiers
                    if (hasShift)
                        ControlSend,, {Shift up}, ahk_id %win1%
                    if (hasAlt)
                        ControlSend,, {Alt up}, ahk_id %win1%
                    if (hasCtrl)
                        ControlSend,, {Ctrl up}, ahk_id %win1%
                    Sleep, 25

                    skillCastSuccessfully := true

                } else {
                    ; FIXED: Add coordinate validation before clicking
                    if (IsObject(healingSkill) && healingSkill.MaxIndex() >= 1) {
                        X := healingSkill.1.x
                        Y := healingSkill.1.y

                        ; Validate coordinates before clicking
                        if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                            ToolTip, Heal Click at %X%`, %Y%, , , 2
                            ControlClick, x%X% y%Y%, ahk_id %win1%,, Left, 1
                            Sleep, 25
                            skillCastSuccessfully := true
                        } else {
                            ;UpdateHealerStatus("⚠ Invalid heal coordinates: " . X . "," . Y . " - skipping click")
                            break ; Exit the spam loop for this skill
                        }
                    } else {
                        ;UpdateHealerStatus("⚠ No heal coords available, skipping click.")
                        break
                    }
                }

                ; Debug: Show ground target status
                ; if (spamCount = 1) {
                ;     hasKey := healGroundTargetSkills.HasKey(priorityPattern)
                ;     isEnabled := (healGroundTargetSkills[priorityPattern] = true || healGroundTargetSkills[priorityPattern] = "1" || healGroundTargetSkills[priorityPattern] = "true")
                ;     hasCoords := healGroundTargetCoords.HasKey(priorityPattern)
                ;     ToolTip, GT Debug: hasKey=%hasKey% isEnabled=%isEnabled% hasCoords=%hasCoords% cast=%skillCastSuccessfully%, , , 4
                ;     SetTimer, RemoveToolTip4, 3000
                ; }

                ; Handle ground targeting if enabled (only on first spam attempt)
                if (spamCount = 1 && skillCastSuccessfully && healGroundTargetSkills.HasKey(priorityPattern) && (healGroundTargetSkills[priorityPattern] = true || healGroundTargetSkills[priorityPattern] = "1" || healGroundTargetSkills[priorityPattern] = "true") && healGroundTargetCoords.HasKey(priorityPattern)) {
                    Sleep, 150
                    groundCoords := healGroundTargetCoords[priorityPattern]
                    ; Add randomization to coordinates (±20 pixels)
                    Random, randX, -20, 20
                    Random, randY, -20, 20
                    relX := groundCoords.x + randX
                    relY := groundCoords.y + randY
                    ToolTip, Ground Target Click: %relX%`, %relY%, , , 3
                    SetTimer, RemoveToolTip3, 2000
                    ; Move mouse to ground target location
                    lParamMove := (relY << 16) | (relX & 0xFFFF)
                    SendMessage, 0x200, 0, lParamMove,, ahk_id %win1% ; WM_MOUSEMOVE
                    Sleep, 50
                    ; Click at ground target location
                    lParam := (relY << 16) | (relX & 0xFFFF)
                    SendMessage, 0x201, 0x0001, lParam,, ahk_id %win1% ; WM_LBUTTONDOWN
                    Sleep, 50
                    SendMessage, 0x202, 0, lParam,, ahk_id %win1% ; WM_LBUTTONUP
                    Sleep, 100
                }

                ; Recheck availability (search full screen width for 4K monitors)
                Sleep, 125
                healingSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

                if (!healingSkill) {
                    success := true
                    break
                }

                if (spamCount >= maxSpam) {
                    break
                }

                ; Optional: return to main character after heal
                if (returnafterheal = true) {
                    if (Templarok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, Templar)) {
                        ReturnToMainCharacter()
                    }
                }
            }

            ; Post-spam status
            if (!success) {
                ;UpdateHealerStatus("⚠ Heal pattern did not disappear after " . spamCount . " attempts, skipping.")
            } else {
                method := (patternKeys.HasKey(priorityPattern) && patternKeys[priorityPattern] != "") 
                ? "key: " . patternKeys[priorityPattern] 
                : "clicking"
                    ;UpdateHealerStatus("Used heal " . healInfo . " with " . method . " (" . spamCount . "x)")
                }

                SendMeleeAttack() ; Send melee attack after successful heal skill cast
                return true
            }
        }

        ;UpdateHealerStatus("No healing skills were found on screen.")
        return false
    }
    return

    DrawHollowRectangle(X1, Y1, X2, Y2, Name, BoxColor, IndicatorColor) {
        global BoundingBoxes

        Width := X2 - X1 + 1
        Height := Y2 - Y1 + 1

        IndicatorWidth := Width + 10
        IndicatorHeight := Height + 10
        IndicatorX1 := X1 - 5
        IndicatorY1 := Y1 - 5
        IndicatorX2 := IndicatorX1 + IndicatorWidth - 1
        IndicatorY2 := IndicatorY1 + IndicatorHeight - 1

        IndTopName := "IndTop" . A_Now . A_MSec
        Gui, %IndTopName%:New, +AlwaysOnTop -MaximizeBox -MinimizeBox +LastFound +ToolWindow -Caption, %Name%_IndTop
        Gui, %IndTopName%:Color, %IndicatorColor%
        WinSet, Transparent, 200
        Gui, %IndTopName%:Show, x%IndicatorX1% y%IndicatorY1% w%IndicatorWidth% h1 NoActivate
        BoundingBoxes.Push({hwnd: WinExist(), name: IndTopName})

        IndBottomName := "IndBottom" . A_Now . A_MSec
        Gui, %IndBottomName%:New, +AlwaysOnTop -MaximizeBox -MinimizeBox +LastFound +ToolWindow -Caption, %Name%_IndBottom
        Gui, %IndBottomName%:Color, %IndicatorColor%
        WinSet, Transparent, 200
        Gui, %IndBottomName%:Show, x%IndicatorX1% y%IndicatorY2% w%IndicatorWidth% h1 NoActivate
        BoundingBoxes.Push({hwnd: WinExist(), name: IndBottomName})

        IndLeftName := "IndLeft" . A_Now . A_MSec
        Gui, %IndLeftName%:New, +AlwaysOnTop -MaximizeBox -MinimizeBox +LastFound +ToolWindow -Caption, %Name%_IndLeft
        Gui, %IndLeftName%:Color, %IndicatorColor%
        WinSet, Transparent, 200
        Gui, %IndLeftName%:Show, x%IndicatorX1% y%IndicatorY1% w1 h%IndicatorHeight% NoActivate
        BoundingBoxes.Push({hwnd: WinExist(), name: IndLeftName})

        IndRightName := "IndRight" . A_Now . A_MSec
        Gui, %IndRightName%:New, +AlwaysOnTop -MaximizeBox -MinimizeBox +LastFound +ToolWindow -Caption, %Name%_IndRight
        Gui, %IndRightName%:Color, %IndicatorColor%
        WinSet, Transparent, 200
        Gui, %IndRightName%:Show, x%IndicatorX2% y%IndicatorY1% w1 h%IndicatorHeight% NoActivate
        BoundingBoxes.Push({hwnd: WinExist(), name: IndRightName})
    }

    ClearBoundingBoxes() {
        global BoundingBoxes

        for index, boxInfo in BoundingBoxes {
            Gui, % boxInfo.name . ":Destroy"
        }
        BoundingBoxes := []
    }

    RemoveToolTip:
        ToolTip
    return

    RemoveToolTip3:
        ToolTip, , , , 3
    return

    RemoveToolTip4:
        ToolTip, , , , 4
    return

    InitializePatternCounter() {
        highestNumber := 0

        for patternName, patternValue in patterns {
            if (SubStr(patternName, 1, 4) = "heal") {
                numberPart := SubStr(patternName, 5)
                if numberPart is integer
                {
                    if (numberPart > highestNumber)
                        highestNumber := numberPart
                }
            }
        }

        patternCounter := highestNumber + 1
    }

    SavePattern(patternName, patternText, keyAssignment, isGroundTarget := false, groundX := "", groundY := "", needsPreCastKey := false, preCastKey := "") {
        global iniFile, patterns, patternKeys, healGroundTargetSkills, healGroundTargetCoords, healPressKeyBeforeCast, healPreCastKeys

        FileEncoding, UTF-8
        IniWrite, %patternText%, %iniFile%, Patterns, %patternName%
        IniWrite, %keyAssignment%, %iniFile%, PatternKeys, %patternName%

        ; Save ground target settings
        IniWrite, %isGroundTarget%, %iniFile%, HealGroundTarget, %patternName%
        if (isGroundTarget && groundX != "" && groundY != "") {
            coordString := groundX . "," . groundY
            IniWrite, %coordString%, %iniFile%, HealGroundCoords, %patternName%
        }

        ; Save pre-cast key settings
        IniWrite, %needsPreCastKey%, %iniFile%, HealPreCastEnabled, %patternName%
        if (needsPreCastKey && preCastKey != "") {
            IniWrite, %preCastKey%, %iniFile%, HealPreCastKeys, %patternName%
        }
        FileEncoding

        patterns[patternName] := patternText
        patternKeys[patternName] := keyAssignment
        healGroundTargetSkills[patternName] := isGroundTarget
        if (isGroundTarget && groundX != "" && groundY != "") {
            healGroundTargetCoords[patternName] := {x: groundX, y: groundY}
        }
        healPressKeyBeforeCast[patternName] := needsPreCastKey
        if (needsPreCastKey && preCastKey != "") {
            healPreCastKeys[patternName] := preCastKey
        }
    }

    ; Save pet buff patterns to INI file
    SavePetBuffPatterns() {
        global iniFile, gnollPatterns, deathTyrantPatterns

        FileEncoding, UTF-8

        ; Delete existing sections first to avoid stale data
        IniDelete, %iniFile%, GnollPatterns
        IniDelete, %iniFile%, DeathTyrantPatterns

        ; Save gnoll patterns
        for index, pattern in gnollPatterns {
            keyName := "Pattern" . index
            IniWrite, %pattern%, %iniFile%, GnollPatterns, %keyName%
        }

        ; Save death tyrant patterns
        for index, pattern in deathTyrantPatterns {
            keyName := "Pattern" . index
            IniWrite, %pattern%, %iniFile%, DeathTyrantPatterns, %keyName%
        }

        FileEncoding
    }

    ; Save pet buff timer intervals to INI file
    SavePetBuffTimers() {
        global iniFile, gnollBuffInterval, dtBuffInterval

        FileEncoding, UTF-8
        IniWrite, %gnollBuffInterval%, %iniFile%, PetBuffTimers, GnollInterval
        IniWrite, %dtBuffInterval%, %iniFile%, PetBuffTimers, DTInterval
        FileEncoding
    }

    ; Load pet buff timer intervals from INI file
    LoadPetBuffTimers() {
        global iniFile, gnollBuffInterval, dtBuffInterval

        ; Load gnoll interval (default 30 minutes = 1800000 ms)
        IniRead, loadedGnollInterval, %iniFile%, PetBuffTimers, GnollInterval, 1800000
        if (loadedGnollInterval >= 60000 && loadedGnollInterval <= 59940000) { ; 1 min to 999 min
            gnollBuffInterval := loadedGnollInterval
        }

        ; Load DT interval (default 60 minutes = 3600000 ms)
        IniRead, loadedDTInterval, %iniFile%, PetBuffTimers, DTInterval, 3600000
        if (loadedDTInterval >= 60000 && loadedDTInterval <= 59940000) { ; 1 min to 999 min
            dtBuffInterval := loadedDTInterval
        }
    }

    ; Update pet buff checkbox labels with current timer values
    UpdatePetBuffLabels() {
        global gnollBuffInterval, dtBuffInterval

        ; Calculate minutes from milliseconds
        gnollMins := Round(gnollBuffInterval / 60000)
        dtMins := Round(dtBuffInterval / 60000)

        ; Update the checkbox labels on the main GUI
        Gui, 1:Default
        GuiControl,, gnollbuff, Enable Gnoll Buff (%gnollMins% mins)
        GuiControl,, dtbuff, Enable Death Tyrant Buff (%dtMins% mins)
    }

    ; Load auto-dura settings from INI file
    LoadAutoDuraSettings() {
        global SettingsFile, autoDuraInterval

        ; Load interval (default 30 minutes)
        IniRead, loadedInterval, %SettingsFile%, AutoDura, Interval, 30
        if (loadedInterval >= 1 && loadedInterval <= 999) {
            autoDuraInterval := loadedInterval
        }

        ; Update GUI control
        GuiControl,, autoDuraIntervalEdit, %autoDuraInterval%
    }

    ; Load pet buff patterns from INI file
    LoadPetBuffPatterns() {
        global iniFile, gnollPatterns, deathTyrantPatterns

        ; Initialize with default patterns if arrays are empty
        defaultGnollPattern := "|<>9E9F85-0.66$32.nzsPGAzy4xbTwzTNrzaBkxyw0k6TC6Nhj270u3H74T4y237yNk1Xz6w0Fzxj08TyEw47zAj23zznk0ztyM0TzLk07zsTU1zysTUT7c"
        defaultDTPattern1 := "|<>E5A657-0.52$19.rTszTwPjz5vzurzVv0sTUxD0ya2ML0CHCDDj3azW0Tk0hk1bU1rk0nw0vDsxwzWk1z0000001"
        defaultDTPattern2 := "|<>*94$16.QbRbnqTiNvz7rwjznTrSztwTbwuTzfzrBzwDzkTzU"

        gnollPatterns := []
        deathTyrantPatterns := []

        ; Load gnoll patterns
        IniRead, gnollPatternSection, %iniFile%, GnollPatterns
        if (gnollPatternSection != "ERROR" && gnollPatternSection != "") {
            Loop, Parse, gnollPatternSection, `n
            {
                if (A_LoopField != "") {
                    equalsPos := InStr(A_LoopField, "=")
                    if (equalsPos > 0) {
                        patternText := SubStr(A_LoopField, equalsPos + 1)
                        gnollPatterns.Push(patternText)
                    }
                }
            }
        }

        ; If no patterns loaded, add default
        if (gnollPatterns.Length() = 0) {
            gnollPatterns.Push(defaultGnollPattern)
        }

        ; Load death tyrant patterns
        IniRead, dtPatternSection, %iniFile%, DeathTyrantPatterns
        if (dtPatternSection != "ERROR" && dtPatternSection != "") {
            Loop, Parse, dtPatternSection, `n
            {
                if (A_LoopField != "") {
                    equalsPos := InStr(A_LoopField, "=")
                    if (equalsPos > 0) {
                        patternText := SubStr(A_LoopField, equalsPos + 1)
                        deathTyrantPatterns.Push(patternText)
                    }
                }
            }
        }

        ; If no patterns loaded, add defaults
        if (deathTyrantPatterns.Length() = 0) {
            deathTyrantPatterns.Push(defaultDTPattern1)
            deathTyrantPatterns.Push(defaultDTPattern2)
        }
    }

    GetPattern(patternName) {
        if (patterns.HasKey(patternName))
            return patterns[patternName]
    return ""
}

LoadPattern(patternName) {
    IniRead, loadedPattern, %iniFile%, Patterns, %patternName%, %A_Space%
    if (loadedPattern != "") {
        patterns[patternName] := loadedPattern
    return loadedPattern
}
return ""
}

LoadAllPatterns() {
    ; Load patterns
    IniRead, patternNames, %iniFile%, Patterns
    if (patternNames != "ERROR") {
        Loop, Parse, patternNames, `n
        {
            if (A_LoopField != "") {
                ; Find first equals sign position
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    patternText := SubStr(A_LoopField, equalsPos + 1)
                    patterns[patternName] := patternText
                }
            }
        }
    }

    ; Load pattern keys
    IniRead, patternKeyNames, %iniFile%, PatternKeys
    if (patternKeyNames != "ERROR") {
        Loop, Parse, patternKeyNames, `n
        {
            if (A_LoopField != "") {
                ; Find first equals sign position
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    keyAssignment := SubStr(A_LoopField, equalsPos + 1)
                    patternKeys[patternName] := keyAssignment
                }
            }
        }
    }

    ; Load pattern custom names
    IniRead, patternNamesList, %iniFile%, PatternNames
    if (patternNamesList != "ERROR") {
        nameCount := 0
        Loop, Parse, patternNamesList, `n
        {
            if (A_LoopField != "") {
                ; Find first equals sign position
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    customName := SubStr(A_LoopField, equalsPos + 1)
                    patternNames[patternName] := customName
                    nameCount++
                }
            }
        }
        if (nameCount > 0) {
            UpdateHealerStatus("Loaded " . nameCount . " custom heal names from INI")
        }
    }

    patternCount := patterns.Count()
    if (patternCount > 0)
        UpdateHealerStatus("Loaded " . patternCount . " pattern(s) successfully.")

    ; Also show custom names count at startup
    nameCount := 0
    for patternName, customName in patternNames {
        if (patterns.HasKey(patternName) && SubStr(patternName, 1, 4) = "heal") {
            nameCount++
        }
    }
    if (nameCount > 0) {
        UpdateHealerStatus("Loaded " . nameCount . " custom heal names at startup")
    }

    ; Load heal ground target settings
    IniRead, healGroundTargetList, %iniFile%, HealGroundTarget
    if (healGroundTargetList != "ERROR") {
        Loop, Parse, healGroundTargetList, `n
        {
            if (A_LoopField != "") {
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    isGroundTarget := SubStr(A_LoopField, equalsPos + 1)
                    healGroundTargetSkills[patternName] := isGroundTarget
                }
            }
        }
    }

    ; Load heal ground target coordinates
    IniRead, healGroundCoordsList, %iniFile%, HealGroundCoords
    if (healGroundCoordsList != "ERROR") {
        Loop, Parse, healGroundCoordsList, `n
        {
            if (A_LoopField != "") {
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    coordString := SubStr(A_LoopField, equalsPos + 1)
                    coords := StrSplit(coordString, ",")
                    if (coords.Length() = 2) {
                        healGroundTargetCoords[patternName] := {x: coords[1], y: coords[2]}
                    }
                }
            }
        }
    }

    ; Load heal pre-cast key settings
    IniRead, healPreCastEnabledList, %iniFile%, HealPreCastEnabled
    if (healPreCastEnabledList != "ERROR") {
        Loop, Parse, healPreCastEnabledList, `n
        {
            if (A_LoopField != "") {
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    needsPreCast := SubStr(A_LoopField, equalsPos + 1)
                    healPressKeyBeforeCast[patternName] := needsPreCast
                }
            }
        }
    }

    ; Load heal pre-cast keys
    IniRead, healPreCastKeysList, %iniFile%, HealPreCastKeys
    if (healPreCastKeysList != "ERROR") {
        Loop, Parse, healPreCastKeysList, `n
        {
            if (A_LoopField != "") {
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    preCastKey := SubStr(A_LoopField, equalsPos + 1)
                    healPreCastKeys[patternName] := preCastKey
                }
            }
        }
    }
}

RefreshHealSkillsList() {
    ; This function now just triggers a priority list refresh
    ; since we're using the same approach as DPS tab
    RefreshHealPriorityList()
}

CreateHealKeyInputs() {
    global patterns, patternKeys

    healIndex := 1
    for patternName, patternText in patterns {
        if (SubStr(patternName, 1, 4) = "heal" && healIndex <= 3) {
            ; For now, just update status with available heals
            ; We'll handle key assignment through a different method
            healIndex++
        }
    }
}

AssignHealKeys:
    ; Show available heal skills and let user assign keys
    healList := "=== ASSIGN KEYS TO HEALING SKILLS ===`n`n"
    healCount := 0

    for patternName, patternText in patterns {
        if (SubStr(patternName, 1, 4) = "heal") {
            healCount++
            displayName := GetDisplayName(patternName)
            currentKey := patternKeys.HasKey(patternName) ? patternKeys[patternName] : "(none)"

                healList .= healCount . ". " . displayName . " [" . patternName . "]`n"
                healList .= " Current Key: " . currentKey . "`n`n"
            }
        }

        if (healCount = 0) {
            UpdateHealerStatus("No healing skills to assign keys to. Capture some skills first.")
            return
        }

        healList .= "`nEnter the number of the healing skill to assign a key to:"

        InputBox, healNumber, Assign Heal Key, %healList%, , 400, 300
        if (ErrorLevel)
            return

        ; Find the selected heal
        currentIndex := 1
        selectedHeal := ""
        for patternName, patternText in patterns {
            if (SubStr(patternName, 1, 4) = "heal") {
                if (currentIndex = healNumber) {
                    selectedHeal := patternName
                    break
                }
                currentIndex++
            }
        }

        if (selectedHeal = "") {
            UpdateHealerStatus("Invalid healing skill number selected.")
            return
        }

        ; Get key assignment
        selectedDisplayName := GetDisplayName(selectedHeal)
        currentKey := patternKeys.HasKey(selectedHeal) ? patternKeys[selectedHeal] : ""
            keyPrompt := "=== ASSIGN KEY ===`n`nHealing Skill: " . selectedDisplayName . "`nID: " . selectedHeal . "`nCurrent Key: " . currentKey . "`n`nEnter new key (examples: 1, 2, F1, F2, etc.):"
            InputBox, newKey, Assign Key to Healing Skill, %keyPrompt%, , 400, 200, , , , , %currentKey%
            if (ErrorLevel)
                return

            ; Save the assignment
            patternKeys[selectedHeal] := newKey
            SavePatternKey(selectedHeal, newKey)
            UpdateHealerStatus("Assigned key '" . newKey . "' to '" . selectedDisplayName . "' [" . selectedHeal . "] and saved to INI")
            RefreshHealPriorityList()
        return

        RenameHealSkills:
            if (patterns.Count() = 0) {
                UpdateHealerStatus("No healing skills to rename.")
                return
            }

            ; Build skill list and selection array in one pass
            healList := "=== RENAME HEALING SKILLS ===`n`n"
            skillArray := []

            for patternName, patternText in patterns {
                if (SubStr(patternName, 1, 4) = "heal") {
                    skillArray.Push(patternName)
                    displayName := GetDisplayName(patternName)
                    status := (displayName != patternName) ? "(Custom)" : "(Default)"
                        healList .= skillArray.Length() . ". " . displayName . " [" . patternName . "] " . status . "`n"
                    }
                }

                ; Create scrollable GUI instead of InputBox
                Gui, RenameHealSelect:New, +Resize, Rename Heal Skill
                Gui, RenameHealSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %healList%`n`nEnter skill number:
                Gui, RenameHealSelect:Add, Edit, x10 y340 w100 h20 vHealNumberInput
                Gui, RenameHealSelect:Add, Button, x120 y340 w60 h20 gRenameHealSelectOK, OK
                Gui, RenameHealSelect:Add, Button, x190 y340 w60 h20 gRenameHealSelectCancel, Cancel
                Gui, RenameHealSelect:Show, w600 h380
                return

                RenameHealSelectOK:
                    Gui, RenameHealSelect:Submit
                    healNumber := HealNumberInput
                    if (healNumber < 1 || healNumber > skillArray.Length()) {
                        UpdateHealerStatus("Invalid selection.")
                        return
                    }
                    Gui, RenameHealSelect:Destroy

                    selectedHeal := skillArray[healNumber]
                    currentDisplayName := GetDisplayName(selectedHeal)

                    InputBox, newName, Rename Heal Skill, Original: %selectedHeal%`nCurrent: %currentDisplayName%`n`nNew name:, , 400, 180, , , , , %currentDisplayName%
                    if (ErrorLevel || newName = "") {
                        if (!ErrorLevel) UpdateHealerStatus("Name cannot be empty.")
                            return
                    }

                    ; Update in-memory object directly
                    patternNames[selectedHeal] := newName
                    SavePatternName(selectedHeal, newName)
                    UpdateHealerStatus("Renamed '" . selectedHeal . "' to '" . newName . "'")

                    ; Force refresh with timer
                    SetTimer, ForceRefreshHeal, -50
                return

                RenameHealSelectCancel:
                    Gui, RenameHealSelect:Destroy
                return

                ModifyHealSkill:
                    if (patterns.Count() = 0) {
                        UpdateHealerStatus("No healing skills to modify.")
                        return
                    }

                    ; Build skill list with current modifier status
                    healList := "=== MODIFY HEALING SKILL ===`n`n"
                    skillArray := []

                    for patternName, patternText in patterns {
                        if (SubStr(patternName, 1, 4) = "heal") {
                            skillArray.Push(patternName)
                            displayName := GetDisplayName(patternName)

                            ; Show current modifier status
                            hasGroundTarget := healGroundTargetSkills.HasKey(patternName) && healGroundTargetSkills[patternName]
                            hasPreCast := healPressKeyBeforeCast.HasKey(patternName) && healPressKeyBeforeCast[patternName]

                            modStatus := ""
                            if (hasGroundTarget && hasPreCast)
                                modStatus := " [Click-After + Button-Before]"
                            else if (hasGroundTarget)
                                modStatus := " [Click-After]"
                            else if (hasPreCast)
                                modStatus := " [Button-Before]"
                            else
                                modStatus := " [No modifiers]"

                            healList .= skillArray.Length() . ". " . displayName . modStatus . "`n"
                        }
                    }

                    ; Create selection GUI
                    Gui, ModifyHealSelect:New, +Resize, Modify Healing Skill
                    Gui, ModifyHealSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %healList%`n`nEnter skill number to modify:
                    Gui, ModifyHealSelect:Add, Edit, x10 y340 w100 h20 vModifyHealNumberInput
                    Gui, ModifyHealSelect:Add, Button, x120 y340 w60 h20 gModifyHealSelectOK, OK
                    Gui, ModifyHealSelect:Add, Button, x190 y340 w60 h20 gModifyHealSelectCancel, Cancel
                    Gui, ModifyHealSelect:Show, w600 h380
                return

                ModifyHealSelectOK:
                    Gui, ModifyHealSelect:Submit
                    healNumber := ModifyHealNumberInput
                    if (healNumber < 1 || healNumber > skillArray.Length()) {
                        UpdateHealerStatus("Invalid selection.")
                        return
                    }
                    Gui, ModifyHealSelect:Destroy

                    selectedHeal := skillArray[healNumber]
                    displayName := GetDisplayName(selectedHeal)

                    ; Get current modifier states
                    currentGroundTarget := healGroundTargetSkills.HasKey(selectedHeal) && healGroundTargetSkills[selectedHeal]
                    currentPreCast := healPressKeyBeforeCast.HasKey(selectedHeal) && healPressKeyBeforeCast[selectedHeal]

                    ; Create modifier options GUI
                    Gui, ModifyHealOptions:New, , Modify Skill: %displayName%
                    Gui, ModifyHealOptions:Add, Text, x20 y20 w400, Select modifiers for: %displayName%
                    Gui, ModifyHealOptions:Add, Checkbox, x20 y50 w400 vModifyGroundTarget Checked%currentGroundTarget%, Click location AFTER skill cast (ground target)
                    Gui, ModifyHealOptions:Add, Checkbox, x20 y80 w400 vModifyPreCast Checked%currentPreCast%, Press button BEFORE skill cast
                    Gui, ModifyHealOptions:Add, Button, x120 y120 w80 h30 gApplyHealModifiers, Apply
                    Gui, ModifyHealOptions:Add, Button, x220 y120 w80 h30 gCancelHealModifiers, Cancel
                    Gui, ModifyHealOptions:Show, w450 h170
                return

                ModifyHealSelectCancel:
                    Gui, ModifyHealSelect:Destroy
                return

                ApplyHealModifiers:
                    Gui, ModifyHealOptions:Submit

                    ; Handle ground target modification
                    if (ModifyGroundTarget) {
                        ; If enabling ground target and it wasn't enabled before
                        if (!healGroundTargetSkills.HasKey(selectedHeal) || !healGroundTargetSkills[selectedHeal]) {
                            MsgBox, 0, Set Ground Target Location, Right-click on the location where the skill should be cast.`n`nPress OK first, then right-click the location.
                            UpdateHealerStatus("Waiting for right-click to set ground target location...")
                            KeyWait, RButton, D
                            MouseGetPos, groundX, groundY
                            ; Convert screen coords to window-relative coords for saving
                            WinGetPos, winX, winY,,, ahk_id %win1%
                            groundX := groundX - winX
                            groundY := groundY - winY

                            ; Save ground target settings
                            healGroundTargetSkills[selectedHeal] := true
                            coordString := groundX . "," . groundY
                            healGroundTargetCoords[selectedHeal] := {x: groundX, y: groundY}
                            FileEncoding, UTF-8
                            IniWrite, true, %iniFile%, HealGroundTarget, %selectedHeal%
                            IniWrite, %coordString%, %iniFile%, HealGroundCoords, %selectedHeal%
                            FileEncoding

                            ; Confirmation message
                            MsgBox, 64, Ground Target Set, Ground target location has been set successfully!`n`nRelative coordinates: %groundX%`, %groundY%
                        }
                    } else {
                        ; Remove ground target if unchecked
                        healGroundTargetSkills[selectedHeal] := false
                        healGroundTargetCoords.Delete(selectedHeal)
                        IniDelete, %iniFile%, HealGroundTarget, %selectedHeal%
                        IniDelete, %iniFile%, HealGroundCoords, %selectedHeal%
                    }

                    ; Handle pre-cast key modification
                    if (ModifyPreCast) {
                        ; If enabling pre-cast and it wasn't enabled before OR key needs updating
                        if (!healPressKeyBeforeCast.HasKey(selectedHeal) || !healPressKeyBeforeCast[selectedHeal] || !healPreCastKeys.HasKey(selectedHeal)) {
                            currentPreKey := healPreCastKeys.HasKey(selectedHeal) ? healPreCastKeys[selectedHeal] : ""
                                InputBox, preCastKey, Pre-Cast Key, Enter the key to press BEFORE the main skill key (e.g. Tab):, , 350, 150, , , , , %currentPreKey%
                                if (!ErrorLevel && preCastKey != "") {
                                    healPressKeyBeforeCast[selectedHeal] := true
                                    healPreCastKeys[selectedHeal] := preCastKey
                                    FileEncoding, UTF-8
                                    IniWrite, true, %iniFile%, HealPreCastEnabled, %selectedHeal%
                                    IniWrite, %preCastKey%, %iniFile%, HealPreCastKeys, %selectedHeal%
                                    FileEncoding
                                }
                            }
                        } else {
                            ; Remove pre-cast if unchecked
                            healPressKeyBeforeCast[selectedHeal] := false
                            healPreCastKeys.Delete(selectedHeal)
                            IniDelete, %iniFile%, HealPreCastEnabled, %selectedHeal%
                            IniDelete, %iniFile%, HealPreCastKeys, %selectedHeal%
                        }

                        ; Force refresh priority list with timer to ensure GUI has processed
                        UpdateHealerStatus("Updated modifiers for '" . displayName . "'")
                        Gui, ModifyHealOptions:Destroy
                        SetTimer, ForceRefreshHeal, -200
                        return

                        CancelHealModifiers:
                            Gui, ModifyHealOptions:Destroy
                        return

                        ReloadCustomNames() {
                            global patterns, patternNames, iniFile

                            ; Clear current names
                            patternNames := {}

                            ; Reload pattern custom names
                            IniRead, patternNamesList, %iniFile%, PatternNames
                            if (patternNamesList != "ERROR") {
                                nameCount := 0
                                Loop, Parse, patternNamesList, `n
                                {
                                    if (A_LoopField != "") {
                                        parts := StrSplit(A_LoopField, "=", " `t")
                                        if (parts.Length() >= 2) {
                                            patternName := parts[1]
                                            customName := parts[2]
                                            patternNames[patternName] := customName
                                            nameCount++
                                        }
                                    }
                                }
                            }
                        }

                        LoadAllHealKeys:
                            global patterns, patternKeys, iniFile

                            ; Load all key assignments from INI
                            keyLoadCount := 0

                            ; Read the PatternKeys section
                            IniRead, patternKeyNames, %iniFile%, PatternKeys
                            if (patternKeyNames != "ERROR") {
                                Loop, Parse, patternKeyNames, `n
                                {
                                    parts := StrSplit(A_LoopField, "=", " `t")
                                    if (parts.Length() >= 2) {
                                        patternName := parts[1]
                                        keyAssignment := parts[2]

                                        ; Only load if it's a heal pattern
                                        if (SubStr(patternName, 1, 4) = "heal") {
                                            patternKeys[patternName] := keyAssignment
                                            keyLoadCount++
                                        }
                                    }
                                }
                            }

                            UpdateHealerStatus("Loaded " . keyLoadCount . " heal key assignments from INI file")
                            RefreshHealSkillsList()
                        return

                        ShowHealKeysStatus:
                            statusMsg := "=== HEAL SKILLS STATUS ===`r`n`r`nINI: " . iniFile . "`r`n`r`n"

                            if (patterns.Count() = 0) {
                                statusMsg .= "No healing skills captured yet.`r`n"
                            } else {
                                healCount := 0
                                for patternName, patternText in patterns {
                                    if (SubStr(patternName, 1, 4) = "heal") {
                                        displayName := GetDisplayName(patternName)
                                        key := patternKeys.HasKey(patternName) ? patternKeys[patternName] : "Click"
                                            statusMsg .= ++healCount . ". " . displayName . " [" . patternName . "] - " . key . "`r`n"
                                        }
                                    }

                                    statusMsg .= "`r`n=== PRIORITY ORDER ===`r`n"
                                    for index, priorityPattern in healPriorities {
                                        if (patterns.HasKey(priorityPattern))
                                            statusMsg .= index . ". " . GetDisplayName(priorityPattern) . "`r`n"
                                    }
                                }

                                UpdateHealerStatus(statusMsg)
                                return

                                ShowSavedHeals:
                                    global patterns, patternNames, patternKeys

                                    ; Create comprehensive list of all saved healing skills
                                    healList := "=== ALL SAVED HEALING SKILLS ===`n`n"
                                    healCount := 0

                                    for patternName, patternText in patterns {
                                        if (SubStr(patternName, 1, 4) = "heal") {
                                            healCount++

                                            ; Get display name
                                            displayName := GetDisplayName(patternName)

                                            ; Get assigned key
                                            assignedKey := patternKeys.HasKey(patternName) ? patternKeys[patternName] : "(none)"

                                                ; Format: heal1 = Greater Heal [Key: 1]
                                                if (displayName != patternName) {
                                                    healList .= patternName . " = " . displayName . "`n"
                                                } else {
                                                    healList .= patternName . " (no custom name)`n"
                                                }
                                                healList .= " Key: " . assignedKey . "`n`n"
                                            }
                                        }

                                        if (healCount = 0) {
                                            healList .= "No healing skills have been captured yet.`n`n"
                                            healList .= "Use 'Add Healing Skill' to capture some healing skills first."
                                        } else {
                                            healList .= "Total: " . healCount . " healing skills saved`n`n"
                                            healList .= "• Use 'Rename Skills' to set custom names`n"
                                            healList .= "• Use 'Assign Heal Keys' to set keyboard shortcuts"
                                        }

                                        ; Show in a message box for easy viewing
                                        MsgBox, 0, Saved Healing Skills, %healList%
                                        return

                                        UpdatePatternKey:
                                            global patternKeys

                                            ; Get the control name that triggered this
                                            GuiControlGet, controlName, Focus

                                            ; Get pattern name from mapping
                                            patternName := HealControlMap_%controlName%

                                            ; Get the new key value
                                            GuiControlGet, newKey,, %controlName%

                                            ; Save the key assignment
                                            patternKeys[patternName] := newKey
                                            SavePatternKey(patternName, newKey)

                                            UpdateHealerStatus("Updated key for '" . patternName . "' to: " . newKey)
                                        return

                                        SavePatternKey(patternName, keyAssignment) {
                                            FileEncoding, UTF-8
                                            IniWrite, %keyAssignment%, %iniFile%, PatternKeys, %patternName%
                                            FileEncoding
                                        }

                                        GetDisplayName(patternName) {
                                            global patternNames

                                            ; Debug what's in patternNames
                                            if (patternNames.HasKey(patternName)) {
                                                customName := patternNames[patternName]
                                                if (customName != "") {
                                                    return customName
                                                }
                                            }
                                        return patternName ; fallback to original name
                                    }

                                    SavePatternName(patternName, customName) {
                                        global iniFile, patternNames

                                        ; Write to INI file
                                        FileEncoding, UTF-8
                                        IniWrite, %customName%, %iniFile%, PatternNames, %patternName%
                                        FileEncoding

                                        ; Update in-memory storage
                                        patternNames[patternName] := customName
                                    }

                                    UpdateHealerStatus(message) {
                                        global HealerStatusText

                                        ; Get current time
                                        FormatTime, timeStamp,, HH:mm:ss

                                        ; Add timestamp to message
                                        newMessage := "[" . timeStamp . "] " . message . "`r`n"

                                        ; Prepend to existing text (new messages at top)
                                        HealerStatusText := newMessage . HealerStatusText

                                        ; Keep only the first 15 lines to prevent overflow
                                        lines := StrSplit(HealerStatusText, "`r`n")
                                        if (lines.Length() > 15) {
                                            HealerStatusText := ""
                                            Loop, 15 {
                                                if (lines[A_Index] != "") {
                                                    HealerStatusText .= lines[A_Index] . "`r`n"
                                                }
                                            }
                                        }

                                        ; Update the GUI control (simple approach that works)
                                        GuiControl,, HealerStatusEdit, %HealerStatusText%
                                    }

                                    ; ; ========= KEYPRESSER FUNCTIONS =========

                                    StartStop1:
                                        Gui, Submit, NoHide

                                        KeyCombination1 := KeyCombinationEdit1
                                        KeyDelay1 := KeyDelayEdit1
                                        TimerInterval1 := TimerIntervalEdit1

                                        if (!IsRunning1) {
                                            if (win1 = "") {
                                                UpdateStatus1("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination1 = "") {
                                                UpdateStatus1("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence1 := StrSplit(KeyCombination1, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning1 := true
                                            GuiControl,, StartStop1, Stop1
                                            UpdateStatus1("Running: " . KeyCombination1)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys1

                                            NextExecutionTime1 := A_TickCount + (TimerInterval1 * 60 * 1000)
                                        } else {
                                            IsRunning1 := false
                                            GuiControl,, StartStop1, Start1
                                            UpdateStatus1("Stopped")
                                            GuiControl,, CountdownText1, Next: --
                                        }
                                    return

                                    StartStop2:
                                        Gui, Submit, NoHide

                                        KeyCombination2 := KeyCombinationEdit2
                                        KeyDelay2 := KeyDelayEdit2
                                        TimerInterval2 := TimerIntervalEdit2

                                        if (!IsRunning2) {
                                            if (win1 = "") {
                                                UpdateStatus2("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination2 = "") {
                                                UpdateStatus2("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence2 := StrSplit(KeyCombination2, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning2 := true
                                            GuiControl,, StartStop2, Stop2
                                            UpdateStatus2("Running: " . KeyCombination2)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys2

                                            NextExecutionTime2 := A_TickCount + (TimerInterval2 * 60 * 1000)
                                        } else {
                                            IsRunning2 := false
                                            GuiControl,, StartStop2, Start2
                                            UpdateStatus2("Stopped")
                                            GuiControl,, CountdownText2, Next: --
                                        }
                                    return

                                    StartStop3:
                                        Gui, Submit, NoHide

                                        KeyCombination3 := KeyCombinationEdit3
                                        KeyDelay3 := KeyDelayEdit3
                                        TimerInterval3 := TimerIntervalEdit3

                                        if (!IsRunning3) {
                                            if (win1 = "") {
                                                UpdateStatus3("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination3 = "") {
                                                UpdateStatus3("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence3 := StrSplit(KeyCombination3, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning3 := true
                                            GuiControl,, StartStop3, Stop3
                                            UpdateStatus3("Running: " . KeyCombination3)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys3

                                            NextExecutionTime3 := A_TickCount + (TimerInterval3 * 60 * 1000)
                                        } else {
                                            IsRunning3 := false
                                            GuiControl,, StartStop3, Start3
                                            UpdateStatus3("Stopped")
                                            GuiControl,, CountdownText3, Next: --
                                        }
                                    return

                                    StopAll:
                                        if (IsRunning1) {
                                            IsRunning1 := false
                                            GuiControl,, StartStop1, Start1
                                            UpdateStatus1("Stopped")
                                            GuiControl,, CountdownText1, Next: --
                                        }
                                        if (IsRunning2) {
                                            IsRunning2 := false
                                            GuiControl,, StartStop2, Start2
                                            UpdateStatus2("Stopped")
                                            GuiControl,, CountdownText2, Next: --
                                        }
                                        if (IsRunning3) {
                                            IsRunning3 := false
                                            GuiControl,, StartStop3, Start3
                                            UpdateStatus3("Stopped")
                                            GuiControl,, CountdownText3, Next: --
                                        }
                                        SetTimer, CheckExecutions, Off
                                        StopWindowMonitoring()
                                    return

                                    Stop1:
                                        if (IsRunning1) {
                                            IsRunning1 := false
                                            GuiControl,, StartStop1, Start1
                                            UpdateStatus1("Stopped")
                                            GuiControl,, CountdownText1, Next: --
                                        }
                                    return

                                    Stop2:
                                        if (IsRunning2) {
                                            IsRunning2 := false
                                            GuiControl,, StartStop2, Start2
                                            UpdateStatus2("Stopped")
                                            GuiControl,, CountdownText2, Next: --
                                        }
                                    return

                                    Stop3:
                                        if (IsRunning3) {
                                            IsRunning3 := false
                                            GuiControl,, StartStop3, Start3
                                            UpdateStatus3("Stopped")
                                            GuiControl,, CountdownText3, Next: --
                                        }
                                    return

                                    ChatBuffToggle:
                                        Gui, Submit, NoHide
                                        if (chatbuff) {
                                            ; Load existing commands
                                            savedCommands := []
                                            IniRead, commandCount, %SettingsFile%, ChatBuffCommands, Count, 0
                                            Loop, %commandCount% {
                                                IniRead, command, %SettingsFile%, ChatBuffCommands, Command%A_Index%, ERROR
                                                if (command != "" && command != "ERROR") {
                                                    savedCommands.Push(command)
                                                }
                                            }
                                            
                                            ; Get first command
                                            defaultCmd := savedCommands.Length() > 0 ? savedCommands[1] : "/info"
                                            InputBox, firstCommand, Chat Buff Command, Enter first chat command:, , 300, 120, , , , , %defaultCmd%
                                            if (ErrorLevel || firstCommand = "") {
                                                GuiControl,, chatbuff, 0
                                                chatbuff := false
                                                return
                                            }
                                            
                                            ; Start fresh list
                                            chatBuffCommands := []
                                            chatBuffCommands.Push(firstCommand)
                                            
                                            ; Ask for more commands
                                            cmdIndex := 2
                                            Loop {
                                                MsgBox, 4, More Commands?, Do you want to add another chat buff command?
                                                IfMsgBox No
                                                    break
                                                defaultNext := cmdIndex <= savedCommands.Length() ? savedCommands[cmdIndex] : ""
                                                InputBox, nextCommand, Chat Buff Command, Enter next chat command:, , 300, 120, , , , , %defaultNext%
                                                if (ErrorLevel || nextCommand = "")
                                                    break
                                                chatBuffCommands.Push(nextCommand)
                                                cmdIndex++
                                            }
                                            
                                            ; Save commands
                                            IniDelete, %SettingsFile%, ChatBuffCommands
                                            IniWrite, % chatBuffCommands.Length(), %SettingsFile%, ChatBuffCommands, Count
                                            for index, command in chatBuffCommands {
                                                IniWrite, %command%, %SettingsFile%, ChatBuffCommands, Command%index%
                                            }
                                            
                                            ; Send immediately then start timer
                                            if (win1 != "") {
                                                gosub, SendChatBuffCommand
                                                SetTimer, SendChatBuffCommand, % (chatBuffTimerEdit * 60 * 1000)
                                                SetTimer, UpdateChatBuffTimeLeft, 1000
                                                chatBuffStartTime := A_TickCount
                                            }
                                        } else {
                                            SetTimer, SendChatBuffCommand, Off
                                            SetTimer, UpdateChatBuffTimeLeft, Off
                                            GuiControl,, chatBuffTimeLeft, --:--:--
                                        }
                                        IniWrite, %chatbuff%, %SettingsFile%, Settings, chatbuff
                                    return

                                    SendChatBuffCommand:
                                        if (win1 != "") {
                                            IniRead, commandCount, %SettingsFile%, ChatBuffCommands, Count, 0
                                            Loop, %commandCount% {
                                                IniRead, command, %SettingsFile%, ChatBuffCommands, Command%A_Index%, 
                                                if (command != "" && command != "ERROR") {
                                                    WinActivate, ahk_id %win1%
                                                    Sleep, 150
                                                    Clipboard := command
                                                    Send, {Enter}
                                                    Sleep, 80
                                                    Send, ^v
                                                    Sleep, 80
                                                    Send, {Enter}
                                                    Random, randSleep, 500, 2000
                                                    Sleep, %randSleep%
                                                }
                                            }
                                            chatBuffStartTime := A_TickCount
                                        }
                                    return

                                    UpdateChatBuffTimeLeft:
                                        global chatBuffStartTime, chatBuffTimerEdit
                                        if (!chatBuffStartTime)
                                            chatBuffStartTime := A_TickCount
                                        interval := chatBuffTimerEdit ? chatBuffTimerEdit : 63
                                        intervalMs := interval * 60 * 1000
                                        elapsed := A_TickCount - chatBuffStartTime
                                        remaining := intervalMs - elapsed
                                        if (remaining < 0)
                                            remaining := 0
                                        minutes := Floor(remaining / 60000)
                                        seconds := Floor(Mod(remaining, 60000) / 1000)
                                        GuiControl,, chatBuffTimeLeft, % Format("{:02}:{:02}", minutes, seconds)
                                    return

                                    savechatbufftimer:
                                        Gui, Submit, NoHide
                                        ; Save the chat buff timer interval to INI
                                        IniWrite, %chatBuffTimerEdit%, %SettingsFile%, ChatBuff, TimerInterval
                                        ToolTip, Chat buff timer interval saved!, 10, 10, 4
                                        SetTimer, RemoveStartAllTooltip, -1500
                                    return
                                    StartAllTimers:
                                        Gui, Submit, NoHide

                                        ; Validate that window is selected
                                        if (win1 = "") {
                                            MsgBox, 48, Error, Please select a target window first!
                                            return
                                        }

                                        ; Get all settings from GUI
                                        KeyCombination1 := KeyCombinationEdit1
                                        KeyDelay1 := KeyDelayEdit1
                                        TimerInterval1 := TimerIntervalEdit1
                                        KeyCombination2 := KeyCombinationEdit2
                                        KeyDelay2 := KeyDelayEdit2
                                        TimerInterval2 := TimerIntervalEdit2
                                        KeyCombination3 := KeyCombinationEdit3
                                        KeyDelay3 := KeyDelayEdit3
                                        TimerInterval3 := TimerIntervalEdit3

                                        ; Validate that at least one sequence has keys defined
                                        if (KeyCombination1 = "" && KeyCombination2 = "" && KeyCombination3 = "") {
                                            MsgBox, 48, Error, Please configure at least one key sequence!
                                            return
                                        }
                                        ; Ask if user wants to use chat buffs
                                        MsgBox, 4, Chat Buffs, Do you want to activate a chat buff (e.g. /info or custom command)?
                                        IfMsgBox Yes
                                        {
                                            ; Load last used chat command from INI
                                            IniRead, lastChatBuff, %SettingsFile%, ChatBuff, Command, /info
                                            ; Show input box with last used command pre-filled
                                            InputBox, chatBuffCommand, Enter Chat Buff Command, Enter the chat command to use (more power):, , 400, 120, , , , , %lastChatBuff%
                                            if (!ErrorLevel && chatBuffCommand != "")
                                            {
                                                ; Save to INI for next time
                                                IniWrite, %chatBuffCommand%, %SettingsFile%, ChatBuff, Command
                                                ; If /info, send it to the game window
                                                if (TargetGameWindow != "")
                                                {
                                                    WinActivate, ahk_id %TargetGameWindow%
                                                    Sleep, 150
                                                    Clipboard := chatBuffCommand
                                                    Send, {Enter}
                                                    Sleep, 80
                                                    Send, ^v
                                                    Sleep, 80
                                                    Send, {Enter}
                                                    Sleep, 300
                                                    ; Set timer to send chat buff at the correct interval (minutes)
                                                    global chatBuffCommandGlobal := chatBuffCommand
                                                    interval := chatBuffTimerEdit ? chatBuffTimerEdit : 63
                                                    intervalMs := interval * 60 * 1000
                                                    SetTimer, SendChatBuffCommand, %intervalMs%
                                                }
                                            }
                                        }

                                        ; Ask about pet buffs
                                        MsgBox, 4, Pet Buffs, Do you want to activate both pet buffs (DT and Gnoll)?
                                        IfMsgBox Yes
                                        {
                                            activatePetBuffs := true
                                        }
                                        else
                                        {
                                            activatePetBuffs := false
                                        }

                                        ; Activate Death Tyrant buff BEFORE Sequence 1 if requested
                                        if (activatePetBuffs && !dtbuff) {
                                            dtbuff := true
                                            GuiControl,, dtbuff, 1
                                            deathtyrant()
                                            SetTimer, deathtyrant, 3000000
                                            ToolTip, Death Tyrant buff activated!, 10, 10, 4
                                            Sleep, 2000
                                            ToolTip,,,,4
                                        }

                                        ; Start Sequence 1 if configured
                                        if (KeyCombination1 && !IsRunning1) {
                                            if (win1 = "") {
                                                UpdateStatus1("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination1 = "") {
                                                UpdateStatus1("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence1 := StrSplit(KeyCombination1, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning1 := true
                                            GuiControl,, StartStop1, Stop1
                                            UpdateStatus1("Running: " . KeyCombination1)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys1

                                            NextExecutionTime1 := A_TickCount + (TimerInterval1 * 60 * 1000)

                                        }

                                        ; Start Sequence 2 if configured
                                        if (KeyCombination2 && !IsRunning2 ) {
                                            if (win1 = "") {
                                                UpdateStatus2("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination2 = "") {
                                                UpdateStatus2("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence2 := StrSplit(KeyCombination2, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning2 := true
                                            GuiControl,, StartStop2, Stop2
                                            UpdateStatus2("Running: " . KeyCombination2)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys2

                                            NextExecutionTime2 := A_TickCount + (TimerInterval2 * 60 * 1000)
                                        }

                                        ; Start Sequence 3 if configured
                                        if (KeyCombination3 && !IsRunning3) {
                                            if (win1 = "") {
                                                UpdateStatus3("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination3 = "") {
                                                UpdateStatus3("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence3 := StrSplit(KeyCombination3, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning3 := true
                                            GuiControl,, StartStop3, Stop3
                                            UpdateStatus3("Running: " . KeyCombination3)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys3

                                            NextExecutionTime3 := A_TickCount + (TimerInterval3 * 60 * 1000)
                                        }

                                        ; Activate Gnoll buff AFTER Sequence 3 (wait 35 seconds) if requested
                                        if (activatePetBuffs && !gnollbuff) {
                                            ToolTip, Waiting 35 seconds before Gnoll buff..., 10, 10, 4
                                            Sleep, 35000
                                            ToolTip,,,,4

                                            gnollbuff := true
                                            GuiControl,, gnollbuff, 1
                                            gnoll()
                                            SetTimer, gnoll, %gnollBuffInterval%
                                            ToolTip, Gnoll buff activated!, 10, 10, 4
                                            Sleep, 2000
                                            ToolTip,,,,4
                                        }

                                        ; Show completion message
                                        ToolTip, All configured timers started!, 10, 10, 4
                                        SetTimer, RemoveStartAllTooltip, -2000
                                    return

                                    RemoveStartAllTooltip:
                                        ToolTip,,,,4
                                    return

                                    ; Function to start all buff timers (called via network command)
                                    ; This mimics StartAllTimers but without the MsgBox prompt
                                    StartAllBuffTimers() {
                                        global win1, KeyCombination1, KeyDelay1, TimerInterval1
                                        global KeyCombination2, KeyDelay2, TimerInterval2
                                        global KeyCombination3, KeyDelay3, TimerInterval3
                                        global IsRunning1, IsRunning2, IsRunning3
                                        global KeySequence1, KeySequence2, KeySequence3
                                        global NextExecutionTime1, NextExecutionTime2, NextExecutionTime3
                                        global SkipInitial1, dtbuff, gnollbuff, gnollBuffInterval

                                        ; Validate that window is selected
                                        if (win1 = "") {
                                            return
                                        }

                                        ; Auto-activate DT buff (no prompt)
                                        if (!dtbuff) {
                                            dtbuff := true
                                            GuiControl,, dtbuff, 1
                                            deathtyrant()
                                            SetTimer, deathtyrant, 3000000
                                        }

                                        ; Start Sequence 1 if configured and not already running
                                        if (KeyCombination1 && !IsRunning1) {
                                            KeySequence1 := StrSplit(KeyCombination1, "|")
                                            SetTimer, CheckExecutions, 50
                                            IsRunning1 := true
                                            GuiControl,, StartStop1, Stop1
                                            UpdateStatus1("Running: " . KeyCombination1)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys1
                                            NextExecutionTime1 := A_TickCount + (TimerInterval1 * 60 * 1000)
                                        }

                                        ; Start Sequence 2 if configured and not already running
                                        if (KeyCombination2 && !IsRunning2) {
                                            KeySequence2 := StrSplit(KeyCombination2, "|")
                                            SetTimer, CheckExecutions, 50
                                            IsRunning2 := true
                                            GuiControl,, StartStop2, Stop2
                                            UpdateStatus2("Running: " . KeyCombination2)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys2
                                            NextExecutionTime2 := A_TickCount + (TimerInterval2 * 60 * 1000)
                                        }

                                        ; Start Sequence 3 if configured and not already running
                                        if (KeyCombination3 && !IsRunning3) {
                                            KeySequence3 := StrSplit(KeyCombination3, "|")
                                            SetTimer, CheckExecutions, 50
                                            IsRunning3 := true
                                            GuiControl,, StartStop3, Stop3
                                            UpdateStatus3("Running: " . KeyCombination3)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys3
                                            NextExecutionTime3 := A_TickCount + (TimerInterval3 * 60 * 1000)
                                        }

                                        ; Auto-activate Gnoll buff after 35 seconds (no prompt)
                                        SetTimer, ActivateGnollBuffDelayed, -35000
                                    }

                                    ActivateGnollBuffDelayed:
                                        if (!gnollbuff) {
                                            gnollbuff := true
                                            GuiControl,, gnollbuff, 1
                                            gnoll()
                                            SetTimer, gnoll, %gnollBuffInterval%
                                        }
                                    return

                                    SendKeys1:
                                        ; Check if Critical mode is enabled - pause until disabled
                                        while (CriticalModeEnabled) {
                                            UpdateStatus1("Paused - Critical Mode active")
                                            Sleep, 1000
                                        }

                                        ; If navigation is running, set flag instead of executing
                                        if ((NavIsTraveling || IsTraveling) && !force) {
                                            sequence1Needed := true
                                            UpdateStatus2("Buffing queued for waypoint")
                                            return 
                                        }

                                        IfWinNotExist, ahk_id %win1%
                                        {
                                            UpdateStatus1("Window closed - stopping")
                                            IsRunning1 := false
                                            GuiControl,, StartStop1, Start1
                                            GuiControl,, CountdownText1, Next: --
                                            return
                                        }

                                        ; Keypresser has lowest priority - yield to healing and DPS
                                        if (isSystemBusy) {
                                            ; Delay execution by 1 second if system is busy
                                            NextExecutionTime1 := A_TickCount + 1000
                                            UpdateStatus1("Delayed - DPS/Healing active")
                                            return
                                        }

                                        ; Set system busy for buff sequence
                                        isSystemBusy := true
                                        IF (NavIsTraveling)
                                        {
                                            PauseNavigationForBuff()
                                        }
                                        Loop % KeySequence1.Length()
                                        {
                                            CurrentKey := KeySequence1[A_Index]
                                            if (CurrentKey != "") {
                                                ; Check for modifier keys and handle them separately
                                                hasCtrl := InStr(CurrentKey, "^")
                                                hasAlt := InStr(CurrentKey, "!")
                                                hasShift := InStr(CurrentKey, "+")

                                                ; Extract the base key (remove modifiers)
                                                baseKey := CurrentKey
                                                if (hasCtrl)
                                                    baseKey := StrReplace(baseKey, "^", "")
                                                if (hasAlt)
                                                    baseKey := StrReplace(baseKey, "!", "")
                                                if (hasShift)
                                                    baseKey := StrReplace(baseKey, "+", "")

                                                ; Apply QWERTZ conversion if enabled
                                                baseKey := ConvertQwertyToQwertz(baseKey)

                                                ; Send modifier keys down
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl down}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt down}, ahk_id %win1%
                                                if (hasShift)
                                                    ControlSend, , {Shift down}, ahk_id %win1%

                                                ; Send the base key
                                                ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                Sleep, 50
                                                ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                ; Send modifier keys up (in reverse order)
                                                if (hasShift)
                                                    ControlSend, , {Shift up}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt up}, ahk_id %win1%
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl up}, ahk_id %win1%

                                                if (KeyDelay1 > 0 && A_Index < KeySequence1.Length()) {
                                                    DelayMS1 := KeyDelay1 * 1000
                                                    Sleep, %DelayMS1%
                                                }
                                            }
                                        }

                                        ; Release system busy flag
                                        isSystemBusy := false

                                        NextExecutionTime1 := A_TickCount + (TimerInterval1 * 60 * 1000)
                                        UpdateStatus1("Buffs executed - yielding to DPS/Heal")
                                        ; Resume navigation after sequence execution
                                        if (NavigationPausedForBuff) {
                                            ResumeNavigationAfterBuff()
                                        }
                                    return
                                    SendKeys2:
                                        ; Check if Critical mode is enabled - pause until disabled
                                        while (CriticalModeEnabled) {
                                            UpdateStatus2("Paused - Critical Mode active")
                                            Sleep, 1000
                                        }

                                        ; If navigation is running, set flag instead of executing
                                        if ((NavIsTraveling || IsTraveling) && !force) {
                                            sequence2Needed := true
                                            UpdateStatus2("Buffing queued for waypoint")
                                            return
                                        }

                                        IfWinNotExist, ahk_id %win1%
                                        {
                                            UpdateStatus2("Window closed - stopping")
                                            IsRunning2 := false
                                            GuiControl,, StartStop2, Start2
                                            GuiControl,, CountdownText2, Next: --
                                            return
                                        }

                                        ; Keypresser has lowest priority - yield to healing and DPS
                                        if (isSystemBusy) {
                                            ; Delay execution by 1 second if system is busy
                                            NextExecutionTime2 := A_TickCount + 1000
                                            UpdateStatus2("Delayed - DPS/Healing active")
                                            return
                                        }

                                        ; Set system busy for buff sequence
                                        isSystemBusy := true
                                        IF (NavIsTraveling)
                                        {
                                            PauseNavigationForBuff()
                                        }
                                        Loop % KeySequence2.Length()
                                        {
                                            CurrentKey := KeySequence2[A_Index]
                                            if (CurrentKey != "") {
                                                ; Check for modifier keys and handle them separately
                                                hasCtrl := InStr(CurrentKey, "^")
                                                hasAlt := InStr(CurrentKey, "!")
                                                hasShift := InStr(CurrentKey, "+")

                                                ; Extract the base key (remove modifiers)
                                                baseKey := CurrentKey
                                                if (hasCtrl)
                                                    baseKey := StrReplace(baseKey, "^", "")
                                                if (hasAlt)
                                                    baseKey := StrReplace(baseKey, "!", "")
                                                if (hasShift)
                                                    baseKey := StrReplace(baseKey, "+", "")

                                                ; Send modifier keys down
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl down}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt down}, ahk_id %win1%
                                                if (hasShift)
                                                    ControlSend, , {Shift down}, ahk_id %win1%

                                                ; Send the base key
                                                ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                Sleep, 50
                                                ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                ; Send modifier keys up (in reverse order)
                                                if (hasShift)
                                                    ControlSend, , {Shift up}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt up}, ahk_id %win1%
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl up}, ahk_id %win1%

                                                if (KeyDelay2 > 0 && A_Index < KeySequence2.Length()) {
                                                    DelayMS2 := KeyDelay2 * 1000
                                                    Sleep, %DelayMS2%
                                                }
                                            }
                                        }

                                        ; Release system busy flag
                                        isSystemBusy := false

                                        NextExecutionTime2 := A_TickCount + (TimerInterval2 * 60 * 1000)
                                        UpdateStatus2("Buffs executed - yielding to DPS/Heal")
                                        if (NavigationPausedForBuff) {
                                            ResumeNavigationAfterBuff()
                                        }
                                    return

                                    SendKeys3:
                                        ; Check if Critical mode is enabled - pause until disabled
                                        while (CriticalModeEnabled) {
                                            UpdateStatus3("Paused - Critical Mode active")
                                            Sleep, 1000
                                        }

                                        ; If navigation is running, set flag instead of executing
                                        if ((NavIsTraveling || IsTraveling) && !force) {
                                            sequence3Needed := true
                                            UpdateStatus3("Buffing queued for waypoint")
                                            return
                                        }

                                        IfWinNotExist, ahk_id %win1%
                                        {
                                            UpdateStatus3("Window closed - stopping")
                                            IsRunning3 := false
                                            GuiControl,, StartStop3, Start3
                                            GuiControl,, CountdownText3, Next: --
                                            return
                                        }

                                        ; Keypresser has lowest priority - yield to healing and DPS
                                        if (isSystemBusy) {
                                            ; Delay execution by 1 second if system is busy
                                            NextExecutionTime3 := A_TickCount + 1000
                                            UpdateStatus3("Delayed - DPS/Healing active")
                                            return
                                        }

                                        ; Set system busy for buff sequence
                                        isSystemBusy := true

                                        IF (NavIsTraveling)
                                        {
                                            PauseNavigationForBuff()
                                        }
                                        Loop % KeySequence3.Length()
                                        {
                                            CurrentKey := KeySequence3[A_Index]
                                            if (CurrentKey != "") {
                                                ; Check for modifier keys and handle them separately
                                                hasCtrl := InStr(CurrentKey, "^")
                                                hasAlt := InStr(CurrentKey, "!")
                                                hasShift := InStr(CurrentKey, "+")

                                                ; Extract the base key (remove modifiers)
                                                baseKey := CurrentKey
                                                if (hasCtrl)
                                                    baseKey := StrReplace(baseKey, "^", "")
                                                if (hasAlt)
                                                    baseKey := StrReplace(baseKey, "!", "")
                                                if (hasShift)
                                                    baseKey := StrReplace(baseKey, "+", "")

                                                ; Send modifier keys down
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl down}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt down}, ahk_id %win1%
                                                if (hasShift)
                                                    ControlSend, , {Shift down}, ahk_id %win1%

                                                ; Send the base key
                                                ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                Sleep, 50
                                                ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                ; Send modifier keys up (in reverse order)
                                                if (hasShift)
                                                    ControlSend, , {Shift up}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt up}, ahk_id %win1%
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl up}, ahk_id %win1%

                                                if (KeyDelay3 > 0 && A_Index < KeySequence3.Length()) {
                                                    DelayMS3 := KeyDelay3 * 1000
                                                    Sleep, %DelayMS3%
                                                }
                                            }
                                        }

                                        ; Release system busy flag
                                        isSystemBusy := false

                                        NextExecutionTime3 := A_TickCount + (TimerInterval3 * 60 * 1000)
                                        UpdateStatus3("Buffs executed - yielding to DPS/Heal")
                                        if (NavigationPausedForBuff) {
                                            ResumeNavigationAfterBuff()
                                        }
                                    return

                                    CheckExecutions:
                                        ; Check if Critical mode is enabled - pause execution timers
                                        if (CriticalModeEnabled) {
                                            return
                                        }
                                        CurrentTime := A_TickCount

                                        if (IsRunning1 && CurrentTime >= NextExecutionTime1) {
                                            Gosub, SendKeys1
                                        }

                                        if (IsRunning2 && CurrentTime >= NextExecutionTime2) {
                                            Gosub, SendKeys2
                                        }

                                        if (IsRunning3 && CurrentTime >= NextExecutionTime3) {
                                            Gosub, SendKeys3
                                        }

                                        if (IsRunning1) {
                                            TimeRemaining := NextExecutionTime1 - CurrentTime
                                            if (TimeRemaining <= 0) {
                                                MinutesLeft := 0
                                            } else {
                                                MinutesLeft := Round(TimeRemaining / 60000, 2)
                                            }
                                            GuiControl,, CountdownText1, Next: %MinutesLeft%m
                                        }

                                        if (IsRunning2) {
                                            TimeRemaining := NextExecutionTime2 - CurrentTime
                                            if (TimeRemaining <= 0) {
                                                MinutesLeft := 0
                                            } else {
                                                MinutesLeft := Round(TimeRemaining / 60000, 2)
                                            }
                                            GuiControl,, CountdownText2, Next: %MinutesLeft%m
                                        }

                                        if (IsRunning3) {
                                            TimeRemaining := NextExecutionTime3 - CurrentTime
                                            if (TimeRemaining <= 0) {
                                                MinutesLeft := 0
                                            } else {
                                                MinutesLeft := Round(TimeRemaining / 60000, 2)
                                            }
                                            GuiControl,, CountdownText3, Next: %MinutesLeft%m
                                        }

                                        if (!IsRunning1 && !IsRunning2 && !IsRunning3) {
                                            SetTimer, CheckExecutions, Off
                                        }
                                    return

                                    SaveKeypresserSettings:
                                        Gui, Submit, NoHide

                                        KeyCombination1 := KeyCombinationEdit1
                                        KeyDelay1 := KeyDelayEdit1
                                        TimerInterval1 := TimerIntervalEdit1
                                        KeyCombination2 := KeyCombinationEdit2
                                        KeyDelay2 := KeyDelayEdit2
                                        TimerInterval2 := TimerIntervalEdit2
                                        KeyCombination3 := KeyCombinationEdit3
                                        KeyDelay3 := KeyDelayEdit3
                                        TimerInterval3 := TimerIntervalEdit3

                                        FileEncoding, UTF-8

                                        IniWrite, %win1%, %SettingsFile%, Settings, win1

                                        IniWrite, %KeyCombination1%, %SettingsFile%, Sequence1, KeyCombination
                                        IniWrite, %KeyDelay1%, %SettingsFile%, Sequence1, KeyDelay
                                        IniWrite, %TimerInterval1%, %SettingsFile%, Sequence1, TimerInterval

                                        IniWrite, %KeyCombination2%, %SettingsFile%, Sequence2, KeyCombination
                                        IniWrite, %KeyDelay2%, %SettingsFile%, Sequence2, KeyDelay
                                        IniWrite, %TimerInterval2%, %SettingsFile%, Sequence2, TimerInterval

                                        IniWrite, %KeyCombination3%, %SettingsFile%, Sequence3, KeyCombination
                                        IniWrite, %KeyDelay3%, %SettingsFile%, Sequence3, KeyDelay
                                        IniWrite, %TimerInterval3%, %SettingsFile%, Sequence3, TimerInterval
                                        FileEncoding

                                        UpdateStatus1("Settings saved")
                                        UpdateStatus2("Settings saved")
                                        UpdateStatus3("Settings saved")
                                    return

                                    LoadKeypresserSettings:

                                        IniRead, win1, %SettingsFile%, Settings, win1, %A_Space%

                                        IniRead, KeyCombination1, %SettingsFile%, Sequence1, KeyCombination, %A_Space%
                                        IniRead, KeyDelay1, %SettingsFile%, Sequence1, KeyDelay, 0.1
                                        IniRead, TimerInterval1, %SettingsFile%, Sequence1, TimerInterval, 1

                                        IniRead, KeyCombination2, %SettingsFile%, Sequence2, KeyCombination, %A_Space%
                                        IniRead, KeyDelay2, %SettingsFile%, Sequence2, KeyDelay, 0.1
                                        IniRead, TimerInterval2, %SettingsFile%, Sequence2, TimerInterval, 2

                                        IniRead, KeyCombination3, %SettingsFile%, Sequence3, KeyCombination, %A_Space%
                                        IniRead, KeyDelay3, %SettingsFile%, Sequence3, KeyDelay, 0.1
                                        IniRead, TimerInterval3, %SettingsFile%, Sequence3, TimerInterval, 3

                                        ; Add these lines in LoadKeypresserSettings label
                                        IniRead, KeyCombination4, %SettingsFile%, Sequence4, KeyCombination, %A_Space%
                                        IniRead, KeyDelay4, %SettingsFile%, Sequence4, KeyDelay, 0.1
                                        IniRead, TimerInterval4, %SettingsFile%, Sequence4, TimerInterval, 4
                                        KeySequence4 := StrSplit(KeyCombination4, "|")

                                        IniRead, KeyCombination5, %SettingsFile%, Sequence5, KeyCombination, %A_Space%
                                        IniRead, KeyDelay5, %SettingsFile%, Sequence5, KeyDelay, 0.1
                                        IniRead, TimerInterval5, %SettingsFile%, Sequence5, TimerInterval, 5
                                        KeySequence5 := StrSplit(KeyCombination5, "|")

                                        IniRead, KeyCombination6, %SettingsFile%, Sequence6, KeyCombination, %A_Space%
                                        IniRead, KeyDelay6, %SettingsFile%, Sequence6, KeyDelay, 0.1
                                        IniRead, TimerInterval6, %SettingsFile%, Sequence6, TimerInterval, 6
                                        KeySequence6 := StrSplit(KeyCombination6, "|")

                                        if (win1 = "ERROR")
                                            win1 := ""
                                        if (KeyCombination1 = "ERROR")
                                            KeyCombination1 := ""
                                        if (KeyCombination2 = "ERROR")
                                            KeyCombination2 := ""
                                        if (KeyCombination3 = "ERROR")
                                            KeyCombination3 := ""
                                        if (KeyCombination4 = "ERROR")
                                            KeyCombination4 := ""
                                        if (KeyCombination5 = "ERROR")
                                            KeyCombination5 := ""
                                        if (KeyCombination6 = "ERROR")
                                            KeyCombination6 := ""

                                        GuiControl,, KeyCombinationEdit1, %KeyCombination1%
                                        GuiControl,, KeyDelayEdit1, %KeyDelay1%
                                        GuiControl,, TimerIntervalEdit1, %TimerInterval1%
                                        GuiControl,, KeyCombinationEdit2, %KeyCombination2%
                                        GuiControl,, KeyDelayEdit2, %KeyDelay2%
                                        GuiControl,, TimerIntervalEdit2, %TimerInterval2%
                                        GuiControl,, KeyCombinationEdit3, %KeyCombination3%
                                        GuiControl,, KeyDelayEdit3, %KeyDelay3%
                                        GuiControl,, TimerIntervalEdit3, %TimerInterval3%
                                        GuiControl,, KeyCombinationEdit4, %KeyCombination4%
                                        GuiControl,, KeyDelayEdit4, %KeyDelay4%
                                        GuiControl,, TimerIntervalEdit4, %TimerInterval4%
                                        GuiControl,, KeyCombinationEdit5, %KeyCombination5%
                                        GuiControl,, KeyDelayEdit5, %KeyDelay5%
                                        GuiControl,, TimerIntervalEdit5, %TimerInterval5%
                                        GuiControl,, KeyCombinationEdit6, %KeyCombination6%
                                        GuiControl,, KeyDelayEdit6, %KeyDelay6%
                                        GuiControl,, TimerIntervalEdit6, %TimerInterval6%
                                        UpdateStatus1("Settings loaded")
                                        UpdateStatus2("Settings loaded")
                                        UpdateStatus3("Settings loaded")
                                    return

                                    LoadPetBuffImageSettings:
                                        ; Load pet buff image patterns
                                        IniRead, gnollBuffImagePattern, %SettingsFile%, PetBuffImages, GnollBuffPattern, %A_Space%
                                        IniRead, dtBuffImagePattern, %SettingsFile%, PetBuffImages, DTBuffPattern, %A_Space%
                                        IniRead, customSummonPattern, %SettingsFile%, PetBuffImages, SummonPattern, %A_Space%
                                        IniRead, summonKeybind, %SettingsFile%, PetBuffImages, SummonKeybind, +=

                                        ; Handle ERROR values
                                        if (gnollBuffImagePattern = "ERROR")
                                            gnollBuffImagePattern := ""
                                        if (dtBuffImagePattern = "ERROR")
                                            dtBuffImagePattern := ""
                                        if (customSummonPattern = "ERROR")
                                            customSummonPattern := ""
                                        if (summonKeybind = "ERROR")
                                            summonKeybind := "+="
                                    return

                                    UpdateStatus1(Message) {
                                        GuiControl,, StatusText1, %Message%
                                    }

                                    UpdateStatus2(Message) {
                                        GuiControl,, StatusText2, %Message%
                                    }

                                    UpdateStatus3(Message) {
                                        GuiControl,, StatusText3, %Message%
                                    }

                                    ; ========= HEAL PRIORITY FUNCTIONS =========

                                    HealPrioritySelect:
                                    return

                                    MoveHealUp:
                                        ; Get the currently selected item index from the ListBox
                                        GuiControlGet, selectedText, , HealPriorityList
                                        selectedIndex := 0

                                        ; Parse the index from the text (format: "1. SkillName")
                                        if (selectedText != "") {
                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                            selectedIndex := match1
                                        }

                                        ; Debug info
                                        UpdateHealerStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . healPriorities.Length())

                                        if (selectedIndex <= 1 || selectedIndex > healPriorities.Length()) {
                                            UpdateHealerStatus("Cannot move item up. Select an item first or item is already at top.")
                                            return
                                        }

                                        ; Swap with previous item
                                        temp := healPriorities[selectedIndex]
                                        healPriorities[selectedIndex] := healPriorities[selectedIndex - 1]
                                        healPriorities[selectedIndex - 1] := temp

                                        SaveHealPriorities()
                                        RefreshHealPriorityList()

                                        ; Reselect the moved item
                                        GuiControl, Choose, HealPriorityList, % selectedIndex - 1

                                        UpdateHealerStatus("Moved heal skill up in priority.")
                                    return

                                    MoveHealDown:
                                        ; Get the currently selected item index from the ListBox
                                        GuiControlGet, selectedText, , HealPriorityList
                                        selectedIndex := 0

                                        ; Parse the index from the text (format: "1. SkillName")
                                        if (selectedText != "") {
                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                            selectedIndex := match1
                                        }

                                        ; Debug info
                                        UpdateHealerStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . healPriorities.Length())

                                        if (selectedIndex <= 0 || selectedIndex >= healPriorities.Length()) {
                                            UpdateHealerStatus("Cannot move item down. Select an item first or item is already at bottom.")
                                            return
                                        }

                                        ; Swap with next item
                                        temp := healPriorities[selectedIndex]
                                        healPriorities[selectedIndex] := healPriorities[selectedIndex + 1]
                                        healPriorities[selectedIndex + 1] := temp

                                        SaveHealPriorities()
                                        RefreshHealPriorityList()

                                        ; Reselect the moved item
                                        GuiControl, Choose, HealPriorityList, % selectedIndex + 1

                                        UpdateHealerStatus("Moved heal skill down in priority.")
                                    return

                                    RefreshHealList:
                                        RefreshHealPriorityList()
                                        UpdateHealerStatus("Heal priority list refreshed.")
                                    return

                                    RemoveFromHealPriority:
                                        ; Get the currently selected item index from the ListBox
                                        GuiControlGet, selectedText, , HealPriorityList
                                        selectedIndex := 0

                                        ; Parse the index from the text (format: "1. SkillName")
                                        if (selectedText != "") {
                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                            selectedIndex := match1
                                        }

                                        if (selectedIndex <= 0 || selectedIndex > healPriorities.Length()) {
                                            UpdateHealerStatus("Select a heal skill to remove from priority.")
                                            return
                                        }

                                        removedSkill := healPriorities[selectedIndex]
                                        displayName := GetDisplayName(removedSkill)
                                        healPriorities.RemoveAt(selectedIndex)

                                        SaveHealPriorities()
                                        RefreshHealPriorityList()
                                        UpdateHealerStatus("Removed '" . displayName . "' from heal priority order (skill still saved).")
                                    return

                                    AddToHealPriority:
                                        ; Show available heal skills not in priority
                                        availableHeals := "=== ADD HEAL TO PRIORITY ===`n`n"
                                        availableCount := 0
                                        availableSkills := []

                                        for patternName, patternText in patterns {
                                            if (SubStr(patternName, 1, 4) = "heal") {
                                                ; Check if already in priority
                                                inPriority := false
                                                for index, priorityPattern in healPriorities {
                                                    if (priorityPattern = patternName) {
                                                        inPriority := true
                                                        break
                                                    }
                                                }

                                                if (!inPriority) {
                                                    availableCount++
                                                    availableSkills.Push(patternName)
                                                    displayName := GetDisplayName(patternName)
                                                    availableHeals .= availableCount . ". " . displayName . " [" . patternName . "]`n"
                                                }
                                            }
                                        }

                                        if (availableCount = 0) {
                                            UpdateHealerStatus("No heal skills available to add (all are already in priority or none saved).")
                                            return
                                        }

                                        availableHeals .= "`nEnter the number of the heal to add to priority:"

                                        InputBox, healNumber, Add Heal to Priority, %availableHeals%, , 400, 300
                                        if (ErrorLevel)
                                            return

                                        if (healNumber < 1 || healNumber > availableCount) {
                                            UpdateHealerStatus("Invalid heal number selected.")
                                            return
                                        }

                                        selectedSkill := availableSkills[healNumber]
                                        displayName := GetDisplayName(selectedSkill)

                                        ; Add to end of priority list
                                        healPriorities.Push(selectedSkill)
                                        SaveHealPriorities()
                                        RefreshHealPriorityList()
                                        UpdateHealerStatus("Added '" . displayName . "' to heal priority order.")
                                    return

                                    RefreshHealPriorityList() {
                                        global patterns, patternKeys, healPriorities
                                        global healGroundTargetSkills, healPressKeyBeforeCast

                                        ; Clear the listbox
                                        GuiControl,, HealPriorityList, |

                                        ; Add items in priority order
                                        itemCount := 0
                                        for index, priorityPattern in healPriorities {
                                            if (patterns.HasKey(priorityPattern) && SubStr(priorityPattern, 1, 4) = "heal") {
                                                itemCount++
                                                displayName := GetDisplayName(priorityPattern)
                                                keyInfo := patternKeys.HasKey(priorityPattern) && patternKeys[priorityPattern] != "" ? " (Key: " . patternKeys[priorityPattern] . ")" : " (Click)"

                                                    ; Add modifier indicators - check for true/1/"true"
                                                    modifiers := ""
                                                    hasGroundTarget := healGroundTargetSkills.HasKey(priorityPattern) && (healGroundTargetSkills[priorityPattern] = true || healGroundTargetSkills[priorityPattern] = 1 || healGroundTargetSkills[priorityPattern] = "true" || healGroundTargetSkills[priorityPattern] = "1")
                                                    hasPreCast := healPressKeyBeforeCast.HasKey(priorityPattern) && (healPressKeyBeforeCast[priorityPattern] = true || healPressKeyBeforeCast[priorityPattern] = 1 || healPressKeyBeforeCast[priorityPattern] = "true" || healPressKeyBeforeCast[priorityPattern] = "1")

                                                    if (hasGroundTarget && hasPreCast)
                                                        modifiers := " [CB]"
                                                    else if (hasGroundTarget)
                                                        modifiers := " [C]"
                                                    else if (hasPreCast)
                                                        modifiers := " [B]"

                                                    listItem := index . ". " . displayName . keyInfo . modifiers
                                                    GuiControl,, HealPriorityList, %listItem%
                                                }
                                            }

                                            ; Show count for debugging
                                            if (itemCount = 0 && healPriorities.Length() > 0) {
                                                UpdateHealerStatus("Warning: " . healPriorities.Length() . " priorities but 0 valid patterns found")
                                            }
                                        }

                                        SaveHealPriorities() {
                                            global iniFile, healPriorities

                                            ; Convert array to comma-separated string
                                            priorityString := ""
                                            for index, priorityPattern in healPriorities {
                                                if (index > 1)
                                                    priorityString .= ","
                                                priorityString .= priorityPattern
                                            }

                                            FileEncoding, UTF-8
                                            IniWrite, %priorityString%, %iniFile%, HealPriorities, Order
                                            FileEncoding
                                        }

                                        LoadHealPriorities() {
                                            global iniFile, healPriorities

                                            IniRead, priorityString, %iniFile%, HealPriorities, Order, %A_Space%
                                            if (priorityString != "" && priorityString != "ERROR") {
                                                healPriorities := StrSplit(priorityString, ",")
                                            }
                                        }

                                        SaveHealSettings() {
                                            global iniFile, healCheckInterval, healThresholdPercent

                                            FileEncoding, UTF-8
                                            IniWrite, %healCheckInterval%, %iniFile%, HealSettings, CheckInterval
                                            IniWrite, %healThresholdPercent%, %iniFile%, HealSettings, ThresholdPercent
                                            FileEncoding
                                        }

                                        LoadHealSettings() {
                                            global iniFile, healCheckInterval, healThresholdPercent

                                            IniRead, loadedInterval, %iniFile%, HealSettings, CheckInterval, 1000
                                            if (loadedInterval >= 25 && loadedInterval <= 10000) {
                                                healCheckInterval := loadedInterval
                                                GuiControl,, HealIntervalInput, %healCheckInterval%
                                            }

                                            IniRead, loadedThreshold, %iniFile%, HealSettings, ThresholdPercent, 95
                                            if (loadedThreshold >= 1 && loadedThreshold <= 100) {
                                                healThresholdPercent := loadedThreshold
                                                GuiControl,, HealThresholdInput, %healThresholdPercent%
                                            }
                                        }

                                        ; ========= DPS FUNCTIONS =========

                                        AddDPSSkill:
                                            UpdateDPSStatus("Press 1 when the skill to capture is visable on screen.")
                                            KeyWait, 1, D
                                            capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)
                                            Clipboard := capturedText
                                            patternName := "dps" . dpsCounter

                                            ; Prompt for custom name and key assignment
                                            InputBox, customName, Name DPS Skill, Enter a name for this DPS skill:, , 300, 130, , , , , %patternName%
                                                if (ErrorLevel)
                                                return

                                            if (customName = "")
                                                customName := patternName

                                            ; Ask if need to press key before cast
                                            MsgBox, 4, Press Key Before Cast?, Do you need to press a DIFFERENT key BEFORE the main skill key?`n`n(Example: Press Tab to swap weapon bar, then press the skill key)
                                            IfMsgBox, Yes
                                            {
                                                needsPreCastKey := true
                                                InputBox, preCastKey, Pre-Cast Key, Enter the key to press BEFORE the main skill key (e.g. Tab):, , 350, 150
                                                if (ErrorLevel)
                                                    preCastKey := ""
                                            }
                                            IfMsgBox, No
                                            {
                                                needsPreCastKey := false
                                                preCastKey := ""
                                            }

                                            InputBox, assignedKey, Assign Main Skill Key, Enter the MAIN key that casts this skill (e.g. 6):`n`nLeave empty to click with mouse., , 350, 150
                                            if (ErrorLevel)
                                                return

                                            ; Ask if ground-targeted skill
                                            MsgBox, 4, Ground Target Skill?, Is this a ground-targeted skill that requires clicking a location AFTER the key is pressed?
                                            IfMsgBox, Yes
                                            {
                                                isGroundTarget := true
                                                MsgBox, 0, Right-Click to Set Location, Right-click on the location where the skill should be cast.`n`nPress OK first, then right-click the location.
                                                UpdateDPSStatus("Waiting for right-click to set ground target location...")
                                                KeyWait, RButton, D
                                                MouseGetPos, groundX, groundY
                                                ; Convert screen coords to window-relative coords for saving
                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                groundX := groundX - winX
                                                groundY := groundY - winY
                                                UpdateDPSStatus("Ground target location set (relative): " . groundX . ", " . groundY)
                                            }
                                            IfMsgBox, No
                                            {
                                                isGroundTarget := false
                                                groundX := ""
                                                groundY := ""
                                            }

                                            SaveDPSPattern(patternName, capturedText, assignedKey, customName, isGroundTarget, groundX, groundY, needsPreCastKey, preCastKey)
                                            UpdateDPSStatus("DPS skill captured and saved as '" . customName . "' [" . patternName . "]")
                                            UpdateDPSStatus("DEBUG SAVE: PreCast enabled=" . needsPreCastKey . ", PreCast key=" . preCastKey . ", Ground=" . isGroundTarget)
                                            dpsCounter++

                                            ; Add to priority list at the end
                                            dpsPriorities.Push(patternName)
                                            SaveDPSPriorities()
                                            RefreshDPSPriorityList()
                                        return

                                        TestDPSSkills:
                                            if (dpsPatterns.Count() = 0) {
                                                UpdateDPSStatus("No DPS skills captured. Add some skills first.")
                                                return
                                            }

                                            UpdateDPSStatus("Testing DPS skills - searching for patterns on screen...")

                                            foundCount := 0
                                            totalCount := 0

                                            ; Test each DPS pattern
                                            for patternName, patternText in dpsPatterns {
                                                totalCount++
                                                displayName := GetDPSDisplayName(patternName)

                                                ; Search in the skill bar area - convert window-relative to screen coordinates
                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                screenX1 := winX + SkillBarX1
                                                screenY1 := winY + SkillBarY1
                                                screenX2 := winX + SkillBarX2
                                                screenY2 := winY + SkillBarY2
                                                if (ok := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)) {
                                                    foundCount++
                                                    UpdateDPSStatus("✓ FOUND: " . displayName . " at coordinates: " . X . ", " . Y)

                                                    ; Highlight the found skill
                                                    Try {
                                                        For i, v in ok {
                                                            if (i <= 2)
                                                                FindText().MouseTip(ok[i].x, ok[i].y)
                                                        }
                                                    }
                                                } else {
                                                    UpdateDPSStatus("✗ Not found: " . displayName)
                                                }
                                            }

                                            UpdateDPSStatus("Test complete - Found " . foundCount . " out of " . totalCount . " DPS skills on screen.")
                                        return

                                        ClearDPSSkills:
                                            InputBox, patternToClear, Clear DPS Pattern, Enter the name of the DPS pattern to clear (leave empty to clear all):, , 300, 130
                                            if (ErrorLevel)
                                                return

                                            if (patternToClear = "") {
                                                dpsPatterns := {}
                                                dpsPatternKeys := {}
                                                dpsPatternNames := {}
                                                dpsPriorities := []
                                                IniDelete, %iniFile%, DPSPatterns
                                                IniDelete, %iniFile%, DPSPatternKeys
                                                IniDelete, %iniFile%, DPSPatternNames
                                                IniDelete, %iniFile%, DPSPriorities
                                                dpsCounter := 1
                                                RefreshDPSPriorityList()
                                                UpdateDPSStatus("All DPS patterns have been cleared.")
                                            } else {
                                                ; Check both pattern name and custom name
                                                patternToDelete := ""
                                                for dpsPat, dpsText in dpsPatterns {
                                                    displayName := GetDPSDisplayName(dpsPat)
                                                    if (dpsPat = patternToClear || displayName = patternToClear) {
                                                        patternToDelete := dpsPat
                                                        break
                                                    }
                                                }

                                                if (patternToDelete != "") {
                                                    dpsPatterns.Delete(patternToDelete)
                                                    dpsPatternKeys.Delete(patternToDelete)
                                                    dpsPatternNames.Delete(patternToDelete)

                                                    ; Remove from priority list
                                                    for index, priorityPattern in dpsPriorities {
                                                        if (priorityPattern = patternToDelete) {
                                                            dpsPriorities.RemoveAt(index)
                                                            break
                                                        }
                                                    }

                                                    IniDelete, %iniFile%, DPSPatterns, %patternToDelete%
                                                    IniDelete, %iniFile%, DPSPatternKeys, %patternToDelete%
                                                    IniDelete, %iniFile%, DPSPatternNames, %patternToDelete%
                                                    SaveDPSPriorities()
                                                    RefreshDPSPriorityList()
                                                    UpdateDPSStatus("DPS pattern '" . patternToClear . "' has been cleared.")
                                                } else {
                                                    UpdateDPSStatus("DPS pattern '" . patternToClear . "' not found.")
                                                }
                                            }
                                        return

                                        AssignDPSKeys:
                                            ; Show available DPS skills and let user assign keys
                                            dpsList := "=== ASSIGN KEYS TO DPS SKILLS ===`n`n"
                                            dpsCount := 0

                                            for patternName, patternText in dpsPatterns {
                                                dpsCount++
                                                displayName := GetDPSDisplayName(patternName)
                                                currentKey := dpsPatternKeys.HasKey(patternName) ? dpsPatternKeys[patternName] : "(none)"

                                                    dpsList .= dpsCount . ". " . displayName . " [" . patternName . "]`n"
                                                    dpsList .= " Current Key: " . currentKey . "`n`n"
                                                }

                                                if (dpsCount = 0) {
                                                    UpdateDPSStatus("No DPS skills to assign keys to. Capture some skills first.")
                                                return
                                            }

                                            dpsList .= "`nEnter the number of the DPS skill to assign a key to:"

                                            InputBox, dpsNumber, Assign DPS Key, %dpsList%, , 400, 300
                                            if (ErrorLevel)
                                                return

                                            ; Find the selected DPS skill
                                            currentIndex := 1
                                            selectedDPS := ""
                                            for patternName, patternText in dpsPatterns {
                                                if (currentIndex = dpsNumber) {
                                                    selectedDPS := patternName
                                                    break
                                                }
                                                currentIndex++
                                            }

                                            if (selectedDPS = "") {
                                                UpdateDPSStatus("Invalid DPS skill number selected.")
                                                return
                                            }

                                            ; Get key assignment
                                            selectedDisplayName := GetDPSDisplayName(selectedDPS)
                                            currentKey := dpsPatternKeys.HasKey(selectedDPS) ? dpsPatternKeys[selectedDPS] : ""
                                                keyPrompt := "=== ASSIGN KEY ===`n`nDPS Skill: " . selectedDisplayName . "`nID: " . selectedDPS . "`nCurrent Key: " . currentKey . "`n`nEnter new key (examples: 1, 2, F1, F2, etc.):"
                                                InputBox, newKey, Assign Key to DPS Skill, %keyPrompt%, , 400, 200, , , , , %currentKey%
                                                if (ErrorLevel)
                                                    return

                                                ; Save the assignment
                                                dpsPatternKeys[selectedDPS] := newKey
                                                SaveDPSPatternKey(selectedDPS, newKey)
                                                UpdateDPSStatus("Assigned key '" . newKey . "' to '" . selectedDisplayName . "' [" . selectedDPS . "] and saved to INI")
                                                RefreshDPSPriorityList()
                                            return

                                            RenameDPSSkills:
                                                if (dpsPatterns.Count() = 0) {
                                                    UpdateDPSStatus("No DPS skills to rename.")
                                                    return
                                                }

                                                ; Build skill list and selection array in one pass
                                                dpsList := "=== RENAME DPS SKILLS ===`n`n"
                                                skillArray := []

                                                for patternName, patternText in dpsPatterns {
                                                    skillArray.Push(patternName)
                                                    displayName := GetDPSDisplayName(patternName)
                                                    status := (displayName != patternName) ? "(Custom)" : "(Default)"
                                                        dpsList .= skillArray.Length() . ". " . displayName . " [" . patternName . "] " . status . "`n"
                                                    }

                                                    ; Create scrollable GUI instead of InputBox
                                                    Gui, RenameDPSSelect:New, +Resize, Rename DPS Skill
                                                    Gui, RenameDPSSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %dpsList%`n`nEnter skill number:
                                                    Gui, RenameDPSSelect:Add, Edit, x10 y340 w100 h20 vDPSNumberInput
                                                    Gui, RenameDPSSelect:Add, Button, x120 y340 w60 h20 gRenameDPSSelectOK, OK
                                                    Gui, RenameDPSSelect:Add, Button, x190 y340 w60 h20 gRenameDPSSelectCancel, Cancel
                                                    Gui, RenameDPSSelect:Show, w600 h380
                                                    return

                                                    RenameDPSSelectOK:
                                                        Gui, RenameDPSSelect:Submit
                                                        dpsNumber := DPSNumberInput
                                                        if (dpsNumber < 1 || dpsNumber > skillArray.Length()) {
                                                            UpdateDPSStatus("Invalid selection.")
                                                            return
                                                        }
                                                        Gui, RenameDPSSelect:Destroy

                                                        selectedDPS := skillArray[dpsNumber]
                                                        currentDisplayName := GetDPSDisplayName(selectedDPS)

                                                        InputBox, newName, Rename DPS Skill, Original: %selectedDPS%`nCurrent: %currentDisplayName%`n`nNew name:, , 400, 180, , , , , %currentDisplayName%
                                                        if (ErrorLevel || newName = "") {
                                                            if (!ErrorLevel) UpdateDPSStatus("Name cannot be empty.")
                                                                return
                                                        }

                                                        ; Update in-memory object directly
                                                        dpsPatternNames[selectedDPS] := newName
                                                        SaveDPSPatternName(selectedDPS, newName)
                                                        UpdateDPSStatus("Renamed '" . selectedDPS . "' to '" . newName . "'")

                                                        ; Force refresh with timer
                                                        SetTimer, ForceRefreshDPS, -50
                                                    return

                                                    RenameDPSSelectCancel:
                                                        Gui, RenameDPSSelect:Destroy
                                                    return

                                                    ModifyDPSSkill:
                                                        if (dpsPatterns.Count() = 0) {
                                                            UpdateDPSStatus("No DPS skills to modify.")
                                                            return
                                                        }

                                                        ; Build skill list with current modifier status
                                                        dpsList := "=== MODIFY DPS SKILL ===`n`n"
                                                        skillArray := []

                                                        for patternName, patternText in dpsPatterns {
                                                            skillArray.Push(patternName)
                                                            displayName := GetDPSDisplayName(patternName)

                                                            ; Show current modifier status
                                                            hasGroundTarget := dpsGroundTargetSkills.HasKey(patternName) && dpsGroundTargetSkills[patternName]
                                                            hasPreCast := dpsPressKeyBeforeCast.HasKey(patternName) && dpsPressKeyBeforeCast[patternName]

                                                            modStatus := ""
                                                            if (hasGroundTarget && hasPreCast)
                                                                modStatus := " [Click-After + Button-Before]"
                                                            else if (hasGroundTarget)
                                                                modStatus := " [Click-After]"
                                                            else if (hasPreCast)
                                                                modStatus := " [Button-Before]"
                                                            else
                                                                modStatus := " [No modifiers]"

                                                            dpsList .= skillArray.Length() . ". " . displayName . modStatus . "`n"
                                                        }

                                                        ; Create selection GUI
                                                        Gui, ModifyDPSSelect:New, +Resize, Modify DPS Skill
                                                        Gui, ModifyDPSSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %dpsList%`n`nEnter skill number to modify:
                                                        Gui, ModifyDPSSelect:Add, Edit, x10 y340 w100 h20 vModifyDPSNumberInput
                                                        Gui, ModifyDPSSelect:Add, Button, x120 y340 w60 h20 gModifyDPSSelectOK, OK
                                                        Gui, ModifyDPSSelect:Add, Button, x190 y340 w60 h20 gModifyDPSSelectCancel, Cancel
                                                        Gui, ModifyDPSSelect:Show, w600 h380
                                                    return

                                                    ModifyDPSSelectOK:
                                                        Gui, ModifyDPSSelect:Submit
                                                        dpsNumber := ModifyDPSNumberInput
                                                        if (dpsNumber < 1 || dpsNumber > skillArray.Length()) {
                                                            UpdateDPSStatus("Invalid selection.")
                                                            return
                                                        }
                                                        Gui, ModifyDPSSelect:Destroy

                                                        selectedDPS := skillArray[dpsNumber]
                                                        displayName := GetDPSDisplayName(selectedDPS)

                                                        ; Get current modifier states
                                                        currentGroundTarget := dpsGroundTargetSkills.HasKey(selectedDPS) && dpsGroundTargetSkills[selectedDPS]
                                                        currentPreCast := dpsPressKeyBeforeCast.HasKey(selectedDPS) && dpsPressKeyBeforeCast[selectedDPS]

                                                        ; Create modifier options GUI
                                                        Gui, ModifyDPSOptions:New, , Modify Skill: %displayName%
                                                        Gui, ModifyDPSOptions:Add, Text, x20 y20 w400, Select modifiers for: %displayName%
                                                        Gui, ModifyDPSOptions:Add, Checkbox, x20 y50 w400 vModifyDPSGroundTarget Checked%currentGroundTarget%, Click location AFTER skill cast (ground target)
                                                        Gui, ModifyDPSOptions:Add, Checkbox, x20 y80 w400 vModifyDPSPreCast Checked%currentPreCast%, Press button BEFORE skill cast
                                                        Gui, ModifyDPSOptions:Add, Button, x120 y120 w80 h30 gApplyDPSModifiers, Apply
                                                        Gui, ModifyDPSOptions:Add, Button, x220 y120 w80 h30 gCancelDPSModifiers, Cancel
                                                        Gui, ModifyDPSOptions:Show, w450 h170
                                                    return

                                                    ModifyDPSSelectCancel:
                                                        Gui, ModifyDPSSelect:Destroy
                                                    return

                                                    ApplyDPSModifiers:
                                                        Gui, ModifyDPSOptions:Submit

                                                        ; Handle ground target modification
                                                        if (ModifyDPSGroundTarget) {
                                                            ; If enabling ground target and it wasn't enabled before
                                                            if (!dpsGroundTargetSkills.HasKey(selectedDPS) || !dpsGroundTargetSkills[selectedDPS]) {
                                                                MsgBox, 0, Set Ground Target Location, Right-click on the location where the skill should be cast.`n`nPress OK first, then right-click the location.
                                                                UpdateDPSStatus("Waiting for right-click to set ground target location...")
                                                                KeyWait, RButton, D
                                                                MouseGetPos, groundX, groundY
                                                                ; Convert screen coords to window-relative coords for saving
                                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                                groundX := groundX - winX
                                                                groundY := groundY - winY

                                                                ; Save ground target settings
                                                                dpsGroundTargetSkills[selectedDPS] := true
                                                                coordString := groundX . "," . groundY
                                                                dpsGroundTargetCoords[selectedDPS] := {x: groundX, y: groundY}
                                                                FileEncoding, UTF-8
                                                                IniWrite, true, %iniFile%, DPSGroundTarget, %selectedDPS%
                                                                IniWrite, %coordString%, %iniFile%, DPSGroundCoords, %selectedDPS%
                                                                FileEncoding

                                                                ; Confirmation message
                                                                MsgBox, 64, Ground Target Set, Ground target location has been set successfully!`n`nRelative coordinates: %groundX%`, %groundY%
                                                            } else {
                                                                UpdateDPSStatus("Ground target already enabled for this skill - keeping existing location")
                                                            }
                                                        } else {
                                                            ; Remove ground target if unchecked
                                                            dpsGroundTargetSkills[selectedDPS] := false
                                                            dpsGroundTargetCoords.Delete(selectedDPS)
                                                            IniDelete, %iniFile%, DPSGroundTarget, %selectedDPS%
                                                            IniDelete, %iniFile%, DPSGroundCoords, %selectedDPS%
                                                        }

                                                        ; Handle pre-cast key modification
                                                        if (ModifyDPSPreCast) {
                                                            ; If enabling pre-cast and it wasn't enabled before OR key needs updating
                                                            if (!dpsPressKeyBeforeCast.HasKey(selectedDPS) || !dpsPressKeyBeforeCast[selectedDPS] || !dpsPreCastKeys.HasKey(selectedDPS)) {
                                                                currentPreKey := dpsPreCastKeys.HasKey(selectedDPS) ? dpsPreCastKeys[selectedDPS] : ""
                                                                    InputBox, preCastKey, Pre-Cast Key, Enter the key to press BEFORE the main skill key (e.g. Tab):, , 350, 150, , , , , %currentPreKey%
                                                                    if (!ErrorLevel && preCastKey != "") {
                                                                        dpsPressKeyBeforeCast[selectedDPS] := true
                                                                        dpsPreCastKeys[selectedDPS] := preCastKey
                                                                        FileEncoding, UTF-8
                                                                        IniWrite, true, %iniFile%, DPSPreCastEnabled, %selectedDPS%
                                                                        IniWrite, %preCastKey%, %iniFile%, DPSPreCastKeys, %selectedDPS%
                                                                        FileEncoding
                                                                    }
                                                                }
                                                            } else {
                                                                ; Remove pre-cast if unchecked
                                                                dpsPressKeyBeforeCast[selectedDPS] := false
                                                                dpsPreCastKeys.Delete(selectedDPS)
                                                                IniDelete, %iniFile%, DPSPreCastEnabled, %selectedDPS%
                                                                IniDelete, %iniFile%, DPSPreCastKeys, %selectedDPS%
                                                            }

                                                            ; Force refresh priority list with timer to ensure GUI has processed
                                                            UpdateDPSStatus("Updated modifiers for '" . displayName . "'")
                                                            Gui, ModifyDPSOptions:Destroy
                                                            SetTimer, ForceRefreshDPS, -200
                                                            return

                                                            CancelDPSModifiers:
                                                                Gui, ModifyDPSOptions:Destroy
                                                            return

                                                            ShowDPSSkills:
                                                                statusMsg := "=== DPS SKILLS STATUS ===`r`n`r`nINI: " . iniFile . "`r`n`r`n"

                                                                if (dpsPatterns.Count() = 0) {
                                                                    statusMsg .= "No DPS skills captured yet.`r`n"
                                                                } else {
                                                                    dpsCount := 0
                                                                    for patternName, patternText in dpsPatterns {
                                                                        displayName := GetDPSDisplayName(patternName)
                                                                        key := dpsPatternKeys.HasKey(patternName) ? dpsPatternKeys[patternName] : "Click"
                                                                            statusMsg .= ++dpsCount . ". " . displayName . " [" . patternName . "] - " . key . "`r`n"
                                                                        }

                                                                        statusMsg .= "`r`n=== PRIORITY ORDER ===`r`n"
                                                                        for index, priorityPattern in dpsPriorities {
                                                                            if (dpsPatterns.HasKey(priorityPattern))
                                                                                statusMsg .= index . ". " . GetDPSDisplayName(priorityPattern) . "`r`n"
                                                                        }
                                                                    }

                                                                    UpdateDPSStatus(statusMsg)
                                                                    return

                                                                    AddCCSkill:
                                                                        UpdateCCStatus("Press 1 when the skill to capture is visable on screen.")
                                                                        KeyWait, 1, D
                                                                        capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)
                                                                        Clipboard := capturedText
                                                                        patternName := "cc" . ccCounter

                                                                        ; Prompt for custom name and key assignment
                                                                        InputBox, customName, Name CC Skill, Enter a name for this CC skill:, , 300, 130, , , , , %patternName%
                                                                            if (ErrorLevel)
                                                                            return

                                                                        if (customName = "")
                                                                            customName := patternName

                                                                        InputBox, assignedKey, Assign Key, Enter a key for this skill (leave empty to click with mouse):, , 300, 130
                                                                            if (ErrorLevel)
                                                                            return

                                                                        ; Prompt for stun duration
                                                                        InputBox, stunDuration, Stun Duration, Enter the stun duration in milliseconds (e.g. 2000 for 2 seconds):, , 300, 130, , , , , 2000
                                                                            if (ErrorLevel)
                                                                            return

                                                                        if (stunDuration = "" || !RegExMatch(stunDuration, "^\d+$"))
                                                                            stunDuration := 2000

                                                                        ; Prompt for CC type
                                                                        MsgBox, 4, CC Type, Is this an AoE (Area of Effect) stun?`n`nClick Yes for AoE`nClick No for Single Target
                                                                            IfMsgBox Yes
                                                                        ccType := "aoe"
                                                                        Else
                                                                            ccType := "single"

                                                                        SaveCCPattern(patternName, capturedText, assignedKey, customName, stunDuration, ccType)
                                                                        UpdateCCStatus("CC skill captured and saved as '" . customName . "' [" . patternName . "] with " . stunDuration . "ms stun (" . ccType . ")")
                                                                        ccCounter++

                                                                        ; Add to priority list at the end
                                                                        ccPriorities.Push(patternName)
                                                                        SaveCCPriorities()
                                                                        RefreshCCPriorityList()
                                                                    return

                                                                    TestCCSkills:
                                                                        if (ccPatterns.Count() = 0) {
                                                                            UpdateCCStatus("No CC skills captured. Add some skills first.")
                                                                            return
                                                                        }

                                                                        UpdateCCStatus("Testing CC skills - searching for patterns on screen...")

                                                                        foundCount := 0
                                                                        totalCount := 0

                                                                        ; Test each CC pattern
                                                                        for patternName, patternText in ccPatterns {
                                                                            totalCount++
                                                                            displayName := GetCCDisplayName(patternName)

                                                                            ; Search in the skill bar area - convert window-relative to screen coordinates
                                                                            WinGetPos, winX, winY,,, ahk_id %win1%
                                                                            screenX1 := winX + SkillBarX1
                                                                            screenY1 := winY + SkillBarY1
                                                                            screenX2 := winX + SkillBarX2
                                                                            screenY2 := winY + SkillBarY2
                                                                            if (ok := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)) {
                                                                                foundCount++
                                                                                UpdateCCStatus("✓ FOUND: " . displayName . " at coordinates: " . X . ", " . Y)

                                                                                ; Highlight the found skill
                                                                                Try {
                                                                                    For i, v in ok {
                                                                                        if (i <= 2)
                                                                                            FindText().MouseTip(ok[i].x, ok[i].y)
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                UpdateCCStatus("✗ Not found: " . displayName)
                                                                            }
                                                                        }

                                                                        UpdateCCStatus("Test complete - Found " . foundCount . " out of " . totalCount . " CC skills on screen.")
                                                                    return

                                                                    ClearCCSkills:
                                                                        InputBox, patternToClear, Clear CC Pattern, Enter the name of the CC pattern to clear (leave empty to clear all):, , 300, 130
                                                                        if (ErrorLevel)
                                                                            return

                                                                        if (patternToClear = "") {
                                                                            ccPatterns := {}
                                                                            ccPatternKeys := {}
                                                                            ccPatternNames := {}
                                                                            ccPriorities := []
                                                                            IniDelete, %iniFile%, CCPatterns
                                                                            IniDelete, %iniFile%, CCPatternKeys
                                                                            IniDelete, %iniFile%, CCPatternNames
                                                                            IniDelete, %iniFile%, CCPriorities
                                                                            ccCounter := 1
                                                                            RefreshCCPriorityList()
                                                                            UpdateCCStatus("All CC patterns have been cleared.")
                                                                        } else {
                                                                            ; Check both pattern name and custom name
                                                                            patternToDelete := ""
                                                                            for ccPat, ccText in ccPatterns {
                                                                                displayName := GetCCDisplayName(ccPat)
                                                                                if (ccPat = patternToClear || displayName = patternToClear) {
                                                                                    patternToDelete := ccPat
                                                                                    break
                                                                                }
                                                                            }

                                                                            if (patternToDelete != "") {
                                                                                ccPatterns.Delete(patternToDelete)
                                                                                ccPatternKeys.Delete(patternToDelete)
                                                                                ccPatternNames.Delete(patternToDelete)

                                                                                ; Remove from priority list
                                                                                for index, priorityPattern in ccPriorities {
                                                                                    if (priorityPattern = patternToDelete) {
                                                                                        ccPriorities.RemoveAt(index)
                                                                                        break
                                                                                    }
                                                                                }

                                                                                IniDelete, %iniFile%, CCPatterns, %patternToDelete%
                                                                                IniDelete, %iniFile%, CCPatternKeys, %patternToDelete%
                                                                                IniDelete, %iniFile%, CCPatternNames, %patternToDelete%
                                                                                SaveCCPriorities()
                                                                                RefreshCCPriorityList()
                                                                                UpdateCCStatus("CC pattern '" . patternToClear . "' has been cleared.")
                                                                            } else {
                                                                                UpdateCCStatus("CC pattern '" . patternToClear . "' not found.")
                                                                            }
                                                                        }
                                                                    return

                                                                    AssignCCKeys:
                                                                        ; Show available CC skills and let user assign keys
                                                                        ccList := "=== ASSIGN KEYS TO CC SKILLS ===`n`n"
                                                                        ccCount := 0

                                                                        for patternName, patternText in ccPatterns {
                                                                            ccCount++
                                                                            displayName := GetCCDisplayName(patternName)
                                                                            currentKey := ccPatternKeys.HasKey(patternName) ? ccPatternKeys[patternName] : "(none)"

                                                                                ccList .= ccCount . ". " . displayName . " [" . patternName . "]`n"
                                                                                ccList .= " Current Key: " . currentKey . "`n`n"
                                                                            }

                                                                            if (ccCount = 0) {
                                                                                UpdateCCStatus("No CC skills to assign keys to. Capture some skills first.")
                                                                            return
                                                                        }

                                                                        ccList .= "`nEnter the number of the CC skill to assign a key to:"

                                                                        InputBox, ccNumber, Assign CC Key, %ccList%, , 400, 300
                                                                        if (ErrorLevel)
                                                                            return

                                                                        ; Find the selected CC skill
                                                                        currentIndex := 1
                                                                        selectedCC := ""
                                                                        for patternName, patternText in ccPatterns {
                                                                            if (currentIndex = ccNumber) {
                                                                                selectedCC := patternName
                                                                                break
                                                                            }
                                                                            currentIndex++
                                                                        }

                                                                        if (selectedCC = "") {
                                                                            UpdateCCStatus("Invalid CC skill number selected.")
                                                                            return
                                                                        }

                                                                        ; Get key assignment
                                                                        selectedDisplayName := GetCCDisplayName(selectedCC)
                                                                        currentKey := ccPatternKeys.HasKey(selectedCC) ? ccPatternKeys[selectedCC] : ""
                                                                            keyPrompt := "=== ASSIGN KEY ===`n`nCC Skill: " . selectedDisplayName . "`nID: " . selectedCC . "`nCurrent Key: " . currentKey . "`n`nEnter new key (examples: 1, 2, F1, F2, etc.):"
                                                                            InputBox, newKey, Assign Key to CC Skill, %keyPrompt%, , 400, 200, , , , , %currentKey%
                                                                            if (ErrorLevel)
                                                                                return

                                                                            ; Save the assignment
                                                                            ccPatternKeys[selectedCC] := newKey
                                                                            SaveCCPatternKey(selectedCC, newKey)
                                                                            UpdateCCStatus("Assigned key '" . newKey . "' to '" . selectedDisplayName . "' [" . selectedCC . "] and saved to INI")
                                                                            RefreshCCPriorityList()
                                                                        return

                                                                        RenameCCSkills:
                                                                            if (ccPatterns.Count() = 0) {
                                                                                UpdateCCStatus("No CC skills to rename.")
                                                                                return
                                                                            }

                                                                            ; Build skill list and selection array in one pass
                                                                            ccList := "=== RENAME CC SKILLS ===`n`n"
                                                                            skillArray := []

                                                                            for patternName, patternText in ccPatterns {
                                                                                skillArray.Push(patternName)
                                                                                displayName := GetCCDisplayName(patternName)
                                                                                status := (displayName != patternName) ? "(Custom)" : "(Default)"
                                                                                    ccList .= skillArray.Length() . ". " . displayName . " [" . patternName . "] " . status . "`n"
                                                                                }

                                                                                ; Create scrollable GUI instead of InputBox
                                                                                Gui, RenameCCSelect:New, +Resize, Rename CC Skill
                                                                                Gui, RenameCCSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %ccList%`n`nEnter skill number:
                                                                                Gui, RenameCCSelect:Add, Edit, x10 y340 w100 h20 vCCNumberInput
                                                                                Gui, RenameCCSelect:Add, Button, x120 y340 w60 h20 gRenameCCSelectOK, OK
                                                                                Gui, RenameCCSelect:Add, Button, x190 y340 w60 h20 gRenameCCSelectCancel, Cancel
                                                                                Gui, RenameCCSelect:Show, w600 h380
                                                                                return

                                                                                RenameCCSelectOK:
                                                                                    Gui, RenameCCSelect:Submit
                                                                                    ccNumber := CCNumberInput
                                                                                    if (ccNumber < 1 || ccNumber > skillArray.Length()) {
                                                                                        UpdateCCStatus("Invalid selection.")
                                                                                        return
                                                                                    }
                                                                                    Gui, RenameCCSelect:Destroy

                                                                                    selectedCC := skillArray[ccNumber]
                                                                                    currentDisplayName := GetCCDisplayName(selectedCC)

                                                                                    InputBox, newName, Rename CC Skill, Original: %selectedCC%`nCurrent: %currentDisplayName%`n`nNew name:, , 400, 180, , , , , %currentDisplayName%
                                                                                    if (ErrorLevel || newName = "") {
                                                                                        if (!ErrorLevel) UpdateCCStatus("Name cannot be empty.")
                                                                                            return
                                                                                    }

                                                                                    ; Update in-memory object directly
                                                                                    ccPatternNames[selectedCC] := newName
                                                                                    SaveCCPatternName(selectedCC, newName)
                                                                                    UpdateCCStatus("Renamed '" . selectedCC . "' to '" . newName . "'")

                                                                                    ; Force refresh with timer
                                                                                    SetTimer, ForceRefreshCC, -50
                                                                                return

                                                                                RenameCCSelectCancel:
                                                                                    Gui, RenameCCSelect:Destroy
                                                                                return

                                                                                ShowCCSkills:
                                                                                    statusMsg := "=== CC SKILLS STATUS ===`r`n`r`nINI: " . iniFile . "`r`n`r`n"

                                                                                    if (ccPatterns.Count() = 0) {
                                                                                        statusMsg .= "No CC skills captured yet.`r`n"
                                                                                    } else {
                                                                                        ccCount := 0
                                                                                        for patternName, patternText in ccPatterns {
                                                                                            displayName := GetCCDisplayName(patternName)
                                                                                            key := ccPatternKeys.HasKey(patternName) ? ccPatternKeys[patternName] : "Click"
                                                                                                statusMsg .= ++ccCount . ". " . displayName . " [" . patternName . "] - " . key . "`r`n"
                                                                                            }

                                                                                            statusMsg .= "`r`n=== PRIORITY ORDER ===`r`n"
                                                                                            for index, priorityPattern in ccPriorities {
                                                                                                if (ccPatterns.HasKey(priorityPattern))
                                                                                                    statusMsg .= index . ". " . GetCCDisplayName(priorityPattern) . "`r`n"
                                                                                            }
                                                                                        }

                                                                                        UpdateCCStatus(statusMsg)
                                                                                        return
                                                                                        StartDPSScript:
                                                                                            if (TargetGameWindow = "") {
                                                                                                UpdateDPSStatus("Please select a target window first using the Healer tab.")
                                                                                                return
                                                                                            }

                                                                                            if (dpsPatterns.Count() = 0) {
                                                                                                UpdateDPSStatus("No DPS skills captured. Add some skills first.")
                                                                                                return
                                                                                            }

                                                                                            ; If DPS + Heal Combo is enabled, stop standalone healer
                                                                                            if (healanddps) {
                                                                                                SetTimer, DynamicHealthCheck, Off
                                                                                                UpdateHealerStatus("Standalone healer stopped - DPS loop will handle healing")
                                                                                            }

                                                                                            isDpsRunning := true
                                                                                            SetTimer, DPSLoop, 50 ; Check every 300ms for better weaving  

                                                                                            if (healanddps) {
                                                                                                UpdateDPSStatus("DPS + Healing combo started. DPS loop will weave healing and DPS.")
                                                                                            } else {
                                                                                                UpdateDPSStatus("DPS script started. Will weave with healing and buffs using priority order.")
                                                                                            }
                                                                                        return

                                                                                        StopDPSScript:
                                                                                            isDpsRunning := false
                                                                                            SetTimer, DPSLoop, Off
                                                                                            UpdateDPSStatus("DPS script stopped.")
                                                                                        return

                                                                                        DPSLoop:
                                                                                            ; Check if Critical mode is enabled
                                                                                            if (CriticalModeEnabled) {
                                                                                                return
                                                                                            }
                                                                                            if (!isDpsRunning)
                                                                                            {
                                                                                                return
                                                                                            }
                                                                                            ; DPS has second priority - yield to healing
                                                                                            ; if (isSystemBusy) {
                                                                                            ;     ;ActivateGameWindow()
                                                                                            ;     return ; Skip this cycle if system is busy with healing
                                                                                            ; }
                                                                                            if (healanddps)
                                                                                            {
                                                                                                gosub, DynamicHealthCheck
                                                                                            }

                                                                                            ;Check DPS Navigation if enabled
                                                                                            if (dpsNavEnabled && dpsNavTargetX != "" && dpsNavTargetY != "") {
                                                                                                Loop {
                                                                                                    CheckDPSNavigation()
                                                                                                    GetNavCurrentCoordinates(currentX, currentY)
                                                                                                    if (Abs(currentX - dpsNavTargetX) <= dpsNavRadius && Abs(currentY - dpsNavTargetY) <= dpsNavRadius) {
                                                                                                        ControlSend,, {tab}, ahk_id %win1%
                                                                                                        break
                                                                                                    }
                                                                                                    Sleep, 100
                                                                                                }
                                                                                                if (arrived)
                                                                                                {

                                                                                                    sendmessage, 0x100, ox1b, 0, , ahk_id %win1% ; esc_KEYDOWN
                                                                                                    Sleep, 50
                                                                                                    sendmessage, 0x101, ox1b, 0, , ahk_id %win1% ; esc_KEYUP
                                                                                                    sendmessage, 0x100, ox1b, 0, , ahk_id %win1% ; esc_KEYDOWN
                                                                                                    Sleep, 50
                                                                                                    sendmessage, 0x101, ox1b, 0, , ahk_id %win1% ; esc_KEYUP

                                                                                                    ;}
                                                                                                    arrived := false
                                                                                                }

                                                                                            }

                                                                                            TryCastDPSSkills()
                                                                                            ; Add a check to ensure dpsandheal is properly updated when checkbox changes
                                                                                            sleep, 75
                                                                                            ; Release system busy flag
                                                                                            TryCastCC()
                                                                                            ;isSystemBusy := false
                                                                                        return
                                                                                        TryCastDPSSkillsold() {
                                                                                            global dpsPatterns, dpsPatternKeys, dpsPriorities
                                                                                            global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2, isDpsRunning
                                                                                            global SequentialDPSEnabled, CurrentSequentialIndex

                                                                                            if (SequentialDPSEnabled) {
                                                                                                ; Sequential mode - ONLY try the current skill in order, don't skip
                                                                                                if (CurrentSequentialIndex > dpsPriorities.MaxIndex()) {
                                                                                                    CurrentSequentialIndex := 1 ; Loop back to first skill
                                                                                                }

                                                                                                priorityPattern := dpsPriorities[CurrentSequentialIndex]

                                                                                                if (!dpsPatterns.HasKey(priorityPattern)) {
                                                                                                    ; If pattern doesn't exist, skip to next but don't cast anything
                                                                                                    CurrentSequentialIndex++
                                                                                                    return false
                                                                                                }

                                                                                                patternText := dpsPatterns[priorityPattern]

                                                                                                ; Convert window-relative coordinates to screen coordinates
                                                                                                WinGetPos, winX, winY,,, ahk_id %win1%

                                                                                                ; Validate window position first
                                                                                                if (winX = "" || winY = "" || winX < 0 || winY < 0) {
                                                                                                    return false
                                                                                                }

                                                                                                global screenX1 := winX + SkillBarX1
                                                                                                global screenY1 := winY + SkillBarY1
                                                                                                global screenX2 := winX + SkillBarX2
                                                                                                global screenY2 := winY + SkillBarY2

                                                                                                global dpsSkill := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)

                                                                                                if (dpsSkill) {
                                                                                                    ; ONLY cast if we found the exact skill we're looking for
                                                                                                    displayName := GetDPSDisplayName(priorityPattern)
                                                                                                    hasKey := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != ""
                                                                                                    skillCastSuccessfully := false

                                                                                                    if (hasKey) {
                                                                                                        keyToPress := dpsPatternKeys[priorityPattern]

                                                                                                        ; Check for modifier keys
                                                                                                        hasCtrl := InStr(keyToPress, "^")
                                                                                                        hasAlt := InStr(keyToPress, "!")
                                                                                                        hasShift := InStr(keyToPress, "+")

                                                                                                        ; Extract the base key (remove modifiers)
                                                                                                        baseKey := keyToPress
                                                                                                        if (hasCtrl)
                                                                                                            baseKey := StrReplace(baseKey, "^")
                                                                                                        if (hasAlt)
                                                                                                            baseKey := StrReplace(baseKey, "!")
                                                                                                        if (hasShift)
                                                                                                            baseKey := StrReplace(baseKey, "+")

                                                                                                        ; Send modifier keys down
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                        ; Send the base key
                                                                                                        ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                        Sleep, 50
                                                                                                        ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                        ; Release modifiers (reverse order)
                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                        skillCastSuccessfully := true

                                                                                                    } else {
                                                                                                        if (IsObject(dpsSkill) && dpsSkill.MaxIndex() >= 1) {
                                                                                                            X := dpsSkill.1.x
                                                                                                            Y := dpsSkill.1.y

                                                                                                            if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                                                                                                                ToolTip, Sequential DPS Click at %X%`, %Y%, , , 1
                                                                                                                SendMessageClick(X, Y)
                                                                                                                skillCastSuccessfully := true
                                                                                                            }
                                                                                                        }
                                                                                                    }

                                                                                                    if (skillCastSuccessfully) {
                                                                                                        method := hasKey ? "key: " . dpsPatternKeys[priorityPattern] : "clicking"
                                                                                                        prefix := isDpsRunning ? "" : "TEST: "
                                                                                                            UpdateDPSStatus(prefix . "Sequential: Used " . displayName . " (" . CurrentSequentialIndex . "/" . dpsPriorities.MaxIndex() . ") with " . method)

                                                                                                            CurrentSequentialIndex++ ; ONLY move to next skill AFTER successful cast
                                                                                                            Sleep, 150
                                                                                                        return true
                                                                                                    }
                                                                                                } else {
                                                                                                    ; Skill not available - DO NOT move to next skill, just return false and wait
                                                                                                    ; This means we'll keep looking for the same skill on the next call
                                                                                                    displayName := GetDPSDisplayName(priorityPattern)
                                                                                                    if (!isDpsRunning) {
                                                                                                        UpdateDPSStatus("Sequential: Waiting for " . displayName . " (" . CurrentSequentialIndex . "/" . dpsPriorities.MaxIndex() . ")")
                                                                                                    }
                                                                                                    return false ; Don't cast anything, don't advance index
                                                                                                }

                                                                                                return false

                                                                                            } else {
                                                                                                ; Original availability-based mode (unchanged)
                                                                                                for index, priorityPattern in dpsPriorities {
                                                                                                    if (!dpsPatterns.HasKey(priorityPattern))
                                                                                                        continue

                                                                                                    patternText := dpsPatterns[priorityPattern]
                                                                                                    ; Convert window-relative coordinates to screen coordinates
                                                                                                    WinGetPos, winX, winY,,, ahk_id %win1%

                                                                                                    ; Validate window position first
                                                                                                    if (winX = "" || winY = "" || winX < 0 || winY < 0) {
                                                                                                        return false
                                                                                                    }

                                                                                                    global screenX1 := winX + SkillBarX1
                                                                                                    global screenY1 := winY + SkillBarY1
                                                                                                    global screenX2 := winX + SkillBarX2
                                                                                                    global screenY2 := winY + SkillBarY2

                                                                                                    global dpsSkill := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)

                                                                                                    if (dpsSkill) {
                                                                                                        displayName := GetDPSDisplayName(priorityPattern)
                                                                                                        hasKey := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != ""

                                                                                                        ; Execute skill with spam protection
                                                                                                        spamCount := 0
                                                                                                        skillCastSuccessfully := false

                                                                                                        Loop, 5 { ; Max 5 attempts
                                                                                                            spamCount++

                                                                                                            if (hasKey) {
                                                                                                                keyToPress := dpsPatternKeys[priorityPattern]

                                                                                                                ; Check for modifier keys
                                                                                                                hasCtrl := InStr(keyToPress, "^")
                                                                                                                hasAlt := InStr(keyToPress, "!")
                                                                                                                hasShift := InStr(keyToPress, "+")

                                                                                                                ; Extract the base key (remove modifiers)
                                                                                                                baseKey := keyToPress
                                                                                                                if (hasCtrl)
                                                                                                                    baseKey := StrReplace(baseKey, "^")
                                                                                                                if (hasAlt)
                                                                                                                    baseKey := StrReplace(baseKey, "!")
                                                                                                                if (hasShift)
                                                                                                                    baseKey := StrReplace(baseKey, "+")

                                                                                                                ; Send modifier keys down
                                                                                                                if (hasCtrl)
                                                                                                                    ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                                if (hasAlt)
                                                                                                                    ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                                if (hasShift)
                                                                                                                    ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                                ; Send the base key
                                                                                                                ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                                Sleep, 50
                                                                                                                ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                                ; Release modifiers (reverse order)
                                                                                                                if (hasShift)
                                                                                                                    ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                                if (hasAlt)
                                                                                                                    ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                                if (hasCtrl)
                                                                                                                    ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                                skillCastSuccessfully := true

                                                                                                            } else {
                                                                                                                if (IsObject(dpsSkill) && dpsSkill.MaxIndex() >= 1) {
                                                                                                                    X := dpsSkill.1.x
                                                                                                                    Y := dpsSkill.1.y

                                                                                                                    if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                                                                                                                        ToolTip, DPS Click at %X%`, %Y%, , , 1
                                                                                                                        SendMessageClick(X, Y)
                                                                                                                        skillCastSuccessfully := true
                                                                                                                    } else {
                                                                                                                        break
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    break
                                                                                                                }
                                                                                                            }

                                                                                                            ; Recheck availability (search full screen width for 4K monitors)
                                                                                                            Sleep, 125
                                                                                                            recheckSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)
                                                                                                            if (!recheckSkill) {
                                                                                                                break
                                                                                                            }
                                                                                                        }

                                                                                                        if (skillCastSuccessfully) {
                                                                                                        method := hasKey ? "key: " . dpsPatternKeys[priorityPattern] : "clicking"
                                                                                                        prefix := isDpsRunning ? "" : "TEST: "
                                                                                                            UpdateDPSStatus(prefix . "Used " . displayName . " with " . method . " (" . spamCount . "x)")
                                                                                                            Sleep, 150
                                                                                                        return true
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            if (!isDpsRunning)
                                                                                                UpdateDPSStatus("No DPS skills found on screen.")
                                                                                            return false
                                                                                        }
                                                                                    }
                                                                                    SequentialDPSMode:
                                                                                        Gui, Submit, NoHide
                                                                                        SequentialDPSEnabled := SequentialDPSMode
                                                                                        if (SequentialDPSEnabled) {
                                                                                            UpdateDPSStatus("Sequential DPS Mode: ENABLED - Skills will cast in priority order only")
                                                                                            CurrentSequentialIndex := 1 ; Reset to first skill
                                                                                        } else {
                                                                                            UpdateDPSStatus("Sequential DPS Mode: DISABLED - Normal availability-based casting")
                                                                                        }
                                                                                    return

                                                                                    MeleeAttackToggle:
                                                                                        Gui, Submit, NoHide
                                                                                        if (meleeAttackEnabled) {
                                                                                            GuiControl, Show, MeleeKeyLabel
                                                                                            GuiControl, Show, meleeAttackKey
                                                                                            UpdateDPSStatus("Melee Attack: ENABLED - Will send melee key after each successful skill cast")
                                                                                        } else {
                                                                                            GuiControl, Hide, MeleeKeyLabel
                                                                                            GuiControl, Hide, meleeAttackKey
                                                                                            UpdateDPSStatus("Melee Attack: DISABLED")
                                                                                        }
                                                                                        ; Save to INI
                                                                                        IniWrite, %meleeAttackEnabled%, %SettingsFile%, Settings, meleeAttackEnabled
                                                                                    return

                                                                                    meleeKeyChanged:
                                                                                        Gui, Submit, NoHide
                                                                                        ; Save to INI
                                                                                        IniWrite, %meleeAttackKey%, %SettingsFile%, Settings, meleeAttackKey
                                                                                        if (meleeAttackKey != "")
                                                                                            UpdateDPSStatus("melee attack key set to: " . meleeAttackKey)
                                                                                    return

                                                                                    UpdateFollowKey:
                                                                                        Gui, Submit, NoHide
                                                                                        ; Save to INI
                                                                                        IniWrite, %selectedKey%, %iniFile%, Settings, FollowWhoKey
                                                                                    return

                                                                                    UseRefreshScroll:
                                                                                        if (refreshscrollEnabled) {
                                                                                            ; Allow multiple key combos separated by |
                                                                                            if (refreshKey != "") {
                                                                                                keyList := StrSplit(refreshKey, "|")
                                                                                                if (!IsObject(lastPressTimes))
                                                                                                    lastPressTimes := {}
                                                                                                keysPressed := 0
                                                                                                now := A_TickCount

                                                                                                Loop % keyList.Length() {
                                                                                                    keyCombo := Trim(keyList[A_Index])
                                                                                                    ; Check for modifier keys
                                                                                                    hasCtrl := InStr(keyCombo, "^")
                                                                                                    hasAlt := InStr(keyCombo, "!")
                                                                                                    hasShift := InStr(keyCombo, "+")

                                                                                                    ; Extract the base key (remove modifiers)
                                                                                                    baseKey := keyCombo
                                                                                                    if (hasCtrl)
                                                                                                        baseKey := StrReplace(baseKey, "^")
                                                                                                    if (hasAlt)
                                                                                                        baseKey := StrReplace(baseKey, "!")
                                                                                                    if (hasShift)
                                                                                                        baseKey := StrReplace(baseKey, "+")

                                                                                                }

                                                                                                ; Initialize sequence tracking
                                                                                                if (!IsObject(refreshScrollState)) {
                                                                                                    refreshScrollState := {currentKeyIndex: 1, lastPressTime: 0}
                                                                                                }

                                                                                                ; Check if it's time to press the next key in sequence
                                                                                                if (now - refreshScrollState.lastPressTime >= 20000) {
                                                                                                    if (refreshScrollState.currentKeyIndex <= keyList.Length()) {
                                                                                                        ; Get current key to press
                                                                                                        currentKey := keyList[refreshScrollState.currentKeyIndex]

                                                                                                        ; Parse modifiers
                                                                                                        hasCtrl := InStr(currentKey, "^")
                                                                                                        hasAlt := InStr(currentKey, "!")
                                                                                                        hasShift := InStr(currentKey, "+")
                                                                                                        baseKey := currentKey
                                                                                                        if (hasCtrl)
                                                                                                            baseKey := StrReplace(baseKey, "^")
                                                                                                        if (hasAlt)
                                                                                                            baseKey := StrReplace(baseKey, "!")
                                                                                                        if (hasShift)
                                                                                                            baseKey := StrReplace(baseKey, "+")

                                                                                                        ; Send the key
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                        ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                        Sleep, 50
                                                                                                        ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                        refreshScrollState.lastPressTime := now
                                                                                                        refreshScrollState.currentKeyIndex++

                                                                                                        ; If sequence complete, set 1-hour wait
                                                                                                        if (refreshScrollState.currentKeyIndex > keyList.Length()) {
                                                                                                            refreshScrollState.lastPressTime := now + 3600000 ; Wait 1 hour
                                                                                                        }
                                                                                                    }

                                                                                                }

                                                                                            }
                                                                                        }

                                                                                    UpdateRefreshScrollTimer:
                                                                                        ; Pause timer until all keys are pressed
                                                                                        if (refreshScrollState.currentKeyIndex <= StrSplit(refreshKey, "|").Length()) {
                                                                                            GuiControl,, refreshScrollTimer, % "Pressing keys..."
                                                                                            return
                                                                                        }

                                                                                        ; Show 1-hour countdown after all keys pressed
                                                                                        remaining := refreshScrollState.lastPressTime - A_TickCount
                                                                                        if (remaining < 0) {
                                                                                            remaining := 0
                                                                                            refreshScrollState.currentKeyIndex := 1
                                                                                            refreshScrollState.lastPressTime := 0
                                                                                        }

                                                                                        hours := Floor(remaining / 3600000)
                                                                                        minutes := Floor(Mod(remaining, 3600000) / 60000)
                                                                                        seconds := Floor(Mod(remaining, 60000) / 1000)
                                                                                        GuiControl,, refreshScrollTimer, % "Time left: " . Format("{:02}:{:02}:{:02}", hours, minutes, seconds)
                                                                                    return

                                                                                    return
                                                                                    refreshscrollToggle:
                                                                                        Gui, Submit, NoHide
                                                                                        if (refreshscrollEnabled) {
                                                                                            GuiControl, Show, refreshKeyLabel
                                                                                            GuiControl, Show, refreshKey
                                                                                            ; Initialize refresh scroll state
                                                                                            refreshScrollState := {currentKeyIndex: 1, lastPressTime: 0}
                                                                                            Gosub, userefreshscroll
                                                                                            refreshScrollEndTime := A_TickCount + 3600000
                                                                                            SetTimer, UpdateRefreshScrollTimer, 1000
                                                                                            SetTimer, userefreshscroll, 5000
                                                                                        } else {
                                                                                            GuiControl, Hide, refreshKeyLabel
                                                                                            GuiControl, Hide, refreshKey
                                                                                            SetTimer, UpdateRefreshScrollTimer, Off
                                                                                            SetTimer, userefreshscroll, Off
                                                                                            GuiControl,, refreshScrollTimer, Time left: --:--:--
                                                                                        }
                                                                                        IniWrite, %refreshscrollEnabled%, %SettingsFile%, Settings, refreshscrollEnabled
                                                                                    return

                                                                                    refreshKeyChanged:
                                                                                        Gui, Submit, NoHide
                                                                                        ; Save to INI
                                                                                        IniWrite, %refreshKey%, %SettingsFile%, Settings, refreshKey
                                                                                        if (refreshKey != "")
                                                                                            UpdateDPSStatus("Refresh key set to: " . refreshKey)
                                                                                    return

                                                                                    ; DPS Priority Management
                                                                                    DPSPrioritySelect:
                                                                                    return

                                                                                    MoveDPSUp:
                                                                                        ; Get the currently selected item index from the ListBox
                                                                                        GuiControlGet, selectedText, , DPSPriorityList
                                                                                        selectedIndex := 0

                                                                                        ; Parse the index from the text (format: "1. SkillName")
                                                                                        if (selectedText != "") {
                                                                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                            selectedIndex := match1
                                                                                        }

                                                                                        ; Debug info
                                                                                        UpdateDPSStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . dpsPriorities.Length())

                                                                                        if (selectedIndex <= 1 || selectedIndex > dpsPriorities.Length()) {
                                                                                            UpdateDPSStatus("Cannot move item up. Select an item first or item is already at top.")
                                                                                            return
                                                                                        }

                                                                                        ; Swap with previous item
                                                                                        temp := dpsPriorities[selectedIndex]
                                                                                        dpsPriorities[selectedIndex] := dpsPriorities[selectedIndex - 1]
                                                                                        dpsPriorities[selectedIndex - 1] := temp

                                                                                        SaveDPSPriorities()
                                                                                        RefreshDPSPriorityList()

                                                                                        ; Reselect the moved item
                                                                                        GuiControl, Choose, DPSPriorityList, % selectedIndex - 1

                                                                                        UpdateDPSStatus("Moved DPS skill up in priority.")
                                                                                    return

                                                                                    MoveDPSDown:
                                                                                        ; Get the currently selected item index from the ListBox
                                                                                        GuiControlGet, selectedText, , DPSPriorityList
                                                                                        selectedIndex := 0

                                                                                        ; Parse the index from the text (format: "1. SkillName")
                                                                                        if (selectedText != "") {
                                                                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                            selectedIndex := match1
                                                                                        }

                                                                                        ; Debug info
                                                                                        UpdateDPSStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . dpsPriorities.Length())

                                                                                        if (selectedIndex <= 0 || selectedIndex >= dpsPriorities.Length()) {
                                                                                            UpdateDPSStatus("Cannot move item down. Select an item first or item is already at bottom.")
                                                                                            return
                                                                                        }

                                                                                        ; Swap with next item
                                                                                        temp := dpsPriorities[selectedIndex]
                                                                                        dpsPriorities[selectedIndex] := dpsPriorities[selectedIndex + 1]
                                                                                        dpsPriorities[selectedIndex + 1] := temp

                                                                                        SaveDPSPriorities()
                                                                                        RefreshDPSPriorityList()

                                                                                        ; Reselect the moved item
                                                                                        GuiControl, Choose, DPSPriorityList, % selectedIndex + 1

                                                                                        UpdateDPSStatus("Moved DPS skill down in priority.")
                                                                                    return

                                                                                    RefreshDPSList:
                                                                                        RefreshDPSPriorityList()
                                                                                        UpdateDPSStatus("DPS priority list refreshed.")
                                                                                    return

                                                                                    RemoveFromDPSPriority:
                                                                                        ; Get the currently selected item index from the ListBox
                                                                                        GuiControlGet, selectedText, , DPSPriorityList
                                                                                        selectedIndex := 0

                                                                                        ; Parse the index from the text (format: "1. SkillName")
                                                                                        if (selectedText != "") {
                                                                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                            selectedIndex := match1
                                                                                        }

                                                                                        if (selectedIndex <= 0 || selectedIndex > dpsPriorities.Length()) {
                                                                                            UpdateDPSStatus("Select a DPS skill to remove from priority.")
                                                                                            return
                                                                                        }

                                                                                        removedSkill := dpsPriorities[selectedIndex]
                                                                                        displayName := GetDPSDisplayName(removedSkill)
                                                                                        dpsPriorities.RemoveAt(selectedIndex)

                                                                                        SaveDPSPriorities()
                                                                                        RefreshDPSPriorityList()
                                                                                        UpdateDPSStatus("Removed '" . displayName . "' from DPS priority order (skill still saved).")
                                                                                    return

                                                                                    AddToDPSPriority:
                                                                                        ; Show available DPS skills not in priority
                                                                                        availableDPS := "=== ADD DPS SKILL TO PRIORITY ===`n`n"
                                                                                        availableCount := 0
                                                                                        availableSkills := []

                                                                                        for patternName, patternText in dpsPatterns {
                                                                                            ; Check if already in priority
                                                                                            inPriority := false
                                                                                            for index, priorityPattern in dpsPriorities {
                                                                                                if (priorityPattern = patternName) {
                                                                                                    inPriority := true
                                                                                                    break
                                                                                                }
                                                                                            }

                                                                                            if (!inPriority) {
                                                                                                availableCount++
                                                                                                availableSkills.Push(patternName)
                                                                                                displayName := GetDPSDisplayName(patternName)
                                                                                                availableDPS .= availableCount . ". " . displayName . " [" . patternName . "]`n"
                                                                                            }
                                                                                        }

                                                                                        if (availableCount = 0) {
                                                                                            UpdateDPSStatus("No DPS skills available to add (all are already in priority or none saved).")
                                                                                            return
                                                                                        }

                                                                                        availableDPS .= "`nEnter the number of the DPS skill to add to priority:"

                                                                                        InputBox, dpsNumber, Add DPS Skill to Priority, %availableDPS%, , 400, 300
                                                                                        if (ErrorLevel)
                                                                                            return

                                                                                        if (dpsNumber < 1 || dpsNumber > availableCount) {
                                                                                            UpdateDPSStatus("Invalid DPS skill number selected.")
                                                                                            return
                                                                                        }

                                                                                        selectedSkill := availableSkills[dpsNumber]
                                                                                        displayName := GetDPSDisplayName(selectedSkill)

                                                                                        ; Add to end of priority list
                                                                                        dpsPriorities.Push(selectedSkill)
                                                                                        SaveDPSPriorities()
                                                                                        RefreshDPSPriorityList()
                                                                                        UpdateDPSStatus("Added '" . displayName . "' to DPS priority order.")
                                                                                    return

                                                                                    RefreshDPSPriorityList() {
                                                                                        global dpsPatterns, dpsPatternNames, dpsPatternKeys, dpsPriorities
                                                                                        global dpsGroundTargetSkills, dpsPressKeyBeforeCast

                                                                                        ; Clear the listbox completely
                                                                                        GuiControl,, DPSPriorityList, |

                                                                                        ; Force rebuild the list
                                                                                        newList := ""
                                                                                        itemCount := 0
                                                                                        for index, priorityPattern in dpsPriorities {
                                                                                            if (dpsPatterns.HasKey(priorityPattern)) {
                                                                                                itemCount++
                                                                                                ; Force get fresh display name
                                                                                                displayName := dpsPatternNames.HasKey(priorityPattern) && dpsPatternNames[priorityPattern] != "" ? dpsPatternNames[priorityPattern] : priorityPattern
                                                                                                keyInfo := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != "" ? " (Key: " . dpsPatternKeys[priorityPattern] . ")" : " (Click)"

                                                                                                    ; Add modifier indicators - check for true/1/"true"
                                                                                                    modifiers := ""
                                                                                                    hasGroundTarget := dpsGroundTargetSkills.HasKey(priorityPattern) && (dpsGroundTargetSkills[priorityPattern] = true || dpsGroundTargetSkills[priorityPattern] = 1 || dpsGroundTargetSkills[priorityPattern] = "true" || dpsGroundTargetSkills[priorityPattern] = "1")
                                                                                                    hasPreCast := dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = 1 || dpsPressKeyBeforeCast[priorityPattern] = "true" || dpsPressKeyBeforeCast[priorityPattern] = "1")

                                                                                                    if (hasGroundTarget && hasPreCast)
                                                                                                        modifiers := " [CB]"
                                                                                                    else if (hasGroundTarget)
                                                                                                        modifiers := " [C]"
                                                                                                    else if (hasPreCast)
                                                                                                        modifiers := " [B]"

                                                                                                    listItem := index . ". " . displayName . keyInfo . modifiers
                                                                                                    if (newList != "")
                                                                                                        newList .= "|"
                                                                                                    newList .= listItem
                                                                                                }
                                                                                            }

                                                                                            ; Set the entire list at once
                                                                                            GuiControl,, DPSPriorityList, %newList%

                                                                                            ; Show count for debugging
                                                                                            if (itemCount = 0 && dpsPriorities.Length() > 0) {
                                                                                                UpdateDPSStatus("Warning: " . dpsPriorities.Length() . " priorities but 0 valid patterns found")
                                                                                            }
                                                                                        }

                                                                                        ; DPS Helper Functions
                                                                                        SaveDPSPattern(patternName, patternText, keyAssignment, customName, isGroundTarget := false, groundX := "", groundY := "", needsPreCastKey := false, preCastKey := "") {
                                                                                            global iniFile, dpsPatterns, dpsPatternKeys, dpsPatternNames, dpsGroundTargetSkills, dpsGroundTargetCoords, dpsPressKeyBeforeCast, dpsPreCastKeys

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %patternText%, %iniFile%, DPSPatterns, %patternName%
                                                                                            IniWrite, %keyAssignment%, %iniFile%, DPSPatternKeys, %patternName%
                                                                                            IniWrite, %customName%, %iniFile%, DPSPatternNames, %patternName%

                                                                                            ; Save ground target settings
                                                                                            IniWrite, %isGroundTarget%, %iniFile%, DPSGroundTarget, %patternName%
                                                                                            if (isGroundTarget && groundX != "" && groundY != "") {
                                                                                                coordString := groundX . "," . groundY
                                                                                                IniWrite, %coordString%, %iniFile%, DPSGroundCoords, %patternName%
                                                                                            }

                                                                                            ; Save pre-cast key settings
                                                                                            IniWrite, %needsPreCastKey%, %iniFile%, DPSPreCastEnabled, %patternName%
                                                                                            if (needsPreCastKey && preCastKey != "") {
                                                                                                IniWrite, %preCastKey%, %iniFile%, DPSPreCastKeys, %patternName%
                                                                                            }
                                                                                            FileEncoding

                                                                                            dpsPatterns[patternName] := patternText
                                                                                            dpsPatternKeys[patternName] := keyAssignment
                                                                                            dpsPatternNames[patternName] := customName
                                                                                            dpsGroundTargetSkills[patternName] := isGroundTarget
                                                                                            if (isGroundTarget && groundX != "" && groundY != "") {
                                                                                                dpsGroundTargetCoords[patternName] := {x: groundX, y: groundY}
                                                                                            }
                                                                                            dpsPressKeyBeforeCast[patternName] := needsPreCastKey
                                                                                            if (needsPreCastKey && preCastKey != "") {
                                                                                                dpsPreCastKeys[patternName] := preCastKey
                                                                                            }
                                                                                        }

                                                                                        SaveDPSPatternKey(patternName, keyAssignment) {
                                                                                            global iniFile, dpsPatternKeys

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %keyAssignment%, %iniFile%, DPSPatternKeys, %patternName%
                                                                                            FileEncoding
                                                                                            dpsPatternKeys[patternName] := keyAssignment
                                                                                        }

                                                                                        SaveDPSPatternName(patternName, customName) {
                                                                                            global iniFile, dpsPatternNames

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %customName%, %iniFile%, DPSPatternNames, %patternName%
                                                                                            FileEncoding
                                                                                            dpsPatternNames[patternName] := customName
                                                                                        }

                                                                                        SaveDPSPriorities() {
                                                                                            global iniFile, dpsPriorities

                                                                                            ; Convert array to comma-separated string
                                                                                            priorityString := ""
                                                                                            for index, priorityPattern in dpsPriorities {
                                                                                                if (index > 1)
                                                                                                    priorityString .= ","
                                                                                                priorityString .= priorityPattern
                                                                                            }

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %priorityString%, %iniFile%, DPSPriorities, Order
                                                                                            FileEncoding
                                                                                        }

                                                                                        LoadDPSPriorities() {
                                                                                            global iniFile, dpsPriorities

                                                                                            IniRead, priorityString, %iniFile%, DPSPriorities, Order, %A_Space%
                                                                                            if (priorityString != "" && priorityString != "ERROR") {
                                                                                                dpsPriorities := StrSplit(priorityString, ",")
                                                                                            }
                                                                                        }

                                                                                        GetDPSDisplayName(patternName) {
                                                                                            global dpsPatternNames

                                                                                            if (dpsPatternNames.HasKey(patternName) && dpsPatternNames[patternName] != "")
                                                                                                return dpsPatternNames[patternName]
                                                                                            return patternName
                                                                                        }

                                                                                        LoadAllDPSPatterns() {
                                                                                            global iniFile, dpsPatterns, dpsPatternKeys, dpsPatternNames, dpsGroundTargetSkills, dpsGroundTargetCoords, dpsPressKeyBeforeCast, dpsPreCastKeys

                                                                                            ; Load DPS patterns
                                                                                            IniRead, dpsPatternsList, %iniFile%, DPSPatterns
                                                                                            if (dpsPatternsList != "ERROR") {
                                                                                                Loop, Parse, dpsPatternsList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            patternText := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPatterns[patternName] := patternText
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load DPS pattern keys
                                                                                            IniRead, dpsPatternKeysList, %iniFile%, DPSPatternKeys
                                                                                            if (dpsPatternKeysList != "ERROR") {
                                                                                                Loop, Parse, dpsPatternKeysList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            keyAssignment := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPatternKeys[patternName] := keyAssignment
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load DPS pattern names
                                                                                            IniRead, dpsPatternNamesList, %iniFile%, DPSPatternNames
                                                                                            if (dpsPatternNamesList != "ERROR") {
                                                                                                Loop, Parse, dpsPatternNamesList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            customName := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPatternNames[patternName] := customName
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load ground target settings
                                                                                            IniRead, dpsGroundTargetList, %iniFile%, DPSGroundTarget
                                                                                            if (dpsGroundTargetList != "ERROR") {
                                                                                                Loop, Parse, dpsGroundTargetList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            isGroundTarget := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsGroundTargetSkills[patternName] := isGroundTarget
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load ground target coordinates
                                                                                            IniRead, dpsGroundCoordsList, %iniFile%, DPSGroundCoords
                                                                                            if (dpsGroundCoordsList != "ERROR") {
                                                                                                Loop, Parse, dpsGroundCoordsList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            coordString := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            coords := StrSplit(coordString, ",")
                                                                                                            if (coords.Length() = 2) {
                                                                                                                dpsGroundTargetCoords[patternName] := {x: coords[1], y: coords[2]}
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load pre-cast key enabled settings
                                                                                            IniRead, dpsPreCastEnabledList, %iniFile%, DPSPreCastEnabled
                                                                                            if (dpsPreCastEnabledList != "ERROR") {
                                                                                                Loop, Parse, dpsPreCastEnabledList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            needsPreCast := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPressKeyBeforeCast[patternName] := needsPreCast
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load pre-cast keys
                                                                                            IniRead, dpsPreCastKeysList, %iniFile%, DPSPreCastKeys
                                                                                            if (dpsPreCastKeysList != "ERROR") {
                                                                                                Loop, Parse, dpsPreCastKeysList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            preCastKey := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPreCastKeys[patternName] := preCastKey
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Initialize DPS counter
                                                                                            InitializeDPSCounter()

                                                                                            dpsCount := dpsPatterns.Count()
                                                                                            if (dpsCount > 0) {
                                                                                                UpdateDPSStatus("Loaded " . dpsCount . " DPS pattern(s) successfully.")
                                                                                            }
                                                                                        }

                                                                                        InitializeDPSCounter() {
                                                                                            global dpsPatterns, dpsCounter

                                                                                            highestNumber := 0
                                                                                            for patternName, patternValue in dpsPatterns {
                                                                                                if (SubStr(patternName, 1, 3) = "dps") {
                                                                                                    numberPart := SubStr(patternName, 4)
                                                                                                    if numberPart is integer
                                                                                                    {
                                                                                                        if (numberPart > highestNumber)
                                                                                                            highestNumber := numberPart
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            dpsCounter := highestNumber + 1
                                                                                        }

                                                                                        ReloadDPSCustomNames() {
                                                                                            global iniFile, dpsPatternNames

                                                                                            ; Don't clear - just reload what's in the INI
                                                                                            FileEncoding, UTF-8
                                                                                            IniRead, dpsPatternNamesList, %iniFile%, DPSPatternNames
                                                                                            FileEncoding
                                                                                            if (dpsPatternNamesList != "ERROR") {
                                                                                                Loop, Parse, dpsPatternNamesList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            customName := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPatternNames[patternName] := customName
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }

                                                                                        UpdateDPSStatus(message) {
                                                                                            global

                                                                                            ; Get current time
                                                                                            FormatTime, TimeString, , yyyy-MM-dd HH:mm:ss
                                                                                            statusMessage := "[" . TimeString . "] " . message

                                                                                            ; Get current content and add new message at top
                                                                                            GuiControlGet, currentContent, , DPSStatusEdit
                                                                                            if (currentContent != "") {
                                                                                                newContent := statusMessage . "`r`n" . currentContent
                                                                                            } else {
                                                                                                newContent := statusMessage
                                                                                            }

                                                                                            ; Update the edit control
                                                                                            GuiControl,, DPSStatusEdit, %newContent%

                                                                                            ; Scroll to top (new messages are now at top)
                                                                                            SendMessage, 0x0115, 6, 0, , ahk_id %DPSStatusEdit% ; WM_VSCROLL, SB_TOP
                                                                                        }
                                                                                        ;  ========= CC Helper Functions =========
                                                                                        SaveCCPattern(patternName, patternText, keyAssignment, customName, stunDuration, ccType) {
                                                                                            global iniFile, ccPatterns, ccPatternKeys, ccPatternNames, ccStunDurations, ccTypes

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %patternText%, %iniFile%, CCPatterns, %patternName%
                                                                                            IniWrite, %keyAssignment%, %iniFile%, CCPatternKeys, %patternName%
                                                                                            IniWrite, %customName%, %iniFile%, CCPatternNames, %patternName%
                                                                                            IniWrite, %stunDuration%, %iniFile%, CCStunDurations, %patternName%
                                                                                            IniWrite, %ccType%, %iniFile%, CCTypes, %patternName%
                                                                                            FileEncoding

                                                                                            ccPatterns[patternName] := patternText
                                                                                            ccPatternKeys[patternName] := keyAssignment
                                                                                            ccPatternNames[patternName] := customName
                                                                                            ccStunDurations[patternName] := stunDuration
                                                                                            ccTypes[patternName] := ccType
                                                                                        }

                                                                                        SaveCCPatternKey(patternName, keyAssignment) {
                                                                                            global iniFile, ccPatternKeys

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %keyAssignment%, %iniFile%, CCPatternKeys, %patternName%
                                                                                            FileEncoding
                                                                                            ccPatternKeys[patternName] := keyAssignment
                                                                                        }

                                                                                        SaveCCPatternName(patternName, customName) {
                                                                                            global iniFile, ccPatternNames

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %customName%, %iniFile%, CCPatternNames, %patternName%
                                                                                            FileEncoding
                                                                                            ccPatternNames[patternName] := customName
                                                                                        }
                                                                                        RefreshCCPriorityList() {
                                                                                            ; Clear the listbox completely
                                                                                            GuiControl,, CCPriorityList, |

                                                                                            ; Force rebuild the list
                                                                                            newList := ""
                                                                                            itemCount := 0
                                                                                            for index, priorityPattern in ccPriorities {
                                                                                                if (ccPatterns.HasKey(priorityPattern)) {
                                                                                                    itemCount++
                                                                                                    ; Force get fresh display name
                                                                                                    displayName := ccPatternNames.HasKey(priorityPattern) && ccPatternNames[priorityPattern] != "" ? ccPatternNames[priorityPattern] : priorityPattern
                                                                                                keyInfo := ccPatternKeys.HasKey(priorityPattern) && ccPatternKeys[priorityPattern] != "" ? " (Key: " . ccPatternKeys[priorityPattern] . ")" : " (Click)"
                                                                                                    listItem := index . ". " . displayName . keyInfo
                                                                                                    if (newList != "")
                                                                                                        newList .= "|"
                                                                                                    newList .= listItem
                                                                                                }
                                                                                            }

                                                                                            ; Set the entire list at once
                                                                                            GuiControl,, CCPriorityList, %newList%

                                                                                            ; Show count for debugging
                                                                                            if (itemCount = 0 && ccPriorities.Length() > 0) {
                                                                                                UpdateCCStatus("Warning: " . ccPriorities.Length() . " priorities but 0 valid patterns found")
                                                                                            }
                                                                                        }

                                                                                        SaveCCPriorities() {
                                                                                            global iniFile, ccPriorities

                                                                                            ; Convert array to comma-separated string
                                                                                            priorityString := ""
                                                                                            for index, priorityPattern in ccPriorities {
                                                                                                if (index > 1)
                                                                                                    priorityString .= ","
                                                                                                priorityString .= priorityPattern
                                                                                            }

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %priorityString%, %iniFile%, CCPriorities, Order
                                                                                            FileEncoding
                                                                                        }

                                                                                        LoadCCPriorities() {
                                                                                            global iniFile, ccPriorities

                                                                                            IniRead, priorityString, %iniFile%, CCPriorities, Order, %A_Space%
                                                                                            if (priorityString != "" && priorityString != "ERROR") {
                                                                                                ccPriorities := StrSplit(priorityString, ",")
                                                                                            }
                                                                                        }

                                                                                        GetCCDisplayName(patternName) {
                                                                                            global ccPatternNames

                                                                                            if (ccPatternNames.HasKey(patternName) && ccPatternNames[patternName] != "")
                                                                                                return ccPatternNames[patternName]
                                                                                            return patternName
                                                                                        }

                                                                                        LoadAllCCPatterns() {
                                                                                            global iniFile, ccPatterns, ccPatternKeys, ccPatternNames, ccStunDurations, ccTypes

                                                                                            ; Load CC patterns
                                                                                            IniRead, ccPatternsList, %iniFile%, CCPatterns
                                                                                            if (ccPatternsList != "ERROR") {
                                                                                                Loop, Parse, ccPatternsList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            patternText := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccPatterns[patternName] := patternText
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load CC pattern keys
                                                                                            IniRead, ccPatternKeysList, %iniFile%, CCPatternKeys
                                                                                            if (ccPatternKeysList != "ERROR") {
                                                                                                Loop, Parse, ccPatternKeysList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            keyAssignment := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccPatternKeys[patternName] := keyAssignment
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load CC pattern names
                                                                                            IniRead, ccPatternNamesList, %iniFile%, CCPatternNames
                                                                                            if (ccPatternNamesList != "ERROR") {
                                                                                                Loop, Parse, ccPatternNamesList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            customName := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccPatternNames[patternName] := customName
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load CC stun durations
                                                                                            IniRead, ccStunDurationsList, %iniFile%, CCStunDurations
                                                                                            if (ccStunDurationsList != "ERROR") {
                                                                                                Loop, Parse, ccStunDurationsList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            stunDuration := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccStunDurations[patternName] := stunDuration
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load CC types
                                                                                            IniRead, ccTypesList, %iniFile%, CCTypes
                                                                                            if (ccTypesList != "ERROR") {
                                                                                                Loop, Parse, ccTypesList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            ccType := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccTypes[patternName] := ccType
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Initialize CC counter
                                                                                            InitializeCCCounter()

                                                                                            ccCount := ccPatterns.Count()
                                                                                            if (ccCount > 0) {
                                                                                                UpdateCCStatus("Loaded " . ccCount . " CC pattern(s) successfully.")
                                                                                            }
                                                                                        }

                                                                                        InitializeCCCounter() {
                                                                                            global ccPatterns, ccCounter

                                                                                            highestNumber := 0
                                                                                            for patternName, patternValue in ccPatterns {
                                                                                                if (SubStr(patternName, 1, 3) = "cc") {
                                                                                                    numberPart := SubStr(patternName, 4)
                                                                                                    if numberPart is integer
                                                                                                    {
                                                                                                        if (numberPart > highestNumber)
                                                                                                            highestNumber := numberPart
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ccCounter := highestNumber + 1
                                                                                        }

                                                                                        ReloadCCCustomNames() {
                                                                                            global iniFile, ccPatternNames

                                                                                            ; Don't clear - just reload what's in the INI
                                                                                            FileEncoding, UTF-8
                                                                                            IniRead, ccPatternNamesList, %iniFile%, CCPatternNames
                                                                                            FileEncoding
                                                                                            if (ccPatternNamesList != "ERROR") {
                                                                                                Loop, Parse, ccPatternNamesList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            customName := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccPatternNames[patternName] := customName
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        UpdateCCStatus(message) {
                                                                                            global

                                                                                            ; Get current time
                                                                                            FormatTime, TimeString, , yyyy-MM-dd HH:mm:ss
                                                                                            statusMessage := "[" . TimeString . "] " . message

                                                                                            ; Get current content and add new message at top
                                                                                            GuiControlGet, currentContent, , CCStatusEdit
                                                                                            if (currentContent != "") {
                                                                                                newContent := statusMessage . "`r`n" . currentContent
                                                                                            } else {
                                                                                                newContent := statusMessage
                                                                                            }

                                                                                            ; Update the edit control
                                                                                            GuiControl,, CCStatusEdit, %newContent%

                                                                                            ; Scroll to top (new messages are now at top)
                                                                                            SendMessage, 0x0115, 6, 0, , ahk_id %CCStatusEdit% ; WM_VSCROLL, SB_TOP
                                                                                        }

                                                                                        TryCastCC() {
                                                                                            global ccPatterns, ccPatternKeys, ccPriorities, ccStunDurations, ccTypes
                                                                                            global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2, isCcRunning, ccOnCooldown
                                                                                            global lastAoeCCTime, aoeCCCooldown, ClientSocket

                                                                                            currentTime := A_TickCount

                                                                                            ; Skip if on local cooldown (can't use ANY CC until own cooldown expires)
                                                                                            if (ccOnCooldown)
                                                                                                return false

                                                                                            for index, priorityPattern in ccPriorities {
                                                                                                if (!ccPatterns.HasKey(priorityPattern))
                                                                                                    continue

                                                                                                ; Check CC type
                                                                                                ccType := ccTypes.HasKey(priorityPattern) ? ccTypes[priorityPattern] : "single"

                                                                                                    ; If AoE, check network-wide AoE cooldown
                                                                                                    if (ccType = "aoe") {
                                                                                                        if (currentTime < lastAoeCCTime + aoeCCCooldown) {
                                                                                                            ; Another client's AoE is still active, skip this AoE skill
                                                                                                            continue
                                                                                                        }
                                                                                                    }
                                                                                                    ; Single-target stuns can always be attempted if local cooldown is clear

                                                                                                    patternText := ccPatterns[priorityPattern]

                                                                                                    ; Convert window-relative coords to screen coords
                                                                                                    WinGetPos, winX, winY,,, ahk_id %win1%
                                                                                                    screenX1 := winX + SkillBarX1
                                                                                                    screenY1 := winY + SkillBarY1
                                                                                                    screenX2 := winX + SkillBarX2
                                                                                                    screenY2 := winY + SkillBarY2

                                                                                                    ; For 4K monitors, search entire screen width but constrain to skill bar height
                                                                                                    ccSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

                                                                                                    if (ccSkill) {
                                                                                                        displayName := GetDPSDisplayName(priorityPattern) ; rename if you have a CC-specific display name
                                                                                                        hasKey := ccPatternKeys.HasKey(priorityPattern) && ccPatternKeys[priorityPattern] != ""

                                                                                                        ; Execute skill with spam protection
                                                                                                        spamCount := 0
                                                                                                        success := false
                                                                                                        Loop, 5 { ; Max 5 attempts
                                                                                                            spamCount++

                                                                                                            if (hasKey) {
                                                                                                                keyToPress := ccPatternKeys[priorityPattern]

                                                                                                                ; Check for modifier keys
                                                                                                                hasCtrl := InStr(keyToPress, "^")
                                                                                                                hasAlt := InStr(keyToPress, "!")
                                                                                                                hasShift := InStr(keyToPress, "+")

                                                                                                                ; Extract the base key
                                                                                                                baseKey := StrReplace(keyToPress, "^", "")
                                                                                                                baseKey := StrReplace(baseKey, "!", "")
                                                                                                                baseKey := StrReplace(baseKey, "+", "")

                                                                                                                ; Apply QWERTZ conversion if enabled
                                                                                                                baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                                                ; Send modifier keys down
                                                                                                                if (hasCtrl)
                                                                                                                    ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                                if (hasAlt)
                                                                                                                    ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                                if (hasShift)
                                                                                                                    ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                                ; Send the base key
                                                                                                                ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                                Sleep, 50
                                                                                                                ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                                ; Release modifiers
                                                                                                                if (hasShift)
                                                                                                                    ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                                if (hasAlt)
                                                                                                                    ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                                if (hasCtrl)
                                                                                                                    ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                            } else {
                                                                                                                ; Only click if coords exist
                                                                                                                if (IsObject(ccSkill) && ccSkill.MaxIndex() >= 1) {
                                                                                                                    X := ccSkill.1.x
                                                                                                                    Y := ccSkill.1.y
                                                                                                                    SendMessageClick(X, Y)
                                                                                                                } else {
                                                                                                                    ;UpdateCCStatus("⚠ No CC coords available, skipping click.")
                                                                                                                }
                                                                                                            }

                                                                                                            ; Recheck availability (search full screen width for 4K monitors)
                                                                                                            Sleep, 125
                                                                                                            if (!FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)) {
                                                                                                                success := true
                                                                                                                break
                                                                                                            }
                                                                                                        }

                                                                                                        ; If after 5 tries the image is still there → don’t click (avoid 0,0 jump)
                                                                                                        if (!success) {
                                                                                                            ;UpdateCCStatus("⚠ Pattern did not disappear after " . spamCount . " attempts, skipping.")
                                                                                                        }

                                                                                                        ; Status message
                                                                                                        method := hasKey ? "key: " . ccPatternKeys[priorityPattern] : "clicking"
                                                                                                        prefix := isCcRunning ? "" : "TEST: "

                                                                                                            ; Set cooldown based on stun duration
                                                                                                            if (ccStunDurations.HasKey(priorityPattern)) {
                                                                                                                stunDurationMs := ccStunDurations[priorityPattern]
                                                                                                                if (stunDurationMs > 0) {
                                                                                                                    ; Set local cooldown (prevents THIS client from using any CC)
                                                                                                                    ccOnCooldown := true
                                                                                                                    stunDurationSec := stunDurationMs / 1000.0

                                                                                                                    ; If AoE, also update network-wide AoE cooldown and broadcast
                                                                                                                    if (ccType = "aoe") {
                                                                                                                        lastAoeCCTime := A_TickCount
                                                                                                                        aoeCCCooldown := stunDurationMs

                                                                                                                        ; Broadcast to network if connected
                                                                                                                        if (ClientSocket != -1) {
                                                                                                                            SendCommandToAll("STUNUSED:AOE|" . stunDurationMs)
                                                                                                                        }
                                                                                                                        UpdateCCStatus(prefix . "Used " . displayName . " (AoE) - Local & Network CC locked for " . stunDurationSec . "s")
                                                                                                                    } else {
                                                                                                                        UpdateCCStatus(prefix . "Used " . displayName . " (Single) - Local CC locked for " . stunDurationSec . "s")
                                                                                                                    }

                                                                                                                    SetTimer, ResetCCCooldown, -%stunDurationMs%
                                                                                                                }
                                                                                                            }

                                                                                                            SendMeleeAttack() ; Send melee attack after successful CC skill cast
                                                                                                            Sleep, 150
                                                                                                        return true
                                                                                                    }
                                                                                                }

                                                                                                if (!isCcRunning)
                                                                                                    UpdateCCStatus("No CC skills found on screen.")
                                                                                                return false
                                                                                            }

                                                                                            ResetCCCooldown:
                                                                                                ccOnCooldown := false
                                                                                                UpdateCCStatus("CC cooldown expired - ready to cast again")
                                                                                            return

                                                                                            TryCastCCSkills() {
                                                                                            return TryCastCC()
                                                                                        }

                                                                                        ; ========= MELEE ATTACK HELPER FUNCTION =========
                                                                                        SendMeleeAttack() {
                                                                                            global meleeAttackEnabled, meleeAttackKey, win1

                                                                                            if ((meleeAttackEnabled = 1 || meleeAttackEnabled = "1" || meleeAttackEnabled = true) && meleeAttackKey != "" && meleeAttackKey != " ") {
                                                                                                Random, attackCount, 2, 5

                                                                                                ; Check for modifier keys
                                                                                                hasCtrl := InStr(meleeAttackKey, "^")
                                                                                                hasAlt := InStr(meleeAttackKey, "!")
                                                                                                hasShift := InStr(meleeAttackKey, "+")

                                                                                                ; Extract the base key
                                                                                                baseKey := meleeAttackKey
                                                                                                if (hasCtrl)
                                                                                                    baseKey := StrReplace(baseKey, "^")
                                                                                                if (hasAlt)
                                                                                                    baseKey := StrReplace(baseKey, "!")
                                                                                                if (hasShift)
                                                                                                    baseKey := StrReplace(baseKey, "+")

                                                                                                Sleep, 50
                                                                                                Loop, %attackCount% {
                                                                                                    ; Send modifiers down
                                                                                                    if (hasCtrl)
                                                                                                        ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                    if (hasAlt)
                                                                                                        ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                    if (hasShift)
                                                                                                        ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                    ; Send base key
                                                                                                    ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                    Sleep, 25
                                                                                                    ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                    ; Release modifiers
                                                                                                    if (hasShift)
                                                                                                        ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                    if (hasAlt)
                                                                                                        ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                    if (hasCtrl)
                                                                                                        ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                    Sleep, 25
                                                                                                }
                                                                                            }
                                                                                            return
                                                                                        }

                                                                                        ; ========= COMBAT FUNCTION =========
                                                                                        ; Performs a combat sequence for a specified duration
                                                                                        ; Loops: DynamicHealthCheck -> TryCastCC -> TryCastDPSSkills
                                                                                        ; Then navigates back to group if DPS navigation is enabled
                                                                                        PerformCombat(durationSeconds := 10) {
                                                                                            global dpsNavEnabled, dpsNavTargetX, dpsNavTargetY, dpsNavRadius
                                                                                            global win1, arrived

                                                                                            startTime := A_TickCount
                                                                                            endTime := startTime + (durationSeconds * 1000)

                                                                                            ; Combat loop
                                                                                            Loop {
                                                                                                ; Check if duration has elapsed
                                                                                                if (A_TickCount >= endTime)
                                                                                                    break

                                                                                                ; Perform combat actions
                                                                                                gosub, DynamicHealthCheck
                                                                                                Sleep, 50
                                                                                                TryCastCC()
                                                                                                Sleep, 50
                                                                                                TryCastDPSSkills()
                                                                                                Sleep, 50
                                                                                            }

                                                                                            ; After combat, navigate back to group if DPS nav is enabled
                                                                                            if (dpsNavEnabled && dpsNavTargetX != "" && dpsNavTargetY != "") {
                                                                                                Loop {
                                                                                                    CheckDPSNavigation()
                                                                                                    GetNavCurrentCoordinates(currentX, currentY)
                                                                                                    if (Abs(currentX - dpsNavTargetX) <= dpsNavRadius && Abs(currentY - dpsNavTargetY) <= dpsNavRadius) {
                                                                                                        ;ControlSend,, {tab}, ahk_id %win1%
                                                                                                        break
                                                                                                    }
                                                                                                    Sleep, 100
                                                                                                }

                                                                                                ; Press Escape twice when arrived
                                                                                                if (arrived) {
                                                                                                    sendmessage, 0x100, 0x1b, 0, , ahk_id %win1% ; ESC_KEYDOWN
                                                                                                    Sleep, 50
                                                                                                    sendmessage, 0x101, 0x1b, 0, , ahk_id %win1% ; ESC_KEYUP
                                                                                                    sendmessage, 0x100, 0x1b, 0, , ahk_id %win1% ; ESC_KEYDOWN
                                                                                                    Sleep, 50
                                                                                                    sendmessage, 0x101, 0x1b, 0, , ahk_id %win1% ; ESC_KEYUP
                                                                                                    arrived := false
                                                                                                }
                                                                                            }
                                                                                        }

                                                                                        ; ========= DPS SKILL CASTING FUNCTION =========
                                                                                        TryCastDPSSkills() {
                                                                                            global dpsPatterns, dpsPatternKeys, dpsPriorities
                                                                                            global dpsGroundTargetSkills, dpsGroundTargetCoords, dpsPressKeyBeforeCast, dpsPreCastKeys
                                                                                            global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2, isDpsRunning
                                                                                            global SequentialDPSEnabled, CurrentSequentialIndex

                                                                                            if (SequentialDPSEnabled) {
                                                                                                ; Sequential mode - cast skills only in order, don't skip if not found
                                                                                                if (CurrentSequentialIndex > dpsPriorities.MaxIndex()) {
                                                                                                    CurrentSequentialIndex := 1 ; Loop back to first skill
                                                                                                }

                                                                                                priorityPattern := dpsPriorities[CurrentSequentialIndex]

                                                                                                if (!dpsPatterns.HasKey(priorityPattern)) {
                                                                                                    ; If pattern doesn't exist, move to next skill but don't cast anything
                                                                                                    CurrentSequentialIndex++
                                                                                                    return false
                                                                                                }

                                                                                                patternText := dpsPatterns[priorityPattern]

                                                                                                ; Convert window-relative coordinates to screen coordinates
                                                                                                WinGetPos, winX, winY,,, ahk_id %win1%

                                                                                                ; Validate window position first
                                                                                                if (winX = "" || winY = "" || winX < 0 || winY < 0) {
                                                                                                    return false
                                                                                                }

                                                                                                screenX1 := winX + SkillBarX1
                                                                                                screenY1 := winY + SkillBarY1
                                                                                                screenX2 := winX + SkillBarX2
                                                                                                screenY2 := winY + SkillBarY2

                                                                                                ; Debug: Show search area once at start
                                                                                                if (!isDpsRunning && A_Index = 1) {
                                                                                                    UpdateDPSStatus("Searching FULL WIDTH: [0," . screenY1 . "] to [" . A_ScreenWidth . "," . screenY2 . "] | WinPos: " . winX . "," . winY)
                                                                                                }

                                                                                                ; For 4K monitors, search entire screen width but constrain to skill bar height
                                                                                                dpsSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

                                                                                                if (dpsSkill) {
                                                                                                    ; Cast the skill we found
                                                                                                    displayName := GetDPSDisplayName(priorityPattern)
                                                                                                    hasKey := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != ""
                                                                                                    skillCastSuccessfully := false

                                                                                                    ; Check for pre-cast key
                                                                                                    if (dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = "1" || dpsPressKeyBeforeCast[priorityPattern] = "true") && dpsPreCastKeys.HasKey(priorityPattern) && dpsPreCastKeys[priorityPattern] != "") {
                                                                                                        preCastKey := dpsPreCastKeys[priorityPattern]
                                                                                                        ControlSend,, {%preCastKey% down}, ahk_id %win1%
                                                                                                        Sleep, 50
                                                                                                        ControlSend,, {%preCastKey% up}, ahk_id %win1%
                                                                                                        Sleep, 100
                                                                                                    }

                                                                                                    if (hasKey) {
                                                                                                        keyToPress := dpsPatternKeys[priorityPattern]

                                                                                                        ; Check for modifier keys
                                                                                                        hasCtrl := InStr(keyToPress, "^")
                                                                                                        hasAlt := InStr(keyToPress, "!")
                                                                                                        hasShift := InStr(keyToPress, "+")

                                                                                                        ; Extract the base key (remove modifiers)
                                                                                                        baseKey := keyToPress
                                                                                                        if (hasCtrl)
                                                                                                            baseKey := StrReplace(baseKey, "^")
                                                                                                        if (hasAlt)
                                                                                                            baseKey := StrReplace(baseKey, "!")
                                                                                                        if (hasShift)
                                                                                                            baseKey := StrReplace(baseKey, "+")

                                                                                                        ; Apply QWERTZ conversion if enabled
                                                                                                        baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                                        ; Send modifier keys down
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                        ; Send the base key
                                                                                                        ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                        Sleep, 50
                                                                                                        ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                        ; Release modifiers (reverse order)
                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                        skillCastSuccessfully := true

                                                                                                    } else {
                                                                                                        if (IsObject(dpsSkill) && dpsSkill.MaxIndex() >= 1) {
                                                                                                            X := dpsSkill.1.x
                                                                                                            Y := dpsSkill.1.y

                                                                                                            ; Validate coordinates before clicking
                                                                                                            if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                                                                                                                SendMessageClick(X, Y)
                                                                                                                skillCastSuccessfully := true
                                                                                                            }
                                                                                                        }
                                                                                                    }

                                                                                                    ; Handle ground targeting if enabled
                                                                                                    if (skillCastSuccessfully && dpsGroundTargetSkills.HasKey(priorityPattern) && (dpsGroundTargetSkills[priorityPattern] = true || dpsGroundTargetSkills[priorityPattern] = "1" || dpsGroundTargetSkills[priorityPattern] = "true") && dpsGroundTargetCoords.HasKey(priorityPattern)) {
                                                                                                        Sleep, 150
                                                                                                        groundCoords := dpsGroundTargetCoords[priorityPattern]
                                                                                                        ; Add randomization to coordinates (±20 pixels)
                                                                                                        Random, randX, -20, 20
                                                                                                        Random, randY, -20, 20
                                                                                                        relX := groundCoords.x + randX
                                                                                                        relY := groundCoords.y + randY
                                                                                                        ; Move mouse to ground target location
                                                                                                        lParamMove := (relY << 16) | (relX & 0xFFFF)
                                                                                                        SendMessage, 0x200, 0, lParamMove,, ahk_id %win1% ; WM_MOUSEMOVE
                                                                                                        Sleep, 50
                                                                                                        ; Click at ground target location
                                                                                                        lParam := (relY << 16) | (relX & 0xFFFF)
                                                                                                        SendMessage, 0x201, 0x0001, lParam,, ahk_id %win1% ; WM_LBUTTONDOWN
                                                                                                        Sleep, 50
                                                                                                        SendMessage, 0x202, 0, lParam,, ahk_id %win1% ; WM_LBUTTONUP
                                                                                                        Sleep, 100
                                                                                                    }

                                                                                                    ; Press Tab after skill cast (only if pre-cast key was used)
                                                                                                    if (skillCastSuccessfully && dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = "1" || dpsPressKeyBeforeCast[priorityPattern] = "true") && dpsPreCastKeys.HasKey(priorityPattern) && dpsPreCastKeys[priorityPattern] != "") {
                                                                                                        ControlSend,, {Tab down}, ahk_id %win1%
                                                                                                        Sleep, 50
                                                                                                        ControlSend,, {Tab up}, ahk_id %win1%
                                                                                                        Sleep, 100
                                                                                                    } if (skillCastSuccessfully) {
                                                                                                        method := hasKey ? "key: " . dpsPatternKeys[priorityPattern] : "clicking"
                                                                                                        prefix := isDpsRunning ? "" : "TEST: "
                                                                                                            UpdateDPSStatus(prefix . "Sequential: Used " . displayName . " (" . CurrentSequentialIndex . "/" . dpsPriorities.MaxIndex() . ") with " . method)

                                                                                                            SendMeleeAttack() ; Send melee attack after successful DPS skill cast
                                                                                                            CurrentSequentialIndex++ ; Move to next skill AFTER successful cast
                                                                                                            Sleep, 150
                                                                                                        return true
                                                                                                    }
                                                                                                } else {
                                                                                                    ; Skill not found - in sequential mode, we don't cast anything and don't advance
                                                                                                    displayName := GetDPSDisplayName(priorityPattern)
                                                                                                    if (!isDpsRunning) {
                                                                                                        UpdateDPSStatus("Sequential: Waiting for " . displayName . " (" . CurrentSequentialIndex . "/" . dpsPriorities.MaxIndex() . ")")
                                                                                                    }
                                                                                                    return false ; Don't cast anything, don't advance index
                                                                                                }

                                                                                                return false

                                                                                            } else {
                                                                                                ; Non-sequential mode - cast next available skill immediately
                                                                                                for index, priorityPattern in dpsPriorities {
                                                                                                    if (!dpsPatterns.HasKey(priorityPattern))
                                                                                                        continue

                                                                                                    patternText := dpsPatterns[priorityPattern]

                                                                                                    ; Convert window-relative coordinates to screen coordinates
                                                                                                    WinGetPos, winX, winY,,, ahk_id %win1%

                                                                                                    ; Validate window position first
                                                                                                    if (winX = "" || winY = "" || winX < 0 || winY < 0) {
                                                                                                        return false
                                                                                                    }

                                                                                                    screenX1 := winX + SkillBarX1
                                                                                                    screenY1 := winY + SkillBarY1
                                                                                                    screenX2 := winX + SkillBarX2
                                                                                                    screenY2 := winY + SkillBarY2

                                                                                                    ; For 4K monitors, search entire screen width but constrain to skill bar height
                                                                                                    dpsSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

                                                                                                    if (dpsSkill) {
                                                                                                        displayName := GetDPSDisplayName(priorityPattern)
                                                                                                        hasKey := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != ""

                                                                                                        ; Execute skill with spam protection
                                                                                                        spamCount := 0
                                                                                                        skillCastSuccessfully := false

                                                                                                        Loop, 5 { ; Max 5 attempts
                                                                                                            spamCount++

                                                                                                            ; Check for pre-cast key
                                                                                                            if (spamCount = 1 && dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = "1" || dpsPressKeyBeforeCast[priorityPattern] = "true") && dpsPreCastKeys.HasKey(priorityPattern) && dpsPreCastKeys[priorityPattern] != "") {
                                                                                                                preCastKey := dpsPreCastKeys[priorityPattern]
                                                                                                                ControlSend,, {%preCastKey% down}, ahk_id %win1%
                                                                                                                Sleep, 50
                                                                                                                ControlSend,, {%preCastKey% up}, ahk_id %win1%
                                                                                                                Sleep, 100
                                                                                                            }

                                                                                                            if (hasKey) {
                                                                                                                keyToPress := dpsPatternKeys[priorityPattern]

                                                                                                                ; Check for modifier keys
                                                                                                                hasCtrl := InStr(keyToPress, "^")
                                                                                                                hasAlt := InStr(keyToPress, "!")
                                                                                                                hasShift := InStr(keyToPress, "+")

                                                                                                                ; Extract the base key (remove modifiers)
                                                                                                                baseKey := keyToPress
                                                                                                                if (hasCtrl)
                                                                                                                    baseKey := StrReplace(baseKey, "^")
                                                                                                                if (hasAlt)
                                                                                                                    baseKey := StrReplace(baseKey, "!")
                                                                                                                if (hasShift)
                                                                                                                    baseKey := StrReplace(baseKey, "+")

                                                                                                                ; Apply QWERTZ conversion if enabled
                                                                                                                baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                                                ; Send modifier keys down
                                                                                                                if (hasCtrl)
                                                                                                                    ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                                if (hasAlt)
                                                                                                                    ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                                if (hasShift)
                                                                                                                    ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                                ; Send the base key
                                                                                                                ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                                Sleep, 50
                                                                                                                ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                                ; Release modifiers (reverse order)
                                                                                                                if (hasShift)
                                                                                                                    ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                                if (hasAlt)
                                                                                                                    ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                                if (hasCtrl)
                                                                                                                    ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                                skillCastSuccessfully := true

                                                                                                            } else {
                                                                                                                if (IsObject(dpsSkill) && dpsSkill.MaxIndex() >= 1) {
                                                                                                                    X := dpsSkill.1.x
                                                                                                                    Y := dpsSkill.1.y

                                                                                                                    if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                                                                                                                        SendMessageClick(X, Y)
                                                                                                                        skillCastSuccessfully := true
                                                                                                                    } else {
                                                                                                                        break
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    break
                                                                                                                }
                                                                                                            }

                                                                                                            ; Handle ground targeting if enabled (only on first cast)
                                                                                                            if (spamCount = 1 && skillCastSuccessfully && dpsGroundTargetSkills.HasKey(priorityPattern) && (dpsGroundTargetSkills[priorityPattern] = true || dpsGroundTargetSkills[priorityPattern] = "1" || dpsGroundTargetSkills[priorityPattern] = "true") && dpsGroundTargetCoords.HasKey(priorityPattern)) {
                                                                                                                Sleep, 150
                                                                                                                groundCoords := dpsGroundTargetCoords[priorityPattern]
                                                                                                                ; Add randomization to coordinates (±20 pixels)
                                                                                                                Random, randX, -20, 20
                                                                                                                Random, randY, -20, 20
                                                                                                                relX := groundCoords.x + randX
                                                                                                                relY := groundCoords.y + randY
                                                                                                                ; Move mouse to ground target location
                                                                                                                lParamMove := (relY << 16) | (relX & 0xFFFF)
                                                                                                                SendMessage, 0x200, 0, lParamMove,, ahk_id %win1% ; WM_MOUSEMOVE
                                                                                                                Sleep, 50
                                                                                                                ; Click at ground target location
                                                                                                                lParam := (relY << 16) | (relX & 0xFFFF)
                                                                                                                SendMessage, 0x201, 0x0001, lParam,, ahk_id %win1% ; WM_LBUTTONDOWN
                                                                                                                Sleep, 50
                                                                                                                SendMessage, 0x202, 0, lParam,, ahk_id %win1% ; WM_LBUTTONUP
                                                                                                                Sleep, 100
                                                                                                            }

                                                                                                            ; Press Tab after skill cast (only on first cast and if pre-cast key was used)
                                                                                                            if (spamCount = 1 && skillCastSuccessfully && dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = "1" || dpsPressKeyBeforeCast[priorityPattern] = "true") && dpsPreCastKeys.HasKey(priorityPattern) && dpsPreCastKeys[priorityPattern] != "") {
                                                                                                                ControlSend,, {Tab down}, ahk_id %win1%
                                                                                                                Sleep, 50
                                                                                                                ControlSend,, {Tab up}, ahk_id %win1%
                                                                                                                Sleep, 100
                                                                                                            } ; Recheck availability (search full screen width for 4K monitors)
                                                                                                            Sleep, 125
                                                                                                            recheckSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)
                                                                                                            if (!recheckSkill) {
                                                                                                                break
                                                                                                            }
                                                                                                        }

                                                                                                        if (skillCastSuccessfully) {
                                                                                                        method := hasKey ? "key: " . dpsPatternKeys[priorityPattern] : "clicking"
                                                                                                        prefix := isDpsRunning ? "" : "TEST: "
                                                                                                            UpdateDPSStatus(prefix . "Used " . displayName . " with " . method . " (" . spamCount . "x)")
                                                                                                            SendMeleeAttack() ; Send melee attack after successful DPS skill cast
                                                                                                            Sleep, 150
                                                                                                        return true
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            if (!isDpsRunning)
                                                                                                UpdateDPSStatus("No DPS skills found on screen.")
                                                                                            return false
                                                                                        }
                                                                                    }

                                                                                    ; CC Priority Management
                                                                                    CCPrioritySelect:
                                                                                    return

                                                                                    MoveCCUp:
                                                                                        ; Get the currently selected item index from the ListBox
                                                                                        GuiControlGet, selectedText, , CCPriorityList
                                                                                        selectedIndex := 0

                                                                                        ; Parse the index from the text (format: "1. SkillName")
                                                                                        if (selectedText != "") {
                                                                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                            selectedIndex := match1
                                                                                        }

                                                                                        ; Debug info
                                                                                        UpdateCCStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . ccPriorities.Length())

                                                                                        if (selectedIndex <= 1 || selectedIndex > ccPriorities.Length()) {
                                                                                            UpdateCCStatus("Cannot move item up. Select an item first or item is already at top.")
                                                                                            return
                                                                                        }

                                                                                        ; Swap with previous item
                                                                                        temp := ccPriorities[selectedIndex]
                                                                                        ccPriorities[selectedIndex] := ccPriorities[selectedIndex - 1]
                                                                                        ccPriorities[selectedIndex - 1] := temp

                                                                                        SaveCCPriorities()
                                                                                        RefreshCCPriorityList()

                                                                                        ; Reselect the moved item
                                                                                        GuiControl, Choose, CCPriorityList, % selectedIndex - 1

                                                                                        UpdateCCStatus("Moved CC skill up in priority.")
                                                                                    return

                                                                                    MoveCCDown:
                                                                                        ; Get the currently selected item index from the ListBox
                                                                                        GuiControlGet, selectedText, , CCPriorityList
                                                                                        selectedIndex := 0

                                                                                        ; Parse the index from the text (format: "1. SkillName")
                                                                                        if (selectedText != "") {
                                                                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                            selectedIndex := match1
                                                                                        }

                                                                                        ; Debug info
                                                                                        UpdateCCStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . ccPriorities.Length())

                                                                                        if (selectedIndex <= 0 || selectedIndex >= ccPriorities.Length()) {
                                                                                            UpdateCCStatus("Cannot move item down. Select an item first or item is already at bottom.")
                                                                                            return
                                                                                        }

                                                                                        ; Swap with next item
                                                                                        temp := ccPriorities[selectedIndex]
                                                                                        ccPriorities[selectedIndex] := ccPriorities[selectedIndex + 1]
                                                                                        ccPriorities[selectedIndex + 1] := temp

                                                                                        SaveCCPriorities()
                                                                                        RefreshCCPriorityList()

                                                                                        ; Reselect the moved item
                                                                                        GuiControl, Choose, CCPriorityList, % selectedIndex + 1

                                                                                        UpdateCCStatus("Moved CC skill down in priority.")
                                                                                    return

                                                                                    RefreshCCList:
                                                                                        RefreshCCPriorityList()
                                                                                        UpdateCCStatus("CC priority list refreshed.")
                                                                                    return

                                                                                    RemoveFromCCPriority:
                                                                                        ; Get the currently selected item index from the ListBox
                                                                                        GuiControlGet, selectedText, , CCPriorityList
                                                                                        selectedIndex := 0

                                                                                        ; Parse the index from the text (format: "1. SkillName")
                                                                                        if (selectedText != "") {
                                                                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                            selectedIndex := match1
                                                                                        }

                                                                                        if (selectedIndex <= 0 || selectedIndex > ccPriorities.Length()) {
                                                                                            UpdateCCStatus("Select a CC skill to remove from priority.")
                                                                                            return
                                                                                        }

                                                                                        removedSkill := ccPriorities[selectedIndex]
                                                                                        displayName := GetCCDisplayName(removedSkill)
                                                                                        ccPriorities.RemoveAt(selectedIndex)

                                                                                        SaveCCPriorities()
                                                                                        RefreshCCPriorityList()
                                                                                        UpdateCCStatus("Removed '" . displayName . "' from CC priority order (skill still saved).")
                                                                                    return

                                                                                    AddToCCPriority:
                                                                                        ; Show available CC skills not in priority
                                                                                        availableCC := "=== ADD CC SKILL TO PRIORITY ===`n`n"
                                                                                        availableCount := 0
                                                                                        availableSkills := []

                                                                                        for patternName, patternText in ccPatterns {
                                                                                            ; Check if already in priority
                                                                                            inPriority := false
                                                                                            for index, priorityPattern in ccPriorities {
                                                                                                if (priorityPattern = patternName) {
                                                                                                    inPriority := true
                                                                                                    break
                                                                                                }
                                                                                            }

                                                                                            if (!inPriority) {
                                                                                                availableCount++
                                                                                                availableSkills.Push(patternName)
                                                                                                displayName := GetCCDisplayName(patternName)
                                                                                                availableCC .= availableCount . ". " . displayName . " [" . patternName . "]`n"
                                                                                            }
                                                                                        }

                                                                                        if (availableCount = 0) {
                                                                                            UpdateCCStatus("No CC skills available to add (all are already in priority or none saved).")
                                                                                            return
                                                                                        }

                                                                                        availableCC .= "`nEnter the number of the CC skill to add to priority:"

                                                                                        InputBox, ccNumber, Add CC Skill to Priority, %availableCC%, , 400, 300
                                                                                        if (ErrorLevel)
                                                                                            return

                                                                                        if (ccNumber < 1 || ccNumber > availableCount) {
                                                                                            UpdateCCStatus("Invalid CC skill number selected.")
                                                                                            return
                                                                                        }

                                                                                        selectedSkill := availableSkills[ccNumber]
                                                                                        displayName := GetCCDisplayName(selectedSkill)

                                                                                        ; Add to end of priority list
                                                                                        ccPriorities.Push(selectedSkill)
                                                                                        SaveCCPriorities()
                                                                                        RefreshCCPriorityList()
                                                                                        UpdateCCStatus("Added '" . displayName . "' to CC priority order.")
                                                                                    return

                                                                                    ; ========= QWERTY TO QWERTZ CONVERSION =========
                                                                                    ; Function to convert QWERTY keys to QWERTZ keys
                                                                                    ConvertQwertyToQwertz(key) {
                                                                                        global qwertzModeEnabled

                                                                                        ; If QWERTZ mode is not enabled, return the original key
                                                                                        if (!qwertzModeEnabled)
                                                                                            return key

                                                                                        ; Define conversion map for QWERTY→QWERTZ
                                                                                        ; Letter swaps: Y↔Z
                                                                                        if (key = "y")
                                                                                            return "z"
                                                                                        else if (key = "Y")
                                                                                            return "Z"
                                                                                        else if (key = "z")
                                                                                            return "y"
                                                                                        else if (key = "Z")
                                                                                            return "Y"

                                                                                        ; Special character mappings (QWERTY → QWERTZ)
                                                                                        ; Note: These are the shifted/unshifted positions
                                                                                        else if (key = "-") ; QWERTY minus
                                                                                            return "ß" ; QWERTZ ß (sharp s)
                                                                                        else if (key = "=") ; QWERTY equals  
                                                                                            return "´" ; QWERTZ acute accent
                                                                                        else if (key = "[") ; QWERTY left bracket
                                                                                            return "ü" ; QWERTZ ü
                                                                                        else if (key = "]") ; QWERTY right bracket
                                                                                            return "+" ; QWERTZ plus
                                                                                        else if (key = ";")        ; QWERTY semicolon
                                                                                            return "ö" ; QWERTZ ö
                                                                                        else if (key = "'") ; QWERTY apostrophe
                                                                                            return "ä" ; QWERTZ ä
                                                                                        else if (key = "/") ; QWERTY forward slash
                                                                                            return "#" ; QWERTZ hash

                                                                                        ; Shifted special characters (when user types Shift+key)
                                                                                        else if (key = "_") ; QWERTY underscore (Shift+-)
                                                                                            return "?" ; QWERTZ question mark (Shift+ß)
                                                                                        else if (key = "{") ; QWERTY left brace (Shift+[)
                                                                                            return "Ü" ; QWERTZ Ü (Shift+ü)
                                                                                        else if (key = "}") ; QWERTY right brace (Shift+])
                                                                                            return "*" ; QWERTZ asterisk (Shift++)
                                                                                        else if (key = ":") ; QWERTY colon (Shift+;)
                                                                                            return "Ö" ; QWERTZ Ö (Shift+ö)

                                                                                        ; Return original key if no conversion needed
                                                                                    return key
                                                                                }

                                                                                ; Checkbox handler for QWERTZ mode
                                                                                qwertzmode:
                                                                                    Gui, Submit, NoHide
                                                                                    qwertzModeEnabled := qwertzmode
                                                                                    ; Save setting to INI file
                                                                                    IniWrite, %qwertzModeEnabled%, %iniFile%, Settings, QWERTZMode
                                                                                statusText := qwertzModeEnabled ? "QWERTZ key conversion enabled" : "QWERTZ key conversion disabled"
                                                                                    ToolTip, %statusText%, 100, 100
                                                                                    SetTimer, ClearToolTip, 2000
                                                                                return

                                                                                ClearToolTip:
                                                                                    ToolTip
                                                                                    SetTimer, ClearToolTip, Off
                                                                                return

                                                                                ; ========= SHARED FUNCTIONS =========
                                                                                CloseApp:
                                                                                    SetTimer, CheckExecutions, Off
                                                                                    SetTimer, CheckHealth, Off
                                                                                    SetTimer, DPSLoop, Off
                                                                                    ClearBoundingBoxes()
                                                                                ExitApp
                                                                                return

                                                                                CheckWindowExists:
                                                                                    ; Only check if at least one sequence is running
                                                                                    if (!IsRunning1 && !IsRunning2 && !IsRunning3)
                                                                                        return

                                                                                    ; Check if the target window still exists
                                                                                    IfWinNotExist, ahk_id %win1%
                                                                                    {
                                                                                        ; Window no longer exists, pause all running sequences
                                                                                        windowWasClosed := true

                                                                                        if (IsRunning1) {
                                                                                            IsRunning1 := false
                                                                                            GuiControl,, StartStop1, Start1
                                                                                            GuiControl,, CountdownText1, Next: --
                                                                                            UpdateStatus1("Window closed - paused")
                                                                                        }
                                                                                        if (IsRunning2) {
                                                                                            IsRunning2 := false
                                                                                            GuiControl,, StartStop2, Start2
                                                                                            GuiControl,, CountdownText2, Next: --
                                                                                            UpdateStatus2("Window closed - paused")
                                                                                        }
                                                                                        if (IsRunning3) {
                                                                                            IsRunning3 := false
                                                                                            GuiControl,, StartStop3, Start3
                                                                                            GuiControl,, CountdownText3, Next: --
                                                                                            UpdateStatus3("Window closed - paused")
                                                                                        }

                                                                                        ; Stop the main execution timer
                                                                                        SetTimer, CheckExecutions, Off

                                                                                        ; Show notification
                                                                                        TrayTip, Window Monitor, Target window was closed. All sequences paused., 5, 2
                                                                                    }
                                                                                return

                                                                                ; Add this function to start the window monitoring timer
                                                                                StartWindowMonitoring() {
                                                                                    SetTimer, CheckWindowExists, 2000 ; Check every 2 seconds
                                                                                }

                                                                                ; Add this function to stop the window monitoring timer
                                                                                StopWindowMonitoring() {
                                                                                    SetTimer, CheckWindowExists, Off
                                                                                }
                                                                                ; Hotkeys for script control

                                                                                ; ========= TEMPLAR FUNCTIONS =========
                                                                                ; ValidateTemplarTargetCount:
                                                                                ;     Gui, Submit, NoHide
                                                                                ;     if (TemplarTargetCountEdit < 1)
                                                                                ;     {
                                                                                ;         TemplarTargetCountEdit := 1
                                                                                ;         GuiControl,, TemplarTargetCountEdit, 1
                                                                                ;     }
                                                                                ;     else if (TemplarTargetCountEdit > 20)
                                                                                ;     {
                                                                                ;         TemplarTargetCountEdit := 20
                                                                                ;         GuiControl,, TemplarTargetCountEdit, 20
                                                                                ;     }
                                                                                ;     TemplarTargetCount := TemplarTargetCountEdit
                                                                                ; return

                                                                                ; SetTemplarPoints:
                                                                                ;     Gui, Submit, NoHide
                                                                                ;     TemplarTargetCount := TemplarTargetCountEdit

                                                                                ;     if (win2 = "") {
                                                                                ;         UpdateTemplarStatus("Please select Templar window first.")
                                                                                ;         return
                                                                                ;     }

                                                                                ;     ; Clear existing coordinates
                                                                                ;     TemplarTargetCoords := []

                                                                                ;     ; Hide GUI temporarily
                                                                                ;     Gui, Hide

                                                                                ;     MsgBox, 4, Set Templar Points, Click OK then Right-click on %TemplarTargetCount% target locations.`n`nPress ESC to cancel.
                                                                                ;     IfMsgBox No
                                                                                ;     {
                                                                                ;         Gui, Show
                                                                                ;         return
                                                                                ;     }

                                                                                ;     ; Capture coordinates for each target
                                                                                ;     Loop, %TemplarTargetCount% {
                                                                                ;         currentTarget := A_Index
                                                                                ;         ToolTip, Left-click on Target %currentTarget% of %TemplarTargetCount%, 100, 100

                                                                                ;         ; Wait for left click
                                                                                ;         KeyWait, rButton, D
                                                                                ;         MouseGetPos, TargetX, TargetY

                                                                                ;         ; Store coordinates
                                                                                ;         TemplarTargetCoords.Push({X: TargetX, Y: TargetY})

                                                                                ;         KeyWait, rButton
                                                                                ;         Sleep, 200
                                                                                ;     }

                                                                                ;     ToolTip

                                                                                ;     ; Show summary
                                                                                ;     summaryText := "Captured " . TemplarTargetCount . " target points:`n`n"
                                                                                ;     For index, coords in TemplarTargetCoords {
                                                                                ;         summaryText .= "Target " . index . ": (" . coords.X . ", " . coords.Y . ")`n"
                                                                                ;     }

                                                                                ;     MsgBox, 64, Points Captured, %summaryText%

                                                                                ;     ; Show GUI again
                                                                                ;     Gui, Show

                                                                                ;     UpdateTemplarStatus("Captured " . TemplarTargetCount . " target coordinates successfully.")
                                                                                ; return

                                                                                ; SaveHolygroundHotkey:
                                                                                ;     SaveTemplarSettings()
                                                                                ;     UpdateTemplarStatus("Templar settings saved to INI")
                                                                                ; return

                                                                                ; StartTemplarScript:
                                                                                ;     if (win2 = "") {
                                                                                ;         UpdateTemplarStatus("Please select Templar window first.")
                                                                                ;         return
                                                                                ;     }

                                                                                ;     if (TemplarTargetCoords.Length() = 0) {
                                                                                ;         UpdateTemplarStatus("Please set target points first.")
                                                                                ;         return
                                                                                ;     }

                                                                                ;     if (HolygroundHotkey = "") {
                                                                                ;         UpdateTemplarStatus("Please set Holyground hotkey first.")
                                                                                ;         return
                                                                                ;     }

                                                                                ;     ; Start the Templar script
                                                                                ;     SetTimer, TemplarLoop, 100
                                                                                ;     UpdateTemplarStatus("Templar script started - clicking targets and casting Holyground")
                                                                                ; return

                                                                                ; StopTemplarScript:
                                                                                ;     SetTimer, TemplarLoop, Off
                                                                                ;     UpdateTemplarStatus("Templar script stopped.")
                                                                                ; return

                                                                                ; SendHolygroundHotkey() {
                                                                                ;     global HolygroundHotkey, win2

                                                                                ;     if (HolygroundHotkey = "" || win2 = "")
                                                                                ;         return

                                                                                ;     ; Check for modifier keys and handle them separately
                                                                                ;     hasCtrl := InStr(HolygroundHotkey, "^")
                                                                                ;     hasAlt := InStr(HolygroundHotkey, "!")
                                                                                ;     hasShift := InStr(HolygroundHotkey, "+")

                                                                                ;     ; Extract the base key (remove modifiers)
                                                                                ;     baseKey := HolygroundHotkey
                                                                                ;     if (hasCtrl)
                                                                                ;         baseKey := StrReplace(baseKey, "^", "")
                                                                                ;     if (hasAlt)
                                                                                ;         baseKey := StrReplace(baseKey, "!", "")
                                                                                ;     if (hasShift)
                                                                                ;         baseKey := StrReplace(baseKey, "+", "")

                                                                                ;     ; Send modifier keys down
                                                                                ;     if (hasCtrl)
                                                                                ;         ControlSend, , {Ctrl down}, ahk_id %win1%
                                                                                ;     if (hasAlt)
                                                                                ;         ControlSend, , {Alt down}, ahk_id %win1%
                                                                                ;     if (hasShift)
                                                                                ;         ControlSend, , {Shift down}, ahk_id %win1%

                                                                                ;     ; Send the base key
                                                                                ;     ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                                                ;     Sleep, 50
                                                                                ;     ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                                                ;     ; Send modifier keys up (in reverse order)
                                                                                ;     if (hasShift)
                                                                                ;         ControlSend, , {Shift up}, ahk_id %win1%
                                                                                ;     if (hasAlt)
                                                                                ;         ControlSend, , {Alt up}, ahk_id %win1%
                                                                                ;     if (hasCtrl)
                                                                                ;         ControlSend, , {Ctrl up}, ahk_id %win1%
                                                                                ; }

                                                                                ; UpdateTemplarStatus(message) {
                                                                                ;     global

                                                                                ;     ; Get current time
                                                                                ;     FormatTime, timeStamp,, HH:mm:ss

                                                                                ;     ; Add timestamp to message
                                                                                ;     newMessage := "[" . timeStamp . "] " . message . "`r`n"

                                                                                ;     ; Get current content and add new message
                                                                                ;     GuiControlGet, currentContent, , TemplarStatusEdit
                                                                                ;     if (currentContent != "") {
                                                                                ;         newContent := currentContent . newMessage
                                                                                ;     } else {
                                                                                ;         newContent := newMessage
                                                                                ;     }

                                                                                ;     ; Keep only the last 15 lines to prevent overflow
                                                                                ;     lines := StrSplit(newContent, "`r`n")
                                                                                ;     if (lines.Length() > 15) {
                                                                                ;         newContent := ""
                                                                                ;         Loop % Min(15, lines.Length()) {
                                                                                ;             if (lines[lines.Length() - 15 + A_Index] != "") {
                                                                                ;                 newContent .= lines[lines.Length() - 15 + A_Index] . "`r`n"
                                                                                ;             }
                                                                                ;         }
                                                                                ;     }

                                                                                ;     ; Update the GUI control
                                                                                ;     GuiControl,, TemplarStatusEdit, %newContent%
                                                                                ; }

                                                                                ; SaveTemplarSettings() {
                                                                                ;     global iniFile, HolygroundHotkey, RandomXVariation, RandomYVariation, MinDelay, MaxDelay

                                                                                ;     Gui, Submit, NoHide
                                                                                ;     RandomXVariation := RandomXVariationEdit
                                                                                ;     RandomYVariation := RandomYVariationEdit
                                                                                ;     MinDelay := MinDelayEdit
                                                                                ;     MaxDelay := MaxDelayEdit

                                                                                ;     ; Validate that min is not greater than max
                                                                                ;     if (MinDelay > MaxDelay) {
                                                                                ;         temp := MinDelay
                                                                                ;         MinDelay := MaxDelay
                                                                                ;         MaxDelay := temp
                                                                                ;         GuiControl,, MinDelayEdit, %MinDelay%
                                                                                ;         GuiControl,, MaxDelayEdit, %MaxDelay%
                                                                                ;         UpdateTemplarStatus("Swapped min/max delay values (min was greater than max)")
                                                                                ;     }

                                                                                ;     FileEncoding, UTF-8
                                                                                ;     IniWrite, %HolygroundHotkey%, %iniFile%, TemplarSettings, HolygroundHotkey
                                                                                ;     IniWrite, %RandomXVariation%, %iniFile%, TemplarSettings, RandomXVariation
                                                                                ;     IniWrite, %RandomYVariation%, %iniFile%, TemplarSettings, RandomYVariation
                                                                                ;     IniWrite, %MinDelay%, %iniFile%, TemplarSettings, MinDelay
                                                                                ;     IniWrite, %MaxDelay%, %iniFile%, TemplarSettings, MaxDelay
                                                                                ;     FileEncoding
                                                                                ; }

                                                                                ; LoadTemplarSettings() {
                                                                                ;     global iniFile, HolygroundHotkey, RandomXVariation, RandomYVariation, MinDelay, MaxDelay

                                                                                ;     IniRead, loadedHotkey, %iniFile%, TemplarSettings, HolygroundHotkey, %A_Space%
                                                                                ;     if (loadedHotkey != "ERROR" && loadedHotkey != "") {
                                                                                ;         HolygroundHotkey := loadedHotkey
                                                                                ;         GuiControl,, HolygroundHotkeyEdit, %HolygroundHotkey%
                                                                                ;     }

                                                                                ;     IniRead, loadedXVar, %iniFile%, TemplarSettings, RandomXVariation, 5
                                                                                ;     if (loadedXVar != "ERROR") {
                                                                                ;         RandomXVariation := loadedXVar
                                                                                ;         GuiControl,, RandomXVariationEdit, %RandomXVariation%
                                                                                ;     }

                                                                                ;     IniRead, loadedYVar, %iniFile%, TemplarSettings, RandomYVariation, 5
                                                                                ;     if (loadedYVar != "ERROR") {
                                                                                ;         RandomYVariation := loadedYVar
                                                                                ;         GuiControl,, RandomYVariationEdit, %RandomYVariation%
                                                                                ;     }

                                                                                ;     IniRead, loadedMinDelay, %iniFile%, TemplarSettings, MinDelay, 80
                                                                                ;     if (loadedMinDelay != "ERROR") {
                                                                                ;         MinDelay := loadedMinDelay
                                                                                ;         GuiControl,, MinDelayEdit, %MinDelay%
                                                                                ;     }

                                                                                ;     IniRead, loadedMaxDelay, %iniFile%, TemplarSettings, MaxDelay, 150
                                                                                ;     if (loadedMaxDelay != "ERROR") {
                                                                                ;         MaxDelay := loadedMaxDelay
                                                                                ;         GuiControl,, MaxDelayEdit, %MaxDelay%
                                                                                ;     }
                                                                                ; }

                                                                                ; TemplarLoop:
                                                                                ;     ; Check if window still exists
                                                                                ;     IfWinNotExist, ahk_id %win2%
                                                                                ;     {
                                                                                ;         UpdateTemplarStatus("Templar window closed - stopping script")
                                                                                ;         SetTimer, TemplarLoop, Off
                                                                                ;         return
                                                                                ;     }

                                                                                ;     ; Get current settings from GUI
                                                                                ;     Gui, Submit, NoHide
                                                                                ;     currentXVar := RandomXVariationEdit
                                                                                ;     currentYVar := RandomYVariationEdit
                                                                                ;     currentMinDelay := MinDelayEdit
                                                                                ;     currentMaxDelay := MaxDelayEdit

                                                                                ;     ; Validate delay values
                                                                                ;     if (currentMinDelay > currentMaxDelay) {
                                                                                ;         temp := currentMinDelay
                                                                                ;         currentMinDelay := currentMaxDelay
                                                                                ;         currentMaxDelay := temp
                                                                                ;     }

                                                                                ;     ; Activate the window first
                                                                                ;     WinActivate, ahk_id %win2%
                                                                                ;     Random, activateDelay, 20, 50
                                                                                ;     Sleep, %activateDelay%

                                                                                ;     ; Click on each target and cast Holyground
                                                                                ;     For index, coords in TemplarTargetCoords {
                                                                                ;         ; Extract base coordinates
                                                                                ;         baseX := coords.X
                                                                                ;         baseY := coords.Y

                                                                                ;         ; Add random variation
                                                                                ;         Random, xOffset, -%currentXVar%, %currentXVar%
                                                                                ;         Random, yOffset, -%currentYVar%, %currentYVar%

                                                                                ;         targetX := baseX + xOffset
                                                                                ;         targetY := baseY + yOffset
                                                                                ;         ; Random delay between click and spell cast
                                                                                ;         Random, clickDelay, 30, 80
                                                                                ;         ; Cast Holyground using the hotkey
                                                                                ;         SendHolygroundHotkey()
                                                                                ;         ; Move mouse to randomized target location and click
                                                                                ;         MouseMove, %targetX%, %targetY%, 0
                                                                                ;         Sleep, %clickDelay%
                                                                                ;         Click

                                                                                ;         ; Use the custom random delay range
                                                                                ;         Random, targetDelay, %currentMinDelay%, %currentMaxDelay%
                                                                                ;         Sleep, %targetDelay%
                                                                                ;     }
                                                                                ; return

                                                                                capchacheck:
                                                                                    {

                                                                                        confirm:="|<highlighted>DCEAFC-323232$33.D00o0200400ESxpjw2IYd8UUUZ92444d8EGUZ91vo4d8U"
                                                                                        confirm.="|<>DFE4E8-323232$32.S01c0800E023rihz0Z9+G0EEGYW444d8UZ1+G7jEGYW"
                                                                                        confirm.="|<>D3D8DE-323232$41.DU01800k006001000A0020wyxRzs214Wm8k0294YEE04288UU084EF100E8UW1wwUF148"

                                                                                        capchaguardactivatedmessage:="|<>FD4039-323232$97.000E000000000000020800Ak000U00E001040080000E00801Rtmts414wds7XbEKWF14220W1F40+2+9E80U100F0c204150cI0E8UUcYI10W0W4o2080EEIE+0U10F8+944284+954E8c8aBsNm1o1souVc7HXF4U000000000000000E000000000000000U"
                                                                                        capchaguardactivatedmessage.="|<>E22E2F-323232$70.0001000000040104006M000E040E00U0001wywxww20WSIw+944E882854FcIEF1UXcUoFmVE14m22WNE6+544G88+954McYEF8UkcYIFuwAt4u0wSREw20000000000080000000000U"
                                                                                        capchaguardactivatedmessage.="|<>E63C37-0.90$69.000000E0000200020200000U000E0E000001wTbXnwT0E100G4EUEU420802E20240U0100G2E0E0A20c0WEG020EUE5U0G0E0E0420g02EW4200U8504G000E2400000E0000000000200000000000E00000000U"

                                                                                        capcha:="|<>*62$43.szzzzjzs7zxzrztzzyzvzxy224460zxQiyvwTsiKTQsDkL/DiELnfZbr3dtZqvvVa22365m3zzTzzzzzzjzzzzzzrzzzzk"
                                                                                        capchaguardtargetted:="|<>FFFFFF-323232$71.C00002000w00W002040024022004080084040QKQQK70E14M14mF4mF0U29E094W14217YEU3m9428w218X18YG84G842F94HAYF8Yk48WFkOKAQF6U7UwE00U00000000001000000000002000000001"
                                                                                        capchaconfirm:="|<>DFE3E9-323232$33.D00o0200400ESxpjw2IYd8UUUZ92444d8EGUZ91vo4d8U"
                                                                                        capchaquestionwindowopen:="|<>FFFFFF-323232$37.C00000cU0000M8sgACA0WN98a018Y4H07YG3tUYG910cWN4YWHUoWACA"
                                                                                        if (FindText(X, Y, 0, 0, 1919, 1030, 0, 0, capchaguardactivatedmessage, , 0))
                                                                                        {
                                                                                            sleep, 50
                                                                                            ;MsgBox, found message
                                                                                            Loop,
                                                                                            {
                                                                                                ;MsgBox, looping
                                                                                                (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, confirm))
                                                                                                {
                                                                                                    ;Critical, on
                                                                                                    ;WinActivate, ahk_id %win1%                   
                                                                                                    ; settimer, DPSLoop, off
                                                                                                    ; SetTimer, essences, off
                                                                                                    ; SetTimer, buffdaddystone, off
                                                                                                    ;  SetTimer, buffpetscroll, off
                                                                                                    settimer, checkweight, off
                                                                                                    ; SetTimer, snapshot, off
                                                                                                    sleep, 100
                                                                                                    ControlClick, x%AX% y%AY%, ahk_id %win1%,, Left, 1

                                                                                                    if (!ok:=FindText(X, Y, 0, 0, 1919, 1030, 0, 0, capchaguardactivatedmessage, , 0))
                                                                                                    {
                                                                                                        break
                                                                                                    }
                                                                                                }

                                                                                            }

                                                                                            Gosub, PylonClicker
                                                                                            return
                                                                                        }
                                                                                        ;MsgBox, returned
                                                                                        return
                                                                                    }

                                                                                PylonClicker:
                                                                                    ; Click the pylon location once per second
                                                                                    sleep, 750
                                                                                    Loop, {

                                                                                        ; Check for any question patterns
                                                                                        ht:="|<>FBFF47-323232$20.TU0zw0Tb0T1k7lw1gT031k0kAwDXD3tk0zw0By03U"
                                                                                        ht.="|<>FFFF00-323232$20.TU0zw0Tb0T1k7lw1gT031k0kAwDXD3tk0zw0By03U"
                                                                                        ht.="|<>FFFF00-323232$25.600z700zzUMQzkAADM60CATs76DwD30kD1UMD0kA70M07yA03zU"
                                                                                        ht.="|<>FFFF00-323232$20.TU0zw0Tb0Tkk7kQ1g7037U0nkwBsD3Q00zw0Dz03U"
                                                                                        ht.="|<>FBFF47-0.90$26.TU03jw00vb30Skkk7UQA3s7Ttq7byNXkACNs33zQ0kzzw00Pz006U"
                                                                                        ht.="|<>FFFF00-323232$26.TU03jw00vb30Skkk7UQA3s7Ttq7byNXkACNs33zQ0kzzw00Pz006U"
                                                                                        ht.="|<>FFFF00-323232$26.TU0Tjw0Dzb33bkkkkkQA0Q7Ts77by7XkA3ls31sQ0kQDw0Dzz03zU"
                                                                                        ht.="|<>FFFF00-323232$26.3U0TUs0DwS33b7Uk1nsA1xqTsTNby1yMA0Dz33XzkktkM0Dw601yU"
                                                                                        ht.="|<>FBFF47-323232$26.3U0TUs0DwS33b7Uk1nsA1xqTsTNby1yMA0Dz33XzkktkM0Dw601yU"
                                                                                        ht.="|<>FFFF00-323232$70.llk1U001zX03Db060007zA0AyQ0M000MQ00vvbvtwT1UnQTjizjjtw67AviqviMvbETwlwTTXtXyQ1zX7lxwzaDtU60AC7rnyMk60M0lwTTCtXiM1U37ksszrjtU60AvXXVzST60M0r7U"
                                                                                        ht.="|<>FFFF00-323232$26.kC0My706BnU1UQtwynwzjgSCtX7XyMkkzaAAA1X33iMkkzbgA7lvU"
                                                                                        ht.="|<>FFFF00-323232$25.Dk00Dw00DD0073bnzVnvzUNprkAskM6MMC7AA7ba7RzX3yTVUyU"
                                                                                        ht.="|<>FFFF00-323232$65.TlU01U0k001zn00301U003ba0060300077AwyATDbszjUPnyNzTTtzjsz7QniMtnrDtwDtbwlnb63nwTnDtX3ADVbsk6M37CMTbAtrAvaCQkzyNnyNzDTtVjslnslwSTX3U"
                                                                                        ht.="|<>FBFF47-323232$63.Dk060000003z00k000000ww0600000073Xxwz7wMMysQzjjwzn3Dy1bQlnbCMNrkAk6CQtn3Da1a0lVa6MNzsQk6CQtn73zbbQlnbCRtrTszbjwznzDty3swz7wDsy000000k00000000060000000000k0004"
                                                                                        ht.="|<>FFFF00-323232$63.Dk060000003z00k000000ww0600000073Xxwz7wMMysQzjjwzn3Dy1bQlnbCMNrkAk6CQtn3Da1a0lVa6MNzsQk6CQtn73zbbQlnbCRtrTszbjwznzDty3swz7wDsy000000k00000000060000000000k0004"
                                                                                        ht.="|<>FBFF47-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U"
                                                                                        ht.="|<>FFFF00-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U"
                                                                                        ht.="|<>FFFF00-323232$19.wC7yDXw7kS3MD3i7Vr3llVszswTwSQ7DC3bb1nk01y03z01w"
                                                                                        ht.="|<>FFFF00-323232$20.xzXzTwz673lUkwMQD7z3lzswMSD61XlUswTyD7z3k00z00zk0DU"
                                                                                        ht.="|<>FBFF47-323232$20.xzXzTwz67XlUswMCD61XlUMwMCD63XlVswTwD7y3k00z00zk0DU"
                                                                                        ht.="|<>FFFF00-323232$21.xzXrjySlVsqA76lUsqA36lUMqA76lUsqAD6lzkqDw6k00rU0Sw03o"
                                                                                        ht.="|<>FFFF00-323232$20.wTnzDyz7bXlkswQ0D603lU0wQ0D73XltswDyD1z3k00z00zk0DU"

                                                                                        ; Check if any question pattern is found
                                                                                        if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, ht)) {

                                                                                            ; Stop clicking and solve captcha

                                                                                            SolveCaptcha()
                                                                                            ; Restart clicking after solving
                                                                                            return
                                                                                        } else {
                                                                                            ; Convert window-relative coordinates to screen coordinates
                                                                                            WinGetPos, winX, winY,,, ahk_id %win1%
                                                                                            screenPylonX := winX + pylonX
                                                                                            screenPylonY := winY + pylonY
                                                                                            ControlClick, x%pylonX% y%pylonY%, ahk_id %win1%,, Left, 1
                                                                                        }
                                                                                        sleep, 1000
                                                                                    }
                                                                                Return

                                                                                SolveCaptcha() {
                                                                                    ; Define all patterns
                                                                                    capchaguardtargetted := "|<>FFFFFF-323232$71.C00002000w00W002040024022004080084040QKQQK70E14M14mF4mF0U29E094W14217YEU3m9428w218X18YG84G842F94HAYF8Yk48WFkOKAQF6U7UwE00U00000000001000000000002000000001"

                                                                                    ; Question patterns
                                                                                    threeminusone := "|<>FBFF47-323232$20.TU0zw0Tb0T1k7lw1gT031k0kAwDXD3tk0zw0By03U|<>FFFF00-323232$20.TU0zw0Tb0T1k7lw1gT031k0kAwDXD3tk0zw0By03U"
                                                                                    oneplustwo := "|<>FFFF00-323232$25.600z700zzUMQzkAADM60CATs76DwD30kD1UMD0kA70M07yA03zU"
                                                                                    twominusone := "|<>FFFF00-323232$20.TU0zw0Tb0Tkk7kQ1g7037U0nkwBsD3Q00zw0Dz03U"
                                                                                    twoplustwo := "|<>FFFF00-323232$26.TU0Tjw0Dzb33bkkkkkQA0Q7Ts77by7XkA3ls31sQ0kQDw0Dzz03zU"
                                                                                    fourplustwo := "|<>FBFF47-0.90$26.TU03jw00vb30Skkk7UQA3s7Ttq7byNXkACNs33zQ0kzzw00Pz006U|<>FFFF00-323232$26.TU03jw00vb30Skkk7UQA3s7Ttq7byNXkACNs33zQ0kzzw00Pz006U"
                                                                                    fourplusthree := "|<>FFFF00-323232$26.3U0TUs0DwS33b7Uk1nsA1xqTsTNby1yMA0Dz33XzkktkM0Dw601yU|<>FBFF47-323232$26.3U0TUs0DwS33b7Uk1nsA1xqTsTNby1yMA0Dz33XzkktkM0Dw601yU"

                                                                                    ; Press X patterns (monsters/letters)
                                                                                    presswaterpixie := "|<>FFFF00-323232$70.llk1U001zX03Db060007zA0AyQ0M000MQ00vvbvtwT1UnQTjizjjtw67AviqviMvbETwlwTTXtXyQ1zX7lxwzaDtU60AC7rnyMk60M0lwTTCtXiM1U37ksszrjtU60AvXXVzST60M0r7U"
                                                                                    pressyeti := "|<>FFFF00-323232$26.kC0My706BnU1UQtwynwzjgSCtX7XyMkkzaAAA1X33iMkkzbgA7lvU"
                                                                                    pressorc := "|<>FFFF00-323232$25.Dk00Dw00DD0073bnzVnvzUNprkAskM6MMC7AA7ba7RzX3yTVUyU"
                                                                                    pressskeleton := "|<>FFFF00-323232$65.TlU01U0k001zn00301U003ba0060300077AwyATDbszjUPnyNzTTtzjsz7QniMtnrDtwDtbwlnb63nwTnDtX3ADVbsk6M37CMTbAtrAvaCQkzyNnyNzDTtVjslnslwSTX3U"
                                                                                    pressoctopus := "|<>FBFF47-323232$63.Dk060000003z00k000000ww0600000073Xxwz7wMMysQzjjwzn3Dy1bQlnbCMNrkAk6CQtn3Da1a0lVa6MNzsQk6CQtn73zbbQlnbCRtrTszbjwznzDty3swz7wDsy000000k00000000060000000000k0004|<>FFFF00-323232$63.Dk060000003z00k000000ww0600000073Xxwz7wMMysQzjjwzn3Dy1bQlnbCMNrkAk6CQtn3Da1a0lVa6MNzsQk6CQtn73zbbQlnbCRtrTszbjwznzDty3swz7wDsy000000k00000000060000000000k0004"
                                                                                    presssiren := "|<>FBFF47-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U|<>FFFF00-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U"
                                                                                    pressA := "|<>FFFF00-323232$19.wC7yDXw7kS3MD3i7Vr3llVszswTwSQ7DC3bb1nk01y03z01w"
                                                                                    pressB := "|<>FFFF00-323232$20.xzXzTwz673lUkwMQD7z3lzswMSD61XlUswTyD7z3k00z00zk0DU"
                                                                                    pressC := "|<>FFFF00-323232$20.wTnzDyz7bXlkswQ0D603lU0wQ0D73XltswDyD1z3k00z00zk0DU"
                                                                                    pressD := "|<>FBFF47-323232$20.xzXzTwz67XlUswMCD61XlUMwMCD63XlVswTwD7y3k00z00zk0DU|<>FFFF00-323232$21.xzXrjySlVsqA76lUsqA36lUMqA76lUsqAD6lzkqDw6k00rU0Sw03o"

                                                                                    ; Answer patterns
                                                                                    one := "|<>FFFFFF-323232$5.6TzxX6AMlXU|<>FFFFFF-323232$4.4zwF4F6"
                                                                                    two := "|<>FFFFFF-323232$8.TjzbkkQ77XlsQDzzU"
                                                                                    three := "|<>FFFFFF-323232$8.TjzbFlwT1kDXtzxyU"
                                                                                    four := "|<>FFFFFF-323232$8.3UsS7XtqNiPzzkM6U"
                                                                                    six := "|<>FFFFFF-323232$8.DbzrsDvztwD3xrwyU"
                                                                                    seven := "|<>FFFFFF-323232$8.zzw73VkQ73UsC30kU"
                                                                                    waterpixie := "|<>FFFFFF-323232$88.sQC0A0001zX01U3Xss0k0007zA060CDXU30000MQ0000QyQzT7ly1UnQRXtrxrxwzbs67AvaTrRrRn3iQUTwlwNrBrQTADtk1zX7lbwyDbwkza060AC6TnsyTn30M0M0lwNUDXtrACtU1U37lbQQ77ywza060AvaTlkQDvlwM0M0r7MyU"
                                                                                    yeti := "|<>FFFFFF-323232$27.kC0MT3U33Qs0M3bDbnDnyyMwRn37XyMMMTn3330MMMRn333ySMMDXnU"
                                                                                    orc := "|<>FFFFFF-323232$27.Ds003zU00wS0071nwys6Tjy0nZrk6QA70n1UsCMA7Xn1rTwMDtz30yU"
                                                                                    skeleton := "|<>FFFFFF-323232$66.TlU01U0k000ztU01U0k000xtU01U0k000stbblXtwTXyy1jDtbxwznzTlyCtbQktnrDtyDtbwktnX1tyDtbwkkn3sNyA1a0ktn3wtbCtbQktn3ztbDtbwwzn3TlXblXswTX3U"
                                                                                    octopus := "|<>FFFFFF-323232$65.Ds030000000zs060000003ls0A00000071lwyDlz66Di1bxwznzAAzs3CtVnbCMNrk6M33bCQkntkAk666MNVbzUtUACQtn73zXniMQtnbSRrz7wwznzDwzbw7lsz7wDsy000000A0000000000M0000000000k0004"
                                                                                    siren := "|<>FFFFFF-323232$39.TlU0007zA0000xs000077AzDXyy1bvyTvyAtRnrDtb3yQMDAkTn3sNa30MTbAkRn3zta3yMPyAkDX3U|<>FBFF47-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U"
                                                                                    A := "|<>FFFFFF-323232$11.3UDUT0q3i7QQMztzr1y3w7U"
                                                                                    B := "|<>FFFFFF-323232$10.znzgCkP3jyzz1w3kTzzyU"
                                                                                    C := "|<>FFFFFF-323232$10.DtzzDsTUA0k3UC7wxznyU"
                                                                                    Dee := "|<>FFFFFF-323232$10.znzgDkT1w3kD1w7kzzjwU|<>FFFFFF-0.90$10.znzgDkT1w3kD1w7kzzjwU"

                                                                                    ; Question-Answer pairs: [question_pattern, answer_pattern]
                                                                                    captchaMap := [ {q: threeminusone, a: two}
                                                                                    , {q: oneplustwo, a: three}
                                                                                    , {q: twominusone, a: one}
                                                                                    , {q: twoplustwo, a: four}
                                                                                    , {q: fourplustwo, a: six}
                                                                                    , {q: fourplusthree, a: seven}
                                                                                    , {q: presswaterpixie, a: waterpixie}
                                                                                    , {q: pressyeti, a: yeti}
                                                                                    , {q: pressorc, a: orc}
                                                                                    , {q: pressskeleton, a: skeleton}
                                                                                    , {q: pressoctopus, a: octopus}
                                                                                    , {q: presssiren, a: siren}
                                                                                    , {q: pressA, a: A}
                                                                                    , {q: pressB, a: B}
                                                                                    , {q: pressC, a: C}
                                                                                    , {q: pressD, a: Dee} ]

                                                                                    Loop, 4 {
                                                                                        for index, pair in captchaMap {
                                                                                            if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, pair.q)) {
                                                                                                ; Loop click until answer image not found
                                                                                                Loop {
                                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, pair.a)) {
                                                                                                        Sleep, 100
                                                                                                        ControlClick, x%AX% y%AY%, ahk_id %win1%,, Left, 1
                                                                                                        Sleep, 250
                                                                                                    } else {
                                                                                                        break
                                                                                                    }
                                                                                                }
                                                                                                SetTimer, checkweight, On
                                                                                                Sleep, 200
                                                                                                return
                                                                                            }
                                                                                        }
                                                                                        Gosub, PylonClicker
                                                                                    }
                                                                                return
                                                                            }
                                                                            essences:
                                                                                sleep 250
                                                                                ControlSend ,, {6}, ahk_id %win1%
                                                                                sleep 250
                                                                                ControlSend ,, {6}, ahk_id %win1%
                                                                                sleep, 250 sleep, 250

                                                                                ControlSend ,, {7}, ahk_id %win1%
                                                                                sleep, 250
                                                                                ControlSend ,, {6}, ahk_id %win2%
                                                                                sleep, 250
                                                                                ControlSend ,, {7}, ahk_id %win2%
                                                                                sleep, 250
                                                                                ControlSend ,, {8}, ahk_id %win2%
                                                                            Return
                                                                            buffdaddystone:
                                                                                ;WinActivate, ahk_id %win1%  
                                                                                buffdaddy:="|<>#273@0.83$26.080008000A00400PU000C0U3zkh7zy/VyTX0Tzs07zy03No00Kx007zkA3zs10Tq037u00Fi40UC0084S441GE2"
                                                                                buffdaddy.="|<>*126$29.zy07zzUQ3zyAtkzl0Vtz07sNw0zykt7zzJaTzzy/zUyQ3w00k7k00U70000S0000y0005s003rk00bjU007zU023z0047Q008ww00tVs01s"

                                                                                if (buffdaddyok:=FindText(buffdaddyX, buffdaddyY, 0, 0, 1919, 1030, 0, 0, buffdaddy))
                                                                                {
                                                                                    ControlClick, x%buffdaddyX% y%buffdaddyY%, ahk_id %win1%,, Left, 1
                                                                                }
                                                                                sleep, 150
                                                                                refreshscroll:="|<>*140$23.zzVhzsM3z707s00CA00U001M0S51so8ATt8kDVns806DM0A0k0M3U2"

                                                                                if (brefreshscrollok:=FindText(refreshscrollX, refreshscrollY, 0, 0, 1919, 1030, 0, 0, refreshscroll))
                                                                                {
                                                                                    ControlClick, x%refreshscrollX% y%refreshscrollY%, ahk_id %win1%,, Left, 1
                                                                                }
                                                                                sleep, 150
                                                                                windpotionlvl5:="|<>*149$20.yzvpk3zvzzzTzyU1zw0Ty03z00zk07w00s"
                                                                                if (windpotionlvl5ok:=FindText(windpotionlvl5X, windpotionlvl5Y, 0, 0, 1919, 1030, 0, 0, windpotionlvl5))
                                                                                {
                                                                                    ControlClick, x%windpotionlvl5X% y%windpotionlvl5Y%, ahk_id %win1%,, Left, 1
                                                                                }
                                                                            return
                                                                            buffpetscroll:
                                                                                ;WinActivate, ahk_id %win1%  
                                                                                refreshscroll:="|<>*140$23.zzVhzsM3z707s00CA00U001M0S51so8ATt8kDVns806DM0A0k0M3U2"
                                                                                if (brefreshscroll2ok:=FindText(refreshscroll2X, refreshscroll2Y, 0, 0, 1919, 1030, 0, 0, refreshscroll))
                                                                                {
                                                                                    ControlClick, x%refreshscroll2X% y%refreshscroll2Y%, ahk_id %win1%,, Left, 1
                                                                                }
                                                                                sleep, 150
                                                                            return
                                                                            sellitems:

                                                                                sellscroll:="|<>#47@0.83$7.2DcYG8YD1FUE8h7E"
                                                                                sellscroll.="|<>*133$27.zzzzzzzzzzzzs7zzsDzzkzzzkq0zkE07ss01w800oM01z0M0AQDk00290I0F018280E0D0010w0003M000N00M34062N008/M070Q070107L007uw"
                                                                                sellscroll.="|<>*141$29.zzzzzzzzU3zzwDjzwTzjz3M0Tkk00yC00RkU070Q01z06037kz083W90Ic4E0G08U3UQD009sD0000BU0GUNU0T0l03U9Y0My"

                                                                                if (sellscrollok:=FindText(sellscrollX, sellscrollY, 0, 0, 1919, 1030, 0, 0, sellscroll))
                                                                                {
                                                                                    ;ToolTip, found scroll
                                                                                    ;WinActivate, ahk_id %win1%  
                                                                                    ;sleep, 1000
                                                                                    ControlClick, x%sellscrollX% y%sellscrollY%, ahk_id %win1%,, Left, 1
                                                                                    sleep, 2000
                                                                                    Loop,
                                                                                    {
                                                                                        sellbutton:="|<>#75@0.83$16.V01800biAG0Hu1824E4Fvc"
                                                                                        sellbutton.="|<>#74@0.83$16.l01A06bjAnUnv1A74k4Fzc"
                                                                                        if (sellbuttonok:=FindText(sellbuttonX, sellbuttonY, 0, 0, 1919, 1030, 0, 0, sellbutton))
                                                                                        {
                                                                                            loop
                                                                                            {
                                                                                                ControlClick, x%sellbuttonX% y%sellbuttonY%, ahk_id %win1%,, Left, 1

                                                                                                ;ToolTip, found button
                                                                                                sleep, 500
                                                                                                if (!sellbuttonok:=FindText(sellbuttonX, sellbuttonY, 0, 0, 1919, 1030, 0, 0, sellbutton))
                                                                                                {
                                                                                                    break
                                                                                                }

                                                                                            }
                                                                                        }
                                                                                    } until sellbuttonok!
                                                                                }
                                                                                Else
                                                                                {
                                                                                    Goto, sellitems
                                                                                }
                                                                            Return
                                                                            snapshot:
                                                                                imgFile := A_ScriptDir "\weightcheck.bmp" 
                                                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                                                x1 := winX + checkweightX1
                                                                                y1 := winY + checkweightY1
                                                                                x2 := winX + checkweightX2
                                                                                y2 := winY + checkweightY2
                                                                                FindText().Screenshot(x1, y1, x2, y2, 0)
                                                                                Sleep, 500
                                                                                FindText().SavePic(imgFile, x1, y1, x2, y2, 1) 
                                                                                SetTimer, CheckRegionSnapshot, 3000
                                                                            Return 
                                                                            ;==============================================================================
                                                                            CheckRegionSnapshot: 
                                                                                ;  Search entire screen  
                                                                                ImageSearch, sx, sy, 0, 0, A_ScreenWidth, A_ScreenHeight, *50 %A_ScriptDir%\weightcheck.bmp 
                                                                                if (ErrorLevel= 0) { 
                                                                                    ToolTip, looter inactive, 1480, 488
                                                                                    sleep 1000
                                                                                    ControlSend,, +7, ahk_id %win1% 
                                                                                    sleep 1000
                                                                                }
                                                                                Else{
                                                                                    ToolTip, looter active, 1480, 500
                                                                                    SetTimer, CheckRegionSnapshot, Off

                                                                                }
                                                                            Return 
                                                                            checkweight:
                                                                                74weight:="|<>BDBDBD@0.83$23.y2688AGUEMZ11FA22Vf490NET1GU42Z088o"
                                                                                74weight.="|<>BDBDBD@0.83$23.yC688WGUF0Z12lA26Ff48UNEF1GUW2Z0s8o"
                                                                                sleep, 50
                                                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                                                screenX1 := winX + checkweightX1
                                                                                screenY1 := winY + checkweightY1
                                                                                screenX2 := winX + checkweightX2
                                                                                screenY2 := winY + checkweightY2

                                                                                if (74weightok:=FindText(74weightX, 74weightY, screenX1, screenY1, screenX2, screenY2, 0, 0, 74weight))
                                                                                {
                                                                                    Gosub, sellitems
                                                                                }
                                                                            Return
                                                                            f3:: reload

                                                                            SendMessageClick(x, y, winId := "") {
                                                                                if (winId = "")
                                                                                    winId := win1

                                                                                ; Get window position and client area
                                                                                WinGetPos, winX, winY,,, ahk_id %winId%

                                                                                ; Calculate relative coordinates (simple screen to window conversion)
                                                                                relativeX := x - winX
                                                                                relativeY := y - winY

                                                                                ; Adjust for title bar and borders (typical Windows offset)
                                                                                relativeX := relativeX - 8
                                                                                relativeY := relativeY - 31

                                                                                ; Create lParam for coordinates
                                                                                lParam := (relativeY << 16) | (relativeX & 0xFFFF)

                                                                                ; Send mouse down and up messages
                                                                                ControlClick, x%clientX% y%clientY%, ahk_id %winId%,, Left, 1
                                                                            }
                                                                            SendMessageClick3(x, y, winId := "") {
                                                                                if (winId = "")
                                                                                    winId := win1

                                                                                ; Get window position and client area
                                                                                WinGetPos, winX, winY,,, ahk_id %winId%

                                                                                ; Calculate relative coordinates (simple screen to window conversion)
                                                                                relativeX := x - winX
                                                                                relativeY := y - winY

                                                                                ; Adjust for title bar and borders (typical Windows offset)
                                                                                relativeX := relativeX - 8
                                                                                relativeY := relativeY - 31

                                                                                ; Create lParam for coordinates
                                                                                lParam := (relativeY << 16) | (relativeX & 0xFFFF)

                                                                                ; Send mouse down and up messages
                                                                                SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
                                                                                Sleep, 50
                                                                                SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
                                                                                Sleep, 50
                                                                            }

                                                                            normcontrolclick(x, y, sleepTime := 100) {
                                                                                ControlClick, x%x% y%y%, ahk_id %win1%,, Left, 1, D
                                                                                sleep %sleepTime%
                                                                                ControlClick, x%x% y%y%, ahk_id %win1%,, Left, 1, U
                                                                            }

                                                                            ; ========= COORDINATE SETTINGS FUNCTIONS =========
                                                                            SetCheckSnapshotCoords:
                                                                                Gui, Hide

                                                                                MsgBox, 4, Set Area, Click OK then drag to select the area for both checkweight and snapshot.`n`nClick top-left corner, then drag to bottom-right corner.
                                                                                    IfMsgBox No
                                                                                {
                                                                                    Gui, Show
                                                                                    return
                                                                                }

                                                                                ToolTip, Click and drag to select area, 100, 100

                                                                                KeyWait, LButton, D
                                                                                MouseGetPos, startX, startY
                                                                                KeyWait, LButton
                                                                                MouseGetPos, endX, endY

                                                                                ToolTip

                                                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                                                checkweightX1 := startX - winX
                                                                                checkweightY1 := startY - winY
                                                                                checkweightX2 := endX - winX
                                                                                checkweightY2 := endY - winY

                                                                                if (checkweightX1 > checkweightX2) {
                                                                                    temp := checkweightX1
                                                                                    checkweightX1 := checkweightX2
                                                                                    checkweightX2 := temp
                                                                                }
                                                                                if (checkweightY1 > checkweightY2) {
                                                                                    temp := checkweightY1
                                                                                    checkweightY1 := checkweightY2
                                                                                    checkweightY2 := temp
                                                                                }

                                                                                SaveCoordinateSettings()
                                                                                UpdateCoordinateDisplay()

                                                                                MsgBox, 64, Success, Area set to:`n%checkweightX1%,%checkweightY1% to %checkweightX2%,%checkweightY2%

                                                                                Gui, Show
                                                                            return

                                                                            SaveCoordinateSettings() {
                                                                                global iniFile, checkweightX1, checkweightY1, checkweightX2, checkweightY2

                                                                                FileEncoding, UTF-8
                                                                                IniWrite, %checkweightX1%, %iniFile%, CoordinateSettings, CheckweightX1
                                                                                IniWrite, %checkweightY1%, %iniFile%, CoordinateSettings, CheckweightY1
                                                                                IniWrite, %checkweightX2%, %iniFile%, CoordinateSettings, CheckweightX2
                                                                                IniWrite, %checkweightY2%, %iniFile%, CoordinateSettings, CheckweightY2
                                                                                FileEncoding
                                                                            }

                                                                            LoadCoordinateSettings() {
                                                                                global iniFile, checkweightX1, checkweightY1, checkweightX2, checkweightY2

                                                                                IniRead, loadedCWX1, %iniFile%, CoordinateSettings, CheckweightX1, %checkweightX1%
                                                                                IniRead, loadedCWY1, %iniFile%, CoordinateSettings, CheckweightY1, %checkweightY1%
                                                                                IniRead, loadedCWX2, %iniFile%, CoordinateSettings, CheckweightX2, %checkweightX2%
                                                                                IniRead, loadedCWY2, %iniFile%, CoordinateSettings, CheckweightY2, %checkweightY2%

                                                                                if (loadedCWX1 != "ERROR") checkweightX1 := loadedCWX1
                                                                                    if (loadedCWY1 != "ERROR") checkweightY1 := loadedCWY1
                                                                                    if (loadedCWX2 != "ERROR") checkweightX2 := loadedCWX2
                                                                                    if (loadedCWY2 != "ERROR") checkweightY2 := loadedCWY2

                                                                                SetTimer, UpdateCoordinateDisplayDelayed, 500
                                                                            }

                                                                            UpdateCoordinateDisplayDelayed:
                                                                                UpdateCoordinateDisplay()
                                                                            return

                                                                            UpdateCoordinateDisplay() {
                                                                                global checkweightX1, checkweightY1, checkweightX2, checkweightY2

                                                                                coordText := "Area: " . checkweightX1 . "," . checkweightY1 . " to " . checkweightX2 . "," . checkweightY2

                                                                                GuiControl,, CheckSnapshotCoordsText, %coordText%
                                                                            }

                                                                            ForceRefreshDPS:
                                                                                RefreshDPSPriorityList()
                                                                            return

                                                                            ForceRefreshcc:
                                                                                RefreshccPriorityList()
                                                                            return

                                                                            ForceRefreshHeal:
                                                                                RefreshHealPriorityList()
                                                                            return

                                                                            ; Timer functions to remove health dots
                                                                            RemoveHealthDot1:
                                                                                Gui, HealthDot1:Destroy
                                                                            return
                                                                            RemoveHealthDot2:
                                                                                Gui, HealthDot2:Destroy
                                                                            return
                                                                            RemoveHealthDot3:
                                                                                Gui, HealthDot3:Destroy
                                                                            return
                                                                            RemoveHealthDot4:
                                                                                Gui, HealthDot4:Destroy
                                                                            return
                                                                            RemoveHealthDot5:
                                                                                Gui, HealthDot5:Destroy
                                                                            return
                                                                            RemoveHealthDot6:
                                                                                Gui, HealthDot6:Destroy
                                                                            return
                                                                            RemoveHealthDot7:
                                                                                Gui, HealthDot7:Destroy
                                                                            return
                                                                            RemoveHealthDot8:
                                                                                Gui, HealthDot8:Destroy
                                                                            return
                                                                            RemoveHealthDot11:
                                                                                Gui, HealthDot11:Destroy
                                                                            return
                                                                            RemoveHealthDot12:
                                                                                Gui, HealthDot12:Destroy
                                                                            return
                                                                            RemoveHealthDot13:
                                                                                Gui, HealthDot13:Destroy
                                                                            return
                                                                            RemoveHealthDot14:
                                                                                Gui, HealthDot14:Destroy
                                                                            return
                                                                            RemoveHealthDot15:
                                                                                Gui, HealthDot15:Destroy
                                                                            return
                                                                            RemoveHealthDot16:
                                                                                Gui, HealthDot16:Destroy
                                                                            return

                                                                            ; ========= MANUAL HEALING FUNCTIONS =========
                                                                            SetManualCoords:
                                                                                Gui, Submit, NoHide
                                                                                PlayerCount := PlayerCountEdit
                                                                                PetCount := PetCountEdit

                                                                                if (PlayerCount = 0 && PetCount = 0) {
                                                                                    UpdateHealerStatus("Set at least 1 player or pet count first.")
                                                                                    return
                                                                                }

                                                                                ManualPlayerCoords := []
                                                                                ManualPetCoords := []

                                                                                Gui, Hide

                                                                                if (PlayerCount > 0) {
                                                                                    MsgBox, Click OK then left-click on %PlayerCount% player health bar locations.
                                                                                    Loop, %PlayerCount% {
                                                                                        ToolTip, Click on Player %A_Index% health bar, 100, 100
                                                                                        KeyWait, LButton, D
                                                                                        MouseGetPos, px, py
                                                                                        ManualPlayerCoords.Push({x: px, y: py})
                                                                                        KeyWait, LButton
                                                                                        Sleep, 200
                                                                                    }
                                                                                }

                                                                                if (PetCount > 0) {
                                                                                    MsgBox, Now left-click on %PetCount% pet health bar locations.
                                                                                    Loop, %PetCount% {
                                                                                        ToolTip, Click on Pet %A_Index% health bar, 100, 100
                                                                                        KeyWait, LButton, D
                                                                                        MouseGetPos, px, py
                                                                                        ManualPetCoords.Push({x: px, y: py})
                                                                                        KeyWait, LButton
                                                                                        Sleep, 200
                                                                                    }
                                                                                }

                                                                                ToolTip
                                                                                Gui, Show

                                                                                statusText := "Manual coords set: " . PlayerCount . " players, " . PetCount . " pets"
                                                                                GuiControl,, ManualHealStatus, %statusText%
                                                                                UpdateHealerStatus(statusText)
                                                                            return

                                                                            StartManualHealing:
                                                                                if (ManualPlayerCoords.Length() = 0 && ManualPetCoords.Length() = 0) {
                                                                                    UpdateHealerStatus("Set manual coordinates first.")
                                                                                    return
                                                                                }

                                                                                isManualHealingActive := true
                                                                                SetTimer, ManualHealthCheck, %healCheckInterval%
                                                                                UpdateHealerStatus("Manual healing started - checking " . ManualPlayerCoords.Length() . " players, " . ManualPetCoords.Length() . " pets")
                                                                            return

                                                                            StopManualHealing:
                                                                                isManualHealingActive := false
                                                                                SetTimer, ManualHealthCheck, Off
                                                                                UpdateHealerStatus("Manual healing stopped.")
                                                                            return

                                                                            ManualHealthCheck:
                                                                                if (!isManualHealingActive)
                                                                                    return

                                                                                ; Check manual player coordinates
                                                                                for index, coords in ManualPlayerCoords {
                                                                                    checkX := coords.x
                                                                                    checkY := coords.y

                                                                                    ; Look for full health (green)
                                                                                    healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
                                                                                    healthFull.="|<>##0.90$0/0/51CA2F,0/1/48C723,0/2/42D019,0/3/25A800,0/4/259F00"

                                                                                    healthFound := FindText(0, 0, checkX-10, checkY-10, checkX+10, checkY+10, 0, 0, healthFull)

                                                                                    if (!healthFound) {
                                                                                        SendMessageClick(checkX, checkY)
                                                                                        TryCastHealingSkill()
                                                                                        UpdateHealerStatus("→ Healed Manual Player " . index)
                                                                                        Sleep, 25
                                                                                    }
                                                                                }

                                                                                ; Check manual pet coordinates
                                                                                for index, coords in ManualPetCoords {
                                                                                    checkX := coords.x
                                                                                    checkY := coords.y

                                                                                    ; Look for full health (green)
                                                                                    healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
                                                                                    healthFull.="|<>##0.90$0/0/51CA2F,0/1/48C723,0/2/42D019,0/3/25A800,0/4/259F00"
                                                                                    healthFound := FindText(0, 0, checkX-10, checkY-10, checkX+10, checkY+10, 0, 0, healthFull)

                                                                                    if (!healthFound) {
                                                                                        SendMessageClick(checkX, checkY)
                                                                                        TryCastHealingSkill()
                                                                                        UpdateHealerStatus("→ Healed Manual Pet " . index)
                                                                                        Sleep, 25
                                                                                    }
                                                                                }
                                                                            return
                                                                            DPSTargetedHealthCheck:
                                                                                ; Check DPS targeted player coordinates
                                                                                for index, coords in DPSTargetedPlayerCoords {
                                                                                    checkX := coords.x
                                                                                    checkY := coords.y

                                                                                    ; Look for full health (green)
                                                                                    healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
                                                                                    healthFound := FindText(0, 0, checkX-10, checkY-10, checkX+10, checkY+10, 0, 0, healthFull)

                                                                                    if (!healthFound) {
                                                                                        SendMessageClick(checkX, checkY)
                                                                                        TryCastHealingSkill()
                                                                                        Sleep, 25
                                                                                    }
                                                                                }

                                                                                ; Check DPS targeted pet coordinates
                                                                                for index, coords in DPSTargetedPetCoords {
                                                                                    checkX := coords.x
                                                                                    checkY := coords.y

                                                                                    ; Look for full health (green)
                                                                                    healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
                                                                                    healthFound := FindText(0, 0, checkX-10, checkY-10, checkX+10, checkY+10, 0, 0, healthFull)

                                                                                    if (!healthFound) {
                                                                                        SendMessageClick(checkX, checkY)
                                                                                        TryCastHealingSkill()
                                                                                        Sleep, 25
                                                                                    }
                                                                                }
                                                                            return

                                                                            LaunchGame:
                                                                                IniRead, outpath, %iniFile%, gamepath, path
                                                                                Run, %outpath%
                                                                            Return

                                                                            SelectGame:
                                                                                FileSelectFile, selectedGame, 3,, Select a game, Executables (*.exe)
                                                                                if (selectedGame != "") {
                                                                                    MsgBox, You selected: %selectedGame%
                                                                                    IniWrite, %selectedGame%, %iniFile%, gamepath, path
                                                                                }
                                                                            Return
                                                                            Characters:
                                                                                Gui, char:New
                                                                                Gui, char:Color, 444444
                                                                                Loop, 8 {
                                                                                    IniRead, buttonName, %iniFile%, Character%A_Index%, username, Character %A_Index%
                                                                                    y := (A_Index-1)*40 + 10
                                                                                    Gui, char:Add, Button, x10 y%y% w100 h30 gChar%A_Index%, %buttonName%
                                                                                    Gui, char:Add, Button, x120 y%y% w50 h30 gReset%A_Index%, Edit
                                                                                }
                                                                                Gui, char:Show, w180 h340, Characters
                                                                            return

                                                                            Reset1:
                                                                            Reset2:
                                                                            Reset3:
                                                                            Reset4:
                                                                            Reset5:
                                                                            Reset6:
                                                                            Reset7:
                                                                            Reset8:
                                                                                CurrentChar := SubStr(A_ThisLabel, 6)
                                                                                Gui, login:New
                                                                                Gui, login:+AlwaysOnTop
                                                                                Gui, login:Add, Text,, Username:
                                                                                Gui, login:Add, Edit, vNewUser w150
                                                                                Gui, login:Add, Text,, Password:
                                                                                Gui, login:Add, Edit, vNewPass Password w150
                                                                                Gui, login:Add, Button, gSaveLogin w60, Save
                                                                                Gui, login:Show,, Edit Character
                                                                            return

                                                                            SaveLogin:
                                                                                Gui, login:Submit
                                                                                IniWrite, %NewUser%, %iniFile%, Character%CurrentChar%, username
                                                                                IniWrite, %NewPass%, %iniFile%, Character%CurrentChar%, password
                                                                                Gui, login:Destroy
                                                                                Gui, char:Destroy
                                                                                Gosub, Characters
                                                                            return

                                                                            Char1:
                                                                            Char2:
                                                                            Char3:
                                                                            Char4:
                                                                            Char5:
                                                                            Char6:
                                                                            Char7:
                                                                            Char8:
                                                                                CurrentChar := SubStr(A_ThisLabel, 5)
                                                                                IniRead, username, %iniFile%, Character%CurrentChar%, username
                                                                                IniRead, password, %iniFile%, Character%CurrentChar%, password

                                                                                if (username = "ERROR" || password = "ERROR") {
                                                                                    Gui, login:New
                                                                                    Gui, login:+AlwaysOnTop
                                                                                    Gui, login:Add, Text,, Username:
                                                                                    Gui, login:Add, Edit, vNewUser w150
                                                                                    Gui, login:Add, Text,, Password:
                                                                                    Gui, login:Add, Edit, vNewPass Password w150
                                                                                    Gui, login:Add, Button, gSaveLogin w60, Save
                                                                                    Gui, login:Show,, Setup Character
                                                                                } else {
                                                                                    KeyWait, LButton, D
                                                                                    if (InStr(username, "!")) {
                                                                                        SendInput, {!}
                                                                                    }
                                                                                    Sleep, 100
                                                                                    SendInput %username%
                                                                                    Sleep, 100
                                                                                    SendInput {Tab}
                                                                                    Sleep, 100
                                                                                    SendInput %password%
                                                                                    if (InStr(password, "!")) {
                                                                                        SendInput, {!}
                                                                                    }
                                                                                    KeyWait, LButton
                                                                                }
                                                                            return
                                                                            passwordonly:
                                                                                CurrentChar := SubStr(A_ThisLabel, 5)
                                                                                IniRead, password, %iniFile%, Character%CurrentChar%, password

                                                                                if (password = "ERROR") {
                                                                                    Gui, login:New
                                                                                    Gui, login:+AlwaysOnTop
                                                                                    Gui, login:Add, Text,, Password:
                                                                                    Gui, login:Add, Edit, vNewPass Password w150
                                                                                    Gui, login:Add, Button, gSaveLogin w60, Save
                                                                                    Gui, login:Show,, Setup password
                                                                                } else {
                                                                                    KeyWait, LButton, D
                                                                                    Sleep, 100
                                                                                    SendInput %password%
                                                                                    if (InStr(password, "!")) {
                                                                                        SendInput, {!}
                                                                                    }
                                                                                    KeyWait, LButton
                                                                                }
                                                                            return

                                                                            ; ========= WINDOW SETTINGS FUNCTIONS =========
                                                                            SaveGameWindowSettings() {
                                                                                global TargetGameWindow, TargetGameTitle, TargetGamePID, iniFile

                                                                                FileEncoding, UTF-8
                                                                                IniWrite, %TargetGameWindow%, %iniFile%, GameWindow, WindowID
                                                                                IniWrite, %TargetGameTitle%, %iniFile%, GameWindow, WindowTitle
                                                                                IniWrite, %TargetGamePID%, %iniFile%, GameWindow, WindowPID
                                                                                FileEncoding
                                                                            }

                                                                            UpdateWindowDisplayDelayed:
                                                                                UpdateWindowStatusDisplay()
                                                                            return

                                                                            UpdateWindowStatusDisplay() {
                                                                                global TargetGameTitle, actualtitle

                                                                                if (TargetGameTitle != "" && TargetGameTitle != "ERROR") {
                                                                                    statusText := "Window: " . TargetGameTitle
                                                                                    ;ToolTip, [UpdateWindowStatusDisplay] Setting WindowStatus to: %statusText%
                                                                                    GuiControl,, WindowStatus, %statusText%
                                                                                    ;Sleep, 1000
                                                                                    ;ToolTip
                                                                                    Gui, Show
                                                                                } else {
                                                                                    ;ToolTip, [UpdateWindowStatusDisplay] Setting WindowStatus to: No window selected
                                                                                    GuiControl,, WindowStatus, No window selected
                                                                                    ;Sleep, 1000
                                                                                    ;ToolTip
                                                                                    Gui, Show
                                                                                }
                                                                            }

                                                                            ; ========= PROFILE MANAGEMENT FUNCTIONS =========
                                                                            SaveProfile() {
                                                                                global CurrentProfileName, ProfileSettingsFile, SettingsFile
                                                                                global KeyCombination1, KeyDelay1, TimerInterval1
                                                                                global KeyCombination2, KeyDelay2, TimerInterval2
                                                                                global KeyCombination3, KeyDelay3, TimerInterval3
                                                                                global win1

                                                                                ; Get current values from GUI
                                                                                GuiControlGet, CurrentProfile,, CurrentProfile
                                                                                GuiControlGet, KeyCombination1,, KeyCombinationEdit1
                                                                                GuiControlGet, KeyDelay1,, KeyDelayEdit1
                                                                                GuiControlGet, TimerInterval1,, TimerIntervalEdit1
                                                                                GuiControlGet, KeyCombination2,, KeyCombinationEdit2
                                                                                GuiControlGet, KeyDelay2,, KeyDelayEdit2
                                                                                GuiControlGet, TimerInterval2,, TimerIntervalEdit2
                                                                                GuiControlGet, KeyCombination3,, KeyCombinationEdit3
                                                                                GuiControlGet, KeyDelay3,, KeyDelayEdit3
                                                                                GuiControlGet, TimerInterval3,, TimerIntervalEdit3

                                                                                if (CurrentProfile != "") {
                                                                                    CurrentProfileName := CurrentProfile
                                                                                }

                                                                                ; Save profile-specific settings to ProfileSettingsFile
                                                                                FileEncoding, UTF-8
                                                                                IniWrite, %KeyCombination1%, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination1
                                                                                IniWrite, %KeyDelay1%, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay1
                                                                                IniWrite, %TimerInterval1%, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval1
                                                                                IniWrite, %KeyCombination2%, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination2
                                                                                IniWrite, %KeyDelay2%, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay2
                                                                                IniWrite, %TimerInterval2%, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval2
                                                                                IniWrite, %KeyCombination3%, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination3
                                                                                IniWrite, %KeyDelay3%, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay3
                                                                                IniWrite, %TimerInterval3%, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval3
                                                                                FileEncoding

                                                                                ; Also persist current keypresser settings to the general SettingsFile (merge behavior)
                                                                                FileEncoding, UTF-8
                                                                                IniWrite, %win1%, %SettingsFile%, Settings, win1

                                                                                IniWrite, %KeyCombination1%, %SettingsFile%, Sequence1, KeyCombination
                                                                                IniWrite, %KeyDelay1%, %SettingsFile%, Sequence1, KeyDelay
                                                                                IniWrite, %TimerInterval1%, %SettingsFile%, Sequence1, TimerInterval

                                                                                IniWrite, %KeyCombination2%, %SettingsFile%, Sequence2, KeyCombination
                                                                                IniWrite, %KeyDelay2%, %SettingsFile%, Sequence2, KeyDelay
                                                                                IniWrite, %TimerInterval2%, %SettingsFile%, Sequence2, TimerInterval

                                                                                IniWrite, %KeyCombination3%, %SettingsFile%, Sequence3, KeyCombination
                                                                                IniWrite, %KeyDelay3%, %SettingsFile%, Sequence3, KeyDelay
                                                                                IniWrite, %TimerInterval3%, %SettingsFile%, Sequence3, TimerInterval
                                                                                FileEncoding
                                                                                ;RefreshProfileDropdown()

                                                                                ; Notify user and update statuses
                                                                                MsgBox, 64, Success, Profile "%CurrentProfileName%" saved successfully!
                                                                                UpdateStatus1("Settings saved")
                                                                                UpdateStatus2("Settings saved")
                                                                                UpdateStatus3("Settings saved")

                                                                            }

                                                                            LoadProfile() {
                                                                                global CurrentProfileName, ProfileSettingsFile
                                                                                global KeyCombination1, KeyDelay1, TimerInterval1
                                                                                global KeyCombination2, KeyDelay2, TimerInterval2
                                                                                global KeyCombination3, KeyDelay3, TimerInterval3

                                                                                ; Get selected profile from GUI
                                                                                GuiControlGet, CurrentProfile,, CurrentProfile
                                                                                if (CurrentProfile != "") {
                                                                                    CurrentProfileName := CurrentProfile
                                                                                }

                                                                                IniRead, KeyCombination1, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination1, %A_Space%
                                                                                IniRead, KeyDelay1, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay1, 0.1
                                                                                IniRead, TimerInterval1, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval1, 1
                                                                                IniRead, KeyCombination2, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination2, %A_Space%
                                                                                IniRead, KeyDelay2, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay2, 0.1
                                                                                IniRead, TimerInterval2, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval2, 2
                                                                                IniRead, KeyCombination3, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination3, %A_Space%
                                                                                IniRead, KeyDelay3, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay3, 0.1
                                                                                IniRead, TimerInterval3, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval3, 3

                                                                                ; Clean up ERROR values
                                                                                if (KeyCombination1 = "ERROR") 
                                                                                    KeyCombination1 := ""
                                                                                if (KeyCombination2 = "ERROR") 
                                                                                    KeyCombination2 := ""
                                                                                if (KeyCombination3 = "ERROR") 
                                                                                    KeyCombination3 := ""

                                                                                ; Update GUI controls
                                                                                GuiControl,, KeyCombinationEdit1, %KeyCombination1%
                                                                                GuiControl,, KeyDelayEdit1, %KeyDelay1%
                                                                                GuiControl,, TimerIntervalEdit1, %TimerInterval1%
                                                                                GuiControl,, KeyCombinationEdit2, %KeyCombination2%
                                                                                GuiControl,, KeyDelayEdit2, %KeyDelay2%
                                                                                GuiControl,, TimerIntervalEdit2, %TimerInterval2%
                                                                                GuiControl,, KeyCombinationEdit3, %KeyCombination3%
                                                                                GuiControl,, KeyDelayEdit3, %KeyDelay3%
                                                                                GuiControl,, TimerIntervalEdit3, %TimerInterval3%

                                                                                ; Show which profile was actually loaded
                                                                                GuiControlGet, actualProfile,, CurrentProfile
                                                                                ;MsgBox, 64, Success, Profile "%actualProfile%" loaded successfully!
                                                                            }

                                                                            ProfileChanged() {
                                                                                ; Auto-load when profile is changed
                                                                                LoadProfile()
                                                                            }

                                                                            NewProfile() {
                                                                                ; Get profile name from input
                                                                                GuiControlGet, ProfileNameEdit,, ProfileNameEdit
                                                                                if (ProfileNameEdit != "") {
                                                                                    CurrentProfileName := ProfileNameEdit
                                                                                    ; Ensure a section exists and persist default/settings immediately
                                                                                    FileEncoding, UTF-8
                                                                                    ; use an explicit non-empty placeholder to avoid IniWrite parameter #1 being empty
                                                                                    safeValue := " " ; single space (or use "default" / "0" if you prefer)
                                                                                    IniWrite, %safeValue%, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination1
                                                                                    FileEncoding
                                                                                    ; Refresh dropdown and select new profile
                                                                                    RefreshProfileDropdown()
                                                                                    GuiControl,, ProfileNameEdit,
                                                                                    loadprofile()
                                                                                    ;MsgBox, 64, Success, New profile "%CurrentProfileName%" created and saved!
                                                                                } else {
                                                                                    MsgBox, 48, Warning, Please enter a profile name first.
                                                                                }
                                                                            }

                                                                            RenameProfile() {
                                                                                global CurrentProfileName, ProfileSettingsFile

                                                                                ; Read current GUI selection and desired new name
                                                                                GuiControlGet, CurrentProfile,, CurrentProfile
                                                                                GuiControlGet, ProfileNameEdit,, ProfileNameEdit

                                                                                if (ProfileNameEdit = "" || CurrentProfile = "") {
                                                                                    MsgBox, 48, Warning, Please select a profile and enter a new name.
                                                                                    return
                                                                                }

                                                                                oldName := CurrentProfile
                                                                                newName := ProfileNameEdit

                                                                                ; Read all known keys from the old profile (safe defaults)
                                                                                IniRead, kc1, %ProfileSettingsFile%, %oldName%, KeyCombination1,
                                                                                IniRead, kd1, %ProfileSettingsFile%, %oldName%, KeyDelay1,
                                                                                IniRead, ti1, %ProfileSettingsFile%, %oldName%, TimerInterval1,

                                                                                IniRead, kc2, %ProfileSettingsFile%, %oldName%, KeyCombination2,
                                                                                IniRead, kd2, %ProfileSettingsFile%, %oldName%, KeyDelay2,
                                                                                IniRead, ti2, %ProfileSettingsFile%, %oldName%, TimerInterval2,

                                                                                IniRead, kc3, %ProfileSettingsFile%, %oldName%, KeyCombination3,
                                                                                IniRead, kd3, %ProfileSettingsFile%, %oldName%, KeyDelay3,
                                                                                IniRead, ti3, %ProfileSettingsFile%, %oldName%, TimerInterval3

                                                                                ; Write them under the new profile name
                                                                                FileEncoding, UTF-8
                                                                                IniWrite, %kc1%, %ProfileSettingsFile%, %newName%, KeyCombination1
                                                                                IniWrite, %kd1%, %ProfileSettingsFile%, %newName%, KeyDelay1
                                                                                IniWrite, %ti1%, %ProfileSettingsFile%, %newName%, TimerInterval1

                                                                                IniWrite, %kc2%, %ProfileSettingsFile%, %newName%, KeyCombination2
                                                                                IniWrite, %kd2%, %ProfileSettingsFile%, %newName%, KeyDelay2
                                                                                IniWrite, %ti2%, %ProfileSettingsFile%, %newName%, TimerInterval2

                                                                                IniWrite, %kc3%, %ProfileSettingsFile%, %newName%, KeyCombination3
                                                                                IniWrite, %kd3%, %ProfileSettingsFile%, %newName%, KeyDelay3
                                                                                IniWrite, %ti3%, %ProfileSettingsFile%, %newName%, TimerInterval3
                                                                                FileEncoding

                                                                                ; Remove the old profile section so it won't appear after reload
                                                                                IniDelete, %ProfileSettingsFile%, %oldName%

                                                                                ; Update runtime state
                                                                                CurrentProfileName := newName

                                                                                ; Refresh dropdown and select the renamed profile
                                                                                RefreshProfileDropdown()
                                                                                MsgBox, 64, Success, Profile renamed from "%oldName%" to "%newName%"!
                                                                            }

                                                                            DeleteProfile() {
                                                                                global CurrentProfileName, ProfileSettingsFile

                                                                                ; Get selected profile from GUI
                                                                                GuiControlGet, CurrentProfile,, CurrentProfile

                                                                                if (CurrentProfile != "") {
                                                                                    MsgBox, 4, Confirm Delete, Are you sure you want to delete the "%CurrentProfile%" profile?
                                                                                    IfMsgBox Yes
                                                                                    {
                                                                                        ; Delete the profile section
                                                                                        IniDelete, %ProfileSettingsFile%, %CurrentProfile%

                                                                                        ; Reset to default profile variable
                                                                                        CurrentProfileName := ""
                                                                                        ; Refresh dropdown so deleted profile disappears
                                                                                        RefreshProfileDropdown()
                                                                                        ; select farming if present
                                                                                        GuiControl, Choose, CurrentProfile, 1

                                                                                        LoadProfile()

                                                                                        MsgBox, 64, Success, Profile "%CurrentProfile%" deleted successfully!
                                                                                    }
                                                                                } else {
                                                                                    MsgBox, 48, Warning, Please select a profile to delete.
                                                                                }
                                                                            }

                                                                            ; Build the dropdown options from the ProfileSettingsFile sections

                                                                            RefreshProfileDropdown() {
                                                                                global ProfileSettingsFile, CurrentProfileName

                                                                                profiles := [] ; final unique ordered list
                                                                                seen := {} ; dedupe map

                                                                                if FileExist(ProfileSettingsFile) {
                                                                                    FileRead, iniText, %ProfileSettingsFile%
                                                                                    Loop, Parse, iniText, `n, `r
                                                                                    {
                                                                                        line := A_LoopField
                                                                                        if RegExMatch(line, "^\s*\[\s*(.+?)\s*\]\s*$", m) {
                                                                                            name := Trim(m1)
                                                                                            if (name != "" && !seen.HasKey(name)) {
                                                                                                seen[name] := true
                                                                                                profiles.Push(name)
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }

                                                                                ; Ensure at least "Farming" exists and prefer it as the first item
                                                                                if (!seen.HasKey("Default")) {
                                                                                    profiles.InsertAt(1, "Default")
                                                                                    seen["Default"] := true
                                                                                } else {
                                                                                    ; move existing "Farming" to first position for consistency
                                                                                    for i, nm in profiles {
                                                                                        if (nm = "Default") {
                                                                                            profiles.RemoveAt(i)
                                                                                            profiles.InsertAt(1, "Default")
                                                                                            break
                                                                                        }
                                                                                    }
                                                                                }

                                                                                ; Build pipe-delimited list string
                                                                                list := ""
                                                                                for index, name in profiles {
                                                                                    if (index > 1)
                                                                                        list .= "|"
                                                                                    list .= name
                                                                                }

                                                                                ; Clear the dropdown first (prevents appending / duplicates), then set full list
                                                                                GuiControl,, CurrentProfile, |
                                                                                Sleep, 10
                                                                                GuiControl,, CurrentProfile, %list%

                                                                                ; Preserve or reselect current profile if present
                                                                                selIndex := 1
                                                                                for index, name in profiles {
                                                                                    if (name = CurrentProfileName) {
                                                                                        selIndex := index
                                                                                        break
                                                                                    }
                                                                                }
                                                                                GuiControl, Choose, CurrentProfile, %selIndex%
                                                                            }

                                                                            LoadDefaultProfile() {
                                                                                global CurrentProfileName, ProfileSettingsFile
                                                                                global KeyCombination1, KeyDelay1, TimerInterval1
                                                                                global KeyCombination2, KeyDelay2, TimerInterval2
                                                                                global KeyCombination3, KeyDelay3, TimerInterval3

                                                                                ; Try to load the farming profile first
                                                                                IniRead, KeyCombination1, %ProfileSettingsFile%, Farming, KeyCombination1, %A_Space%
                                                                                IniRead, KeyDelay1, %ProfileSettingsFile%, Farming, KeyDelay1, 0.1
                                                                                IniRead, TimerInterval1, %ProfileSettingsFile%, Farming, TimerInterval1, 1
                                                                                IniRead, KeyCombination2, %ProfileSettingsFile%, Farming, KeyCombination2, %A_Space%
                                                                                IniRead, KeyDelay2, %ProfileSettingsFile%, Farming, KeyDelay2, 0.1
                                                                                IniRead, TimerInterval2, %ProfileSettingsFile%, Farming, TimerInterval2, 2
                                                                                IniRead, KeyCombination3, %ProfileSettingsFile%, Farming, KeyCombination3, %A_Space%
                                                                                IniRead, KeyDelay3, %ProfileSettingsFile%, Farming, KeyDelay3, 0.1
                                                                                IniRead, TimerInterval3, %ProfileSettingsFile%, Farming, TimerInterval3, 3

                                                                                ; Clean up ERROR values
                                                                                if (KeyCombination1 = "ERROR") 
                                                                                    KeyCombination1 := ""
                                                                                if (KeyCombination2 = "ERROR") 
                                                                                    KeyCombination2 := ""
                                                                                if (KeyCombination3 = "ERROR") 
                                                                                    KeyCombination3 := ""
                                                                            }
                                                                            DPSHoldHotkey:
                                                                                ; Save new hotkey from control and persist
                                                                                GuiControlGet, DPSHoldHotkey,, DPSHoldHotkey

                                                                                ; Turn off old hotkey if it exists
                                                                                if (OldDPSHoldHotkey != "") {
                                                                                    Hotkey, %OldDPSHoldHotkey%, Off
                                                                                }

                                                                                ; normalize empty -> clear
                                                                                if (DPSHoldHotkey = "") {
                                                                                    IniDelete, %SettingsFile%, Settings, DPSHoldHotkey
                                                                                    MsgBox, 64, Saved, DPS hold-hotkey cleared.
                                                                                    OldDPSHoldHotkey := ""
                                                                                    return
                                                                                }

                                                                                ; persist
                                                                                FileEncoding, UTF-8
                                                                                IniWrite, %DPSHoldHotkey%, %SettingsFile%, Settings, DPSHoldHotkey
                                                                                FileEncoding

                                                                                ; Register the new hotkey
                                                                                try {
                                                                                    Hotkey, %DPSHoldHotkey%, DPSHotkeyAction, On
                                                                                    OldDPSHoldHotkey := DPSHoldHotkey
                                                                                    MsgBox, 64, Saved, DPS hold-hotkey set to "%DPSHoldHotkey%". Hold it to loop DPS + DynamicHealthCheck.
                                                                                } catch {
                                                                                    MsgBox, 16, Error, Invalid hotkey: %DPSHoldHotkey%
                                                                                }
                                                                            return

                                                                            DPSHotkeyAction:
                                                                                ; This runs while the key is held
                                                                                if (!isSystemBusy) {
                                                                                    isSystemBusy := true
                                                                                    TryCastCCSkills()
                                                                                    TryCastDPSSkills()
                                                                                    gosub, DynamicHealthCheck
                                                                                    isSystemBusy := false
                                                                                }
                                                                            return

                                                                            DPSToggleHotkeyChanged:
                                                                                ; Save new DPS toggle hotkey from control and persist
                                                                                GuiControlGet, newDPSToggleKey,, DPSToggleHotkey

                                                                                ; Turn off old hotkey if it exists
                                                                                if (DPSToggleHotkey != "") {
                                                                                    hotkey, %DPSToggleHotkey%, Off, UseErrorLevel
                                                                                }

                                                                                ; Update the variable
                                                                                DPSToggleHotkey := newDPSToggleKey

                                                                                ; If empty, clear hotkey
                                                                                if (DPSToggleHotkey = "") {
                                                                                    IniDelete, %SettingsFile%, Settings, DPSToggleHotkey
                                                                                    MsgBox, 64, Saved, DPS toggle hotkey cleared.
                                                                                    return
                                                                                }

                                                                                ; Persist to INI
                                                                                FileEncoding, UTF-8
                                                                                IniWrite, %DPSToggleHotkey%, %SettingsFile%, Settings, DPSToggleHotkey
                                                                                FileEncoding

                                                                                ; Enable new hotkey
                                                                                hotkey, %DPSToggleHotkey%, ToggleDPSAction, On, UseErrorLevel
                                                                                if (ErrorLevel) {
                                                                                    MsgBox, 16, Invalid Hotkey, The hotkey "%DPSToggleHotkey%" is invalid or already in use.
                                                                                } else {
                                                                                    MsgBox, 64, Saved, DPS toggle hotkey set to: %DPSToggleHotkey%
                                                                                }
                                                                            return

                                                                            ToggleDPSAction:
                                                                                ; Toggle DPS on/off when hotkey is pressed
                                                                                if (isDpsRunning) {
                                                                                    gosub, StopDPSScript
                                                                                } else {
                                                                                    gosub, StartDPSScript
                                                                                }
                                                                            return

                                                                            autofollowhotkey:
                                                                                ; Save new hotkey from control and persist
                                                                                GuiControlGet, newAutoFollowKey,, autofollowhotkey

                                                                                ; Turn off old hotkey if it exists
                                                                                if (autofollowhotkey != "") {
                                                                                    hotkey, %autofollowhotkey%, Off, UseErrorLevel
                                                                                }

                                                                                ; Update the variable
                                                                                autofollowhotkey := newAutoFollowKey

                                                                                ; normalize empty -> clear timer
                                                                                if (autofollowhotkey = "") {
                                                                                    IniDelete, %SettingsFile%, Settings, autofollowhotkey
                                                                                    SetTimer, autofollowhotkeyWorker, Off
                                                                                    MsgBox, 64, Saved, auto follow hotkey cleared.
                                                                                    return
                                                                                }
                                                                                ; persist
                                                                                FileEncoding, UTF-8
                                                                                IniWrite, %autofollowhotkey%, %SettingsFile%, Settings, autofollowhotkey
                                                                                FileEncoding
                                                                                ; ensure timer interval has a safe default
                                                                                if (autofollowhotkeyTimerInterval = "" || autofollowhotkeyTimerInterval <= 0)
                                                                                    autofollowhotkeyTimerInterval := 50
                                                                                ; start timer to watch the key
                                                                                SetTimer, autofollowhotkeyWorker, %autofollowhotkeyTimerInterval%
                                                                            MsgBox, 64, Saved, auto follow hotkey set to "%autofollowhotkey%". press to return to main character.
                                                                            return
                                                                            autofollowhotkeyWorker:
                                                                                ; Poll the hotkey; when pressed, run return to main character
                                                                                Gui, Submit, NoHide
                                                                                if (autofollowhotkey = "") {
                                                                                    SetTimer, autofollowhotkeyWorker, Off
                                                                                    return
                                                                                }

                                                                                key := autofollowhotkey

                                                                                ; Normalize for parsing
                                                                                ; Accept forms like "Ctrl+F1", "Alt+X", "A" (keyboard) or "A" / "LB" / "DPAD_UP" / "Joy1" for Xbox buttons
                                                                                hasCtrl := InStr(key, "Ctrl") || InStr(key, "^")
                                                                                hasAlt := InStr(key, "Alt") || InStr(key, "!")
                                                                                hasShift:= InStr(key, "Shift")|| InStr(key, "+")
                                                                                baseKey := key

                                                                                ; Remove common modifier tokens (case-insensitive)
                                                                                baseKey := RegExReplace(baseKey, "(?i)\b(ctrl|alt|shift)\b\+?", "")
                                                                                baseKey := StrReplace(baseKey, "^", "")
                                                                                baseKey := StrReplace(baseKey, "!", "")
                                                                                baseKey := StrReplace(baseKey, "+", "")
                                                                                baseKey := Trim(baseKey)

                                                                                ; Prepare Xbox mapping
                                                                                xboxMap := {}
                                                                                xboxMap["A"] := "Joy1"
                                                                                xboxMap["B"] := "Joy2"
                                                                                xboxMap["X"] := "Joy3"
                                                                                xboxMap["Y"] := "Joy4"
                                                                                xboxMap["LB"] := "Joy5"
                                                                                xboxMap["RB"] := "Joy6"
                                                                                xboxMap["BACK"] := "Joy7"
                                                                                xboxMap["START"] := "Joy8"
                                                                                xboxMap["LS"] := "Joy9"
                                                                                xboxMap["RS"] := "Joy10"
                                                                                xboxMap["DPADUP"] := "Joy11"
                                                                                xboxMap["DPADDOWN"] := "Joy12"
                                                                                xboxMap["DPADLEFT"] := "Joy13"
                                                                                xboxMap["DPADRIGHT"] := "Joy14"
                                                                                xboxMap["LT"] := "Joy15"
                                                                                xboxMap["RT"] := "Joy16"

                                                                                isGamepad := false
                                                                                mappedJoy := ""

                                                                                ; If user supplied "JoyN" directly (e.g. Joy1) accept that
                                                                                if RegExMatch(baseKey, "(?i)^\s*Joy\s*([0-9]{1,2})\s*$", m) {
                                                                                    mappedJoy := "Joy" . m1
                                                                                    isGamepad := true
                                                                                } else {
                                                                                    ; Normalize for lookup: remove non-alphanum and uppercase
                                                                                    lookupKey := RegExReplace(baseKey, "[^A-Za-z0-9]", "")
                                                                                    StringUpper, lookupKey, lookupKey
                                                                                    if (lookupKey != "" && xboxMap.HasKey(lookupKey)) {
                                                                                        isGamepad := true
                                                                                        mappedJoy := xboxMap[lookupKey]
                                                                                    } else {
                                                                                        isGamepad := false
                                                                                    }
                                                                                } 
                                                                                ; Check key state depending on type
                                                                                isDown := true 
                                                                                ; if there is no base key and not a recognized gamepad mapping, treat as not pressed
                                                                                if (baseKey = "" && !isGamepad) {
                                                                                    isDown := false
                                                                                }
                                                                                if (hasCtrl && !GetKeyState("Ctrl", "P"))
                                                                                    isDown := false
                                                                                if (hasAlt && !GetKeyState("Alt", "P"))
                                                                                    isDown := false
                                                                                if (hasShift && !GetKeyState("Shift", "P"))
                                                                                    isDown := false 
                                                                                if (isGamepad) {
                                                                                    ; Try multiple variations to detect joystick button reliably:
                                                                                    ; - GetKeyState(mappedJoy, "P")
                                                                                    ; - GetKeyState(mappedJoy) (non-physical)
                                                                                    ; - If mappedJoy is "JoyN", also try numeric forms
                                                                                    joyDetected := false
                                                                                    if (mappedJoy != "") {
                                                                                        if (GetKeyState(mappedJoy, "P") || GetKeyState(mappedJoy))
                                                                                            joyDetected := true
                                                                                        else if RegExMatch(mappedJoy, "^Joy(\d+)$", jm) {
                                                                                            jnum := jm1
                                                                                            if (GetKeyState("Joy" . jnum, "P") || GetKeyState("Joy" . jnum))
                                                                                                joyDetected := true
                                                                                        }
                                                                                    }
                                                                                    if (!joyDetected)
                                                                                        isDown := false
                                                                                } else {
                                                                                    ; Regular keyboard key - try both physical and non-physical checks for common keys
                                                                                    if (!(GetKeyState(baseKey, "P") || GetKeyState(baseKey)))
                                                                                        isDown := false
                                                                                }
                                                                                if (isDown) {
                                                                                    ; When pressed: run return to main character
                                                                                    ; Avoid reentrancy using isSystemBusy
                                                                                    if (!isSystemBusy) {
                                                                                        isSystemBusy := true
                                                                                        ReturnToMainCharacter()
                                                                                        isSystemBusy := false
                                                                                    }
                                                                                }
                                                                            return

                                                                            autofollowaction: 
                                                                                ; Server executes locally first, then broadcasts to all clients
                                                                                ProcessCommand("AUTOFOLLOW")

                                                                                ; Broadcast to all connected clients
                                                                                SendCommandToAll("AUTOFOLLOW")
                                                                            return

                                                                            charselectaction:
                                                                                ; Execute character selection sequence
                                                                                PerformCharacterSelect()
                                                                            return
                                                                            ; ========== END PROFILE MANAGEMENT FUNCTIONS ==========
                                                                            ; ========== CROWD CONTROL COOLDOWN HANDLING ==========

                                                                            CCCooldownEnd:
                                                                                ccOnCooldown := false
                                                                                SetTimer, CCCooldownEnd, Off
                                                                            return

                                                                            ; ========= Navigation Functions =========
                                                                            return
                                                                            InitializeNavigation() {
                                                                                CheckNavPreviousSettings()
                                                                                LoadNavWaypoints()
                                                                                LoadDPSNavSettings()
                                                                                SetTimer, UpdateNavCoordinatesDisplay, 500
                                                                            }

                                                                            CheckNavPreviousSettings() {
                                                                                global usePreviousSettings := false ; Track user's choice
                                                                                IniRead, savedPID, navpathingsettings.ini, Settings, WindowPID, ERROR
                                                                                IniRead, savedCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR

                                                                                if (savedPID != "ERROR" && savedCameraFile != "ERROR") {
                                                                                    WinGet, winID, ID, ahk_pid %savedPID%
                                                                                    if (winID) {
                                                                                        ; Auto-accept previous settings (no message box)
                                                                                        NavTargetGameWindow := winID
                                                                                        NavTargetGamePID := savedPID
                                                                                        NavCameraFile := savedCameraFile
                                                                                        FindText().BindWindow(winID)
                                                                                        LoadNavCameraSettings(savedCameraFile)
                                                                                        GuiControl,, NavRadiusEdit, %NavCameraRadius%
                                                                                        GuiControl,, NavCameraFile, Camera: %savedCameraFile%
                                                                                        usePreviousSettings := true
                                                                                    }
                                                                                }
                                                                            }
                                                                            LoadNavWaypoints() {
                                                                                if (!NavSelectedRouteFile || !FileExist(NavSelectedRouteFile)) {
                                                                                    return
                                                                                }

                                                                                NavWaypoints := []
                                                                                NavWaypointCount := 0

                                                                                ; Try new format first (Waypoints section with X1, Y1, etc.)
                                                                                IniRead, waypointCount, %NavSelectedRouteFile%, Waypoints, Count, 0
                                                                                if (waypointCount > 0) {
                                                                                    Loop, %waypointCount% {
                                                                                        IniRead, x, %NavSelectedRouteFile%, Waypoints, X%A_Index%, ERROR
                                                                                        IniRead, y, %NavSelectedRouteFile%, Waypoints, Y%A_Index%, ERROR
                                                                                        if (x != "ERROR" && y != "ERROR") {
                                                                                            NavWaypointCount++
                                                                                            NavWaypoints[NavWaypointCount] := {x: x, y: y}
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    ; Try old format (Waypoint1, Waypoint2, etc. sections)
                                                                                    i := 1
                                                                                    Loop {
                                                                                        IniRead, x, %NavSelectedRouteFile%, Waypoint%i%, X, ERROR
                                                                                        IniRead, y, %NavSelectedRouteFile%, Waypoint%i%, Y, ERROR
                                                                                        if (x = "ERROR" || y = "ERROR") {
                                                                                            break
                                                                                        }
                                                                                        NavWaypointCount++
                                                                                        NavWaypoints[NavWaypointCount] := {x: x, y: y}
                                                                                        i++
                                                                                    }
                                                                                }
                                                                            }

                                                                            SaveNavSettings() {
                                                                                if (NavTargetGamePID && NavCameraFile) {
                                                                                    IniWrite, %NavTargetGamePID%, navpathingsettings.ini, Settings, WindowPID
                                                                                    IniWrite, %NavCameraFile%, navpathingsettings.ini, Settings, CameraFile
                                                                                }
                                                                            }

                                                                            LoadCameraFilesAtStartup() {
                                                                                ; Check for any saved camera files
                                                                                IniRead, savedNavCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
                                                                                IniRead, savedMainCameraFile, pathingsettings.ini, Settings, CameraFile, ERROR

                                                                                ; Determine which camera file to offer
                                                                                cameraFileToOffer := ""
                                                                                cameraFileSource := ""

                                                                                if (savedNavCameraFile != "ERROR" && FileExist(savedNavCameraFile)) {
                                                                                    cameraFileToOffer := savedNavCameraFile
                                                                                    cameraFileSource := "Navigation"
                                                                                }
                                                                                else if (savedMainCameraFile != "ERROR" && FileExist(savedMainCameraFile)) {
                                                                                    cameraFileToOffer := savedMainCameraFile
                                                                                    cameraFileSource := "Main"
                                                                                }

                                                                                ; If we have a camera file to offer, auto-accept it (no prompt)
                                                                                if (cameraFileToOffer != "") {
                                                                                    ; Auto-use the saved camera file
                                                                                    LoadSavedCameraFile(cameraFileToOffer)
                                                                                }
                                                                                ; If no saved camera files found, don't prompt (user can set up later)
                                                                            }

                                                                            LoadSavedCameraFile(filePath) {
                                                                                ; Set up navigation camera
                                                                                NavCameraFile := filePath
                                                                                LoadNavCameraSettings(NavCameraFile)
                                                                                GuiControl,, NavCameraFile, Camera: %NavCameraFile%
                                                                                GuiControl,, NavRadiusEdit, %NavCameraRadius%

                                                                                ; Set up main camera  
                                                                                CameraFile := filePath
                                                                                LoadCameraSettings(navCameraFile)

                                                                                ; Save to both INI files
                                                                                SaveNavSettings()
                                                                                SaveSettings()

                                                                                SplitPath, filePath, fileName
                                                                                ToolTip, Camera file loaded: %fileName%, 0, 0
                                                                                SetTimer, RemoveCameraToolTip, 3000
                                                                            }

                                                                            RemoveCameraToolTip:
                                                                                ToolTip
                                                                                SetTimer, RemoveCameraToolTip, Off
                                                                            return
                                                                            return
                                                                            UpdateNavCoordinatesDisplay:
                                                                                if (NavTargetGameWindow) {
                                                                                    GetNavCurrentCoordinates(coordX, coordY)
                                                                                    if (coordX != "" && coordY != "") {
                                                                                        GuiControl,, NavCurrentCoords, Current: X: %coordX% Y: %coordY%
                                                                                    } else {
                                                                                        GuiControl,, NavCurrentCoords, Current: X: --- Y: ---
                                                                                    }
                                                                                } else {
                                                                                    GuiControl,, NavCurrentCoords, Current: X: --- Y: ---
                                                                                }
                                                                            return

                                                                            ; Check and execute pending timer actions at waypoints
                                                                            CheckAndExecuteTimerFlags() {
                                                                                global gnollBuffNeeded, dtBuffNeeded, sequence1Needed, sequence2Needed, sequence3Needed
                                                                                global potionDestroyNeeded, duraRepairNeeded

                                                                                ; Debug: Show current flag status
                                                                                flagStatus := "Timer Flags: "
                                                                                flagStatus .= "Gnoll:" . gnollBuffNeeded . " "
                                                                                flagStatus .= "DT:" . dtBuffNeeded . " "
                                                                                flagStatus .= "Seq1:" . sequence1Needed . " "
                                                                                flagStatus .= "Seq2:" . sequence2Needed . " "
                                                                                flagStatus .= "Seq3:" . sequence3Needed . " "
                                                                                flagStatus .= "Pot:" . potionDestroyNeeded . " "
                                                                                flagStatus .= "Dur:" . duraRepairNeeded
                                                                                ToolTip, %flagStatus%, 10, 10, 7
                                                                                SetTimer, RemoveFlagDebug, -5000

                                                                                ; Check and execute gnoll buff if needed
                                                                                if (gnollBuffNeeded) {
                                                                                    gnollBuffNeeded := false
                                                                                    gnoll(true)
                                                                                    sleep, 5000
                                                                                }

                                                                                ; Check and execute Death Tyrant buff if needed
                                                                                if (dtBuffNeeded) {
                                                                                    dtBuffNeeded := false
                                                                                    DeathTyrant(true)
                                                                                    sleep, 5000
                                                                                }

                                                                                ; Check and execute sequences if needed
                                                                                if (sequence1Needed) {
                                                                                    sequence1Needed := false
                                                                                    ; Execute sequence 1 directly without navigation checks
                                                                                    ExecuteSequence1(true)
                                                                                }

                                                                                if (sequence2Needed) {
                                                                                    sequence2Needed := false
                                                                                    ; Execute sequence 2 directly without navigation checks
                                                                                    ExecuteSequence2(true)
                                                                                }

                                                                                if (sequence3Needed) {
                                                                                    sequence3Needed := false
                                                                                    ; Execute sequence 3 directly without navigation checks
                                                                                    ExecuteSequence3(true)
                                                                                }

                                                                                ; Check and execute potion destroy if needed
                                                                                if (potionDestroyNeeded) {
                                                                                    potionDestroyNeeded := false
                                                                                    DestroySkyPotions(true)

                                                                                }

                                                                                ; Check and execute dura repair if needed
                                                                                if (duraRepairNeeded) {
                                                                                    duraRepairNeeded := false
                                                                                    PerformDuraRepair(true)

                                                                                }
                                                                            }

                                                                            RemoveFlagDebug:
                                                                                ToolTip, , , , 7
                                                                            return

                                                                            RemoveSignalDebug:
                                                                                ToolTip, , , , 9
                                                                            return

                                                                            RemoveNavDebug:
                                                                                ToolTip, , , , 10
                                                                            return

                                                                            ; Execute sequence functions without navigation checks (for waypoint execution)
                                                                            ExecuteSequence1(force := false) {
                                                                                global KeySequence1, KeyDelay1, win1, isSystemBusy

                                                                                ; Check if Critical mode is enabled - pause until disabled
                                                                                if (CriticalModeEnabled) {
                                                                                    return false
                                                                                }

                                                                                ; If navigation is running, set flag instead of executing, unless forced
                                                                                if ((NavIsTraveling || IsTraveling) && !force) {
                                                                                    sequence1Needed := true
                                                                                    return false
                                                                                }

                                                                                ; Set system busy for buff sequence
                                                                                ;isSystemBusy := true

                                                                                ; Pause navigation during sequence execution
                                                                                PauseNavigationForBuff()

                                                                                Loop % KeySequence1.Length()
                                                                                {
                                                                                    CurrentKey := KeySequence1[A_Index]
                                                                                    if (CurrentKey != "") {
                                                                                        ; Execute the key sequence (copy logic from SendKeys1)
                                                                                        hasCtrl := InStr(CurrentKey, "^")
                                                                                        hasAlt := InStr(CurrentKey, "!")
                                                                                        hasShift := InStr(CurrentKey, "+")

                                                                                        baseKey := CurrentKey
                                                                                        if (hasCtrl)
                                                                                            baseKey := StrReplace(baseKey, "^", "")
                                                                                        if (hasAlt)
                                                                                            baseKey := StrReplace(baseKey, "!", "")
                                                                                        if (hasShift)
                                                                                            baseKey := StrReplace(baseKey, "+", "")

                                                                                        baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                        if (hasCtrl)
                                                                                            ControlSend, , {Ctrl down}, ahk_id %win1%
                                                                                        if (hasAlt)
                                                                                            ControlSend, , {Alt down}, ahk_id %win1%
                                                                                        if (hasShift)
                                                                                            ControlSend, , {Shift down}, ahk_id %win1%

                                                                                        ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                                                        Sleep, 50
                                                                                        ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                                                        if (hasShift)
                                                                                            ControlSend, , {Shift up}, ahk_id %win1%
                                                                                        if (hasAlt)
                                                                                            ControlSend, , {Alt up}, ahk_id %win1%
                                                                                        if (hasCtrl)
                                                                                            ControlSend, , {Ctrl up}, ahk_id %win1%

                                                                                        if (KeyDelay1 > 0 && A_Index < KeySequence1.Length()) {
                                                                                            DelayMS1 := KeyDelay1 * 1000
                                                                                            Sleep, %DelayMS1%
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Sleep, 2000 
                                                                                NextExecutionTime1 := A_TickCount + (TimerInterval1 * 60 * 1000)

                                                                                ; Resume navigation after sequence execution
                                                                                ResumeNavigationAfterBuff()

                                                                                ; Release system busy flag
                                                                                isSystemBusy := false
                                                                            }

                                                                            ExecuteSequence2(force := false) {
                                                                                global KeySequence2, KeyDelay2, win1, isSystemBusy

                                                                                if (CriticalModeEnabled) {
                                                                                    return false
                                                                                }

                                                                                ; If navigation is running, set flag instead of executing, unless forced
                                                                                if ((NavIsTraveling || IsTraveling) && !force) {
                                                                                    sequence2Needed := true
                                                                                    return false
                                                                                }

                                                                                isSystemBusy := true
                                                                                PauseNavigationForBuff()

                                                                                Loop % KeySequence2.Length()
                                                                                {
                                                                                    CurrentKey := KeySequence2[A_Index]
                                                                                    if (CurrentKey != "") {
                                                                                        hasCtrl := InStr(CurrentKey, "^")
                                                                                        hasAlt := InStr(CurrentKey, "!")
                                                                                        hasShift := InStr(CurrentKey, "+")

                                                                                        baseKey := CurrentKey
                                                                                        if (hasCtrl)
                                                                                            baseKey := StrReplace(baseKey, "^", "")
                                                                                        if (hasAlt)
                                                                                            baseKey := StrReplace(baseKey, "!", "")
                                                                                        if (hasShift)
                                                                                            baseKey := StrReplace(baseKey, "+", "")

                                                                                        baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                        if (hasCtrl)
                                                                                            ControlSend, , {Ctrl down}, ahk_id %win1%
                                                                                        if (hasAlt)
                                                                                            ControlSend, , {Alt down}, ahk_id %win1%
                                                                                        if (hasShift)
                                                                                            ControlSend, , {Shift down}, ahk_id %win1%

                                                                                        ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                                                        Sleep, 50
                                                                                        ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                                                        if (hasShift)
                                                                                            ControlSend, , {Shift up}, ahk_id %win1%
                                                                                        if (hasAlt)
                                                                                            ControlSend, , {Alt up}, ahk_id %win1%
                                                                                        if (hasCtrl)
                                                                                            ControlSend, , {Ctrl up}, ahk_id %win1%

                                                                                        if (KeyDelay2 > 0 && A_Index < KeySequence2.Length()) {
                                                                                            DelayMS2 := KeyDelay2 * 1000
                                                                                            Sleep, %DelayMS2%
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Sleep, 2000 
                                                                                NextExecutionTime2 := A_TickCount + (TimerInterval2 * 60 * 1000)

                                                                                ResumeNavigationAfterBuff()
                                                                                isSystemBusy := false
                                                                            }

                                                                            ExecuteSequence3(force := false) {
                                                                                global KeySequence3, KeyDelay3, win1, isSystemBusy

                                                                                if (CriticalModeEnabled) {
                                                                                    return false
                                                                                }

                                                                                ; If navigation is running, set flag instead of executing, unless forced
                                                                                if ((NavIsTraveling || IsTraveling) && !force) {
                                                                                    sequence3Needed := true
                                                                                    return false
                                                                                }

                                                                                isSystemBusy := true
                                                                                PauseNavigationForBuff()

                                                                                Loop % KeySequence3.Length()
                                                                                {
                                                                                    CurrentKey := KeySequence3[A_Index]
                                                                                    if (CurrentKey != "") {
                                                                                        hasCtrl := InStr(CurrentKey, "^")
                                                                                        hasAlt := InStr(CurrentKey, "!")
                                                                                        hasShift := InStr(CurrentKey, "+")

                                                                                        baseKey := CurrentKey
                                                                                        if (hasCtrl)
                                                                                            baseKey := StrReplace(baseKey, "^", "")
                                                                                        if (hasAlt)
                                                                                            baseKey := StrReplace(baseKey, "!", "")
                                                                                        if (hasShift)
                                                                                            baseKey := StrReplace(baseKey, "+", "")

                                                                                        baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                        if (hasCtrl)
                                                                                            ControlSend, , {Ctrl down}, ahk_id %win1%
                                                                                        if (hasAlt)
                                                                                            ControlSend, , {Alt down}, ahk_id %win1%
                                                                                        if (hasShift)
                                                                                            ControlSend, , {Shift down}, ahk_id %win1%

                                                                                        ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                                                        Sleep, 50
                                                                                        ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                                                        if (hasShift)
                                                                                            ControlSend, , {Shift up}, ahk_id %win1%
                                                                                        if (hasAlt)
                                                                                            ControlSend, , {Alt up}, ahk_id %win1%
                                                                                        if (hasCtrl)
                                                                                            ControlSend, , {Ctrl up}, ahk_id %win1%

                                                                                        if (KeyDelay3 > 0 && A_Index < KeySequence3.Length()) {
                                                                                            DelayMS3 := KeyDelay3 * 1000
                                                                                            Sleep, %DelayMS3%
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Sleep, 2000 
                                                                                isSystemBusy := false

                                                                                NextExecutionTime3 := A_TickCount + (TimerInterval3 * 60 * 1000)
                                                                                UpdateStatus3("Buffs executed - yielding to DPS/Heal")
                                                                                if (NavigationPausedForBuff) {
                                                                                    ResumeNavigationAfterBuff()
                                                                                }
                                                                            }
                                                                            SetSequence1Flag:
                                                                                sequence1Needed := true
                                                                            return

                                                                            SetSequence2Flag:
                                                                                sequence2Needed := true
                                                                            return

                                                                            SetSequence3Flag:
                                                                                sequence3Needed := true
                                                                            return
                                                                            LoadNavCameraSettings(filePath) {
                                                                                FileRead, fileContent, %filePath%
                                                                                if (ErrorLevel) {
                                                                                    MsgBox, Error reading camera file
                                                                                    return
                                                                                }

                                                                                RegExMatch(fileContent, "RADIUS\|([0-9.]+)\|", radiusMatch)
                                                                                RegExMatch(fileContent, "ZANGLE\|([0-9.-]+)\|", zangleMatch)

                                                                                if (radiusMatch1) {
                                                                                    NavCameraRadius := radiusMatch1
                                                                                    radiusRatio := NavCameraRadius / 900
                                                                                    NavPixelsPerGameUnitX := (100 / 89) / radiusRatio
                                                                                    NavPixelsPerGameUnitY := (100 / 43) / radiusRatio
                                                                                }

                                                                                if (zangleMatch1) {
                                                                                    NavCameraAngle := zangleMatch1
                                                                                }
                                                                            }

                                                                            ShowSearchArea:
                                                                                if (!NavTargetGameWindow) {
                                                                                    MsgBox, 0, Error, Please select a navigation window first!
                                                                                    return
                                                                                }

                                                                                WinGetPos, winX, winY,,, ahk_id %NavTargetGameWindow%
                                                                                searchX1 := winX + 835
                                                                                searchY1 := winY + 30
                                                                                searchX2 := winX + 1019
                                                                                searchY2 := winY + 48

                                                                                Gui, NavTop:New, +ToolWindow -Caption +AlwaysOnTop, NavTop
                                                                                Gui, NavTop:Color, Red
                                                                                Gui, NavTop:Show, x%searchX1% y%searchY1% w184 h2, NavTop

                                                                                Gui, NavBottom:New, +ToolWindow -Caption +AlwaysOnTop, NavBottom
                                                                                Gui, NavBottom:Color, Red
                                                                                bottomY := searchY2 - 2
                                                                                Gui, NavBottom:Show, x%searchX1% y%bottomY% w184 h2, NavBottom

                                                                                Gui, NavLeft:New, +ToolWindow -Caption +AlwaysOnTop, NavLeft
                                                                                Gui, NavLeft:Color, Red
                                                                                Gui, NavLeft:Show, x%searchX1% y%searchY1% w2 h18, NavLeft

                                                                                Gui, NavRight:New, +ToolWindow -Caption +AlwaysOnTop, NavRight
                                                                                Gui, NavRight:Color, Red
                                                                                rightX := searchX2 - 2
                                                                                Gui, NavRight:Show, x%rightX% y%searchY1% w2 h18, NavRight

                                                                                Sleep, 3000
                                                                                Gui, NavTop:Destroy
                                                                                Gui, NavBottom:Destroy
                                                                                Gui, NavLeft:Destroy
                                                                                Gui, NavRight:Destroy
                                                                            return

                                                                            ; StartTravel:
                                                                            ;     if (NavSelectedRouteFile = "") {
                                                                            ;         MsgBox, 0, Error, Please select a route first!
                                                                            ;         return
                                                                            ;     }
                                                                            ;     if (NavWaypointCount = 0) {
                                                                            ;         MsgBox, No waypoints loaded. Please select a route first.
                                                                            ;         return
                                                                            ;     }
                                                                            ;     InitializeNavigation()
                                                                            ;     NavIsTraveling := true
                                                                            ;     NavCurrentWaypoint := 1
                                                                            ;     SetTimer, NavTravelLoop, 100
                                                                            ; return

                                                                            NavTravelLoop:
                                                                                if (!NavIsTraveling || NavCurrentWaypoint > NavWaypointCount) {
                                                                                    NavIsTraveling := false
                                                                                    SetTimer, NavTravelLoop, Off
                                                                                    ;SetTimer, TimerSignalCheck, Off ; Stop signal checking when navigation ends
                                                                                    ; Restore any blocked functions when navigation ends
                                                                                    RestoreBlockedFunctions()
                                                                                    return
                                                                                }

                                                                                waypoint := NavWaypoints[NavCurrentWaypoint]

                                                                                ; Check if we should block/unblock functions at this waypoint
                                                                                CheckWaypointFunctionBlocking()

                                                                                GetNavCurrentCoordinates(coordsX, coordsY)
                                                                                if (Abs(coordsX - waypoint.x) <= 10 && Abs(coordsY - waypoint.y) <= 10) {
                                                                                    NavCurrentWaypoint++
                                                                                    ; Check if we reached the end and should loop
                                                                                    if (NavCurrentWaypoint > NavWaypointCount) {
                                                                                        NavCurrentWaypoint := 1
                                                                                    }
                                                                                    ; Trigger waypoint reached check for function blocking
                                                                                    CheckWaypointFunctionBlocking()
                                                                                } else {
                                                                                    NavigateToNavCoordinates(waypoint.x, waypoint.y)
                                                                                }
                                                                            return

                                                                            SaveNavRadius:
                                                                                if (!NavCameraFile) {
                                                                                    MsgBox, 0, Error, No camera file loaded!
                                                                                    return
                                                                                }

                                                                                Gui, Submit, NoHide
                                                                                newRadius := NavRadiusEdit

                                                                                if (newRadius = "" || newRadius < 1) {
                                                                                    MsgBox, 0, Error, Please enter a valid number for radius!
                                                                                        return
                                                                                }

                                                                                FileRead, fileContent, %NavCameraFile%
                                                                                if (ErrorLevel) {
                                                                                    MsgBox, Error reading camera file
                                                                                    return
                                                                                }

                                                                                newContent := RegExReplace(fileContent, "RADIUS\|[0-9.]+\|", "RADIUS|" . newRadius . "|")

                                                                                FileDelete, %NavCameraFile%
                                                                                FileAppend, %newContent%, %NavCameraFile%

                                                                                NavCameraRadius := newRadius
                                                                                radiusRatio := NavCameraRadius / 900
                                                                                NavPixelsPerGameUnitX := (100 / 89) / radiusRatio
                                                                                NavPixelsPerGameUnitY := (100 / 43) / radiusRatio

                                                                                MsgBox, Radius updated to %newRadius%
                                                                            return

                                                                            ToggleCameraLock:
                                                                                Gui, Submit, NoHide
                                                                                NavCameraLocked := NavCameraLockCheck
                                                                            return

                                                                            NavigateToNavCoordinates(targetX, targetY) {
                                                                                lastX := ""
                                                                                lastY := ""
                                                                                stuckCount := 0

                                                                                Loop {
                                                                                    GetNavCurrentCoordinates(coords1X, coords1Y)
                                                                                    Sleep, 20
                                                                                    GetNavCurrentCoordinates(coords2X, coords2Y)
                                                                                    Sleep, 20
                                                                                    GetNavCurrentCoordinates(coords3X, coords3Y)

                                                                                    if (coords1X != coords2X || coords1Y != coords2Y || coords2X != coords3X || coords2Y != coords3Y) {
                                                                                        Sleep, 300
                                                                                        continue
                                                                                    }

                                                                                    currentX := coords3X
                                                                                    currentY := coords3Y
                                                                                    targetX := targetX + 0
                                                                                    targetY := targetY + 0

                                                                                    if (Abs(currentX - targetX) <= 50 && Abs(currentY - targetY) <= 50) {
                                                                                        global arrived := true
                                                                                        global pylonresetting := true
                                                                                        return
                                                                                    }

                                                                                    if (currentX = lastX && currentY = lastY) {
                                                                                        stuckCount++
                                                                                    } else {
                                                                                        stuckCount := 0
                                                                                    }
                                                                                    lastX := currentX
                                                                                    lastY := currentY

                                                                                    clickX := 516
                                                                                    clickY := 430

                                                                                    deltaX := targetX - currentX
                                                                                    deltaY := targetY - currentY

                                                                                    pixelsPerGameUnitX := NavPixelsPerGameUnitX
                                                                                    pixelsPerGameUnitY := NavPixelsPerGameUnitY

                                                                                    cos_angle := Cos(-NavCameraAngle)
                                                                                    sin_angle := Sin(-NavCameraAngle)

                                                                                    rotatedX := deltaX * cos_angle - deltaY * sin_angle
                                                                                    rotatedY := deltaX * sin_angle + deltaY * cos_angle

                                                                                    clickOffsetX := -rotatedX * pixelsPerGameUnitX
                                                                                    clickOffsetY := -rotatedY * pixelsPerGameUnitY

                                                                                    maxClickDistance := 100
                                                                                    if (Abs(clickOffsetX) > maxClickDistance) {
                                                                                        clickOffsetX := (clickOffsetX > 0) ? maxClickDistance : -maxClickDistance
                                                                                    }
                                                                                    if (Abs(clickOffsetY) > maxClickDistance) {
                                                                                        clickOffsetY := (clickOffsetY > 0) ? maxClickDistance : -maxClickDistance
                                                                                    }

                                                                                    if (stuckCount > 2) {
                                                                                        Random, randX, -30, 30
                                                                                        Random, randY, -30, 30
                                                                                        clickOffsetX += randX
                                                                                        clickOffsetY += randY
                                                                                    }

                                                                                    clickX += clickOffsetX
                                                                                    clickY -= clickOffsetY

                                                                                    ControlClick, x%clickX% y%clickY%, ahk_id %NavTargetGameWindow%,, Left, 1

                                                                                    decopet:="|<>7D7D7D-0.90$62.w0000Y00w18U0008009UG5vrhzMj2/zVGV+2Z+EaZ8TkUbdLyDTG748/+JM264WEX+mYm0UVD7jSbh8w8DS"

                                                                                    if (ok:=FindText(X, Y, 1466-150000, 248-150000, 1466+150000, 248+150000, 0, 0, decopet))
                                                                                    {
                                                                                        ControlSend,, {Tab down}, ahk_id %NavTargetGameWindow%
                                                                                        Sleep, 50
                                                                                        ControlSend,, {Tab up}, ahk_id %NavTargetGameWindow%
                                                                                        Sleep, 100
                                                                                    }
                                                                                }
                                                                            }

                                                                            GetNavCurrentCoordinates(ByRef outX, ByRef outY) {
                                                                                outX := ""
                                                                                outY := ""

                                                                                WinGetPos, winX, winY,,, ahk_id %NavTargetGameWindow%
                                                                                searchX1 := winX + 835
                                                                                searchY1 := winY + 30
                                                                                searchX2 := winX + 1019
                                                                                searchY2 := winY + 48

                                                                                if (ok := FindText(x, y, searchX1, searchY1, searchX2, searchY2, 0, 0, NavText)) {
                                                                                    results := []
                                                                                    for i, v in ok {
                                                                                        results.Push({x: v.x, id: v.id})
                                                                                    }

                                                                                    Loop % results.Length() - 1 {
                                                                                        i := A_Index
                                                                                        Loop % results.Length() - i {
                                                                                            j := A_Index + i
                                                                                            if (results[i].x > results[j].x) {
                                                                                                temp := results[i]
                                                                                                results[i] := results[j]
                                                                                                results[j] := temp
                                                                                            }
                                                                                        }
                                                                                    }

                                                                                    coordX := ""
                                                                                    coordY := ""
                                                                                    spaceFound := false

                                                                                    for i, v in results {
                                                                                        if (i > 1) {
                                                                                            prevX := results[i-1].x
                                                                                            gap := v.x - prevX
                                                                                            if (gap > 9 && !spaceFound) {
                                                                                                spaceFound := true
                                                                                            }
                                                                                        }

                                                                                        if (!spaceFound) {
                                                                                            coordX .= v.id
                                                                                        } else {
                                                                                            coordY .= v.id
                                                                                        }
                                                                                    }

                                                                                    outX := coordX + 0
                                                                                    outY := coordY + 0
                                                                                }
                                                                            }

                                                                            RemoveNavToolTip:
                                                                                ToolTip
                                                                            return

                                                                            ; Navigation hotkeys
                                                                            #If NavCameraLocked && NavTargetGameWindow && WinActive("ahk_id " . NavTargetGameWindow)
                                                                            RButton::return
                                                                        WheelUp::return
                                                                        WheelDown::return
                                                                        #If

                                                                        ;F8::Gosub, AddWaypoint

                                                                        ; ========= NAVIGATION FUNCTION BLOCKING SYSTEM =========

                                                                        ; Set which waypoints should block functions
                                                                        ; Example: SetNavFunctionBlock(3, 7, ["CheckHealth", "DPSLoop"]) blocks healing and DPS functions from waypoint 3 to 7
                                                                        SetNavFunctionBlock(startWaypoint, endWaypoint, functionNames) {
                                                                            global NavFunctionBlockRanges
                                                                            NavFunctionBlockRanges[startWaypoint . "-" . endWaypoint] := {start: startWaypoint, end: endWaypoint, functions: functionNames}
                                                                        }

                                                                        ; Check if current waypoint requires function blocking/unblocking
                                                                        CheckWaypointFunctionBlocking() {
                                                                            global NavCurrentWaypoint, CurrentWaypoint, NavFunctionBlockRanges, NavFunctionsCurrentlyBlocked

                                                                            ; Use NavCurrentWaypoint if available (Navigation tab), otherwise use CurrentWaypoint (old system)
                                                                            currentWP := (NavCurrentWaypoint > 0) ? NavCurrentWaypoint : CurrentWaypoint

                                                                            shouldBlock := false
                                                                            functionsToBlock := []

                                                                            ; Check all defined blocking ranges
                                                                            for rangeName, rangeData in NavFunctionBlockRanges {
                                                                                if (currentWP >= rangeData.start && currentWP <= rangeData.end) {
                                                                                    shouldBlock := true
                                                                                    for index, functionName in rangeData.functions {
                                                                                        functionsToBlock.Push(functionName)
                                                                                    }
                                                                                }
                                                                            }

                                                                            ; Block functions if needed and not already blocked
                                                                            if (shouldBlock && !NavFunctionsCurrentlyBlocked) {
                                                                                BlockNavFunctions(functionsToBlock)
                                                                            }
                                                                            ; Restore functions if not needed and currently blocked
                                                                            else if (!shouldBlock && NavFunctionsCurrentlyBlocked) {
                                                                                RestoreBlockedFunctions()
                                                                            }
                                                                        }

                                                                        ; Block specified functions (timers keep running, but functions won't execute)
                                                                        BlockNavFunctions(functionNames) {
                                                                            global NavBlockedFunctions, NavFunctionsCurrentlyBlocked

                                                                            NavBlockedFunctions := []

                                                                            for index, functionName in functionNames {
                                                                                ; Store the function info for later restoration
                                                                                NavBlockedFunctions.Push(functionName)
                                                                            }

                                                                            NavFunctionsCurrentlyBlocked := true

                                                                            ; Optional: Show notification
                                                                            if (NavBlockedFunctions.Length() > 0) {
                                                                                functionList := ""
                                                                                for index, func in NavBlockedFunctions {
                                                                                    functionList .= func . (index < NavBlockedFunctions.Length() ? ", " : "")
                                                                                }
                                                                                ToolTip, Navigation: Critical protection - Blocked: %functionList%, 0, 30
                                                                                SetTimer, RemoveNavBlockTooltip, 3000
                                                                            }
                                                                        }

                                                                        ; Restore all blocked functions
                                                                        RestoreBlockedFunctions() {
                                                                            global NavBlockedFunctions, NavFunctionsCurrentlyBlocked

                                                                            if (!NavFunctionsCurrentlyBlocked) {
                                                                            return
                                                                        }

                                                                        restoredFunctions := []

                                                                        for index, functionName in NavBlockedFunctions {
                                                                            restoredFunctions.Push(functionName)
                                                                        }

                                                                        NavBlockedFunctions := []
                                                                        NavFunctionsCurrentlyBlocked := false

                                                                        ; Optional: Show notification
                                                                        if (restoredFunctions.Length() > 0) {
                                                                            functionList := ""
                                                                            for index, func in restoredFunctions {
                                                                                functionList .= func . (index < restoredFunctions.Length() ? ", " : "")
                                                                            }
                                                                            ToolTip, Navigation: Critical protection OFF - Restored: %functionList%, 0, 30
                                                                            SetTimer, RemoveNavBlockTooltip, 3000
                                                                        }
                                                                    }

                                                                    ; Enable Critical mode to block all timers
                                                                    EnableCriticalMode() {
                                                                        global CriticalModeEnabled := true
                                                                        ToolTip, Critical Mode: ON - All timers blocked, 10, 50, 2
                                                                        SetTimer, RemoveCriticalTooltip, -2000
                                                                    }

                                                                    ; Disable Critical mode to allow timers
                                                                    DisableCriticalMode() {
                                                                        global CriticalModeEnabled := false
                                                                        ToolTip, Critical Mode: OFF - Timers enabled, 10, 50, 2
                                                                        SetTimer, RemoveCriticalTooltip, -2000
                                                                    }

                                                                    ; Hotkeys for manual Critical mode control
                                                                    F9::EnableCriticalMode()
                                                                    F11::DisableCriticalMode()

                                                                    RemoveCriticalTooltip:
                                                                        ToolTip, , , , 2
                                                                    return

                                                                    RemoveNavBlockTooltip:
                                                                        ToolTip
                                                                        SetTimer, RemoveNavBlockTooltip, Off
                                                                    return

                                                                    CheckDPSNavigation() {
                                                                        global dpsNavTargetX, dpsNavTargetY, dpsNavRadius, NavTargetGameWindow
                                                                        if (!NavTargetGameWindow || dpsNavTargetX = "" || dpsNavTargetY = "") {
                                                                            return
                                                                        }

                                                                        GetNavCurrentCoordinates(currentX, currentY)
                                                                        if (currentX = "" || currentY = "") {
                                                                            return
                                                                        }

                                                                        ; Check if outside group radius - navigate back if needed
                                                                        radiusToUse := (dpsNavRadius != "" && dpsNavRadius > 0) ? dpsNavRadius : 50
                                                                        if (Abs(currentX - dpsNavTargetX) > radiusToUse || Abs(currentY - dpsNavTargetY) > radiusToUse) {
                                                                            ; Outside radius, navigate back to target
                                                                            NavigateToNavCoordinates(dpsNavTargetX, dpsNavTargetY)
                                                                        }
                                                                    }
                                                                    CheckDPSNavigation2() {
                                                                        if (!NavTargetGameWindow || dpsNavTargetX = "" || dpsNavTargetY = "") {
                                                                            return
                                                                        }

                                                                        GetNavCurrentCoordinates(currentX, currentY)
                                                                        if (currentX = "" || currentY = "") {
                                                                            return
                                                                        }

                                                                        ; Check if already at target coordinates (within 50 units)
                                                                        if (Abs(currentX - dpsNavTargetX) <= 50 && Abs(currentY - dpsNavTargetY) <= 50) {
                                                                            return ; Already there, skip navigation
                                                                        }

                                                                        ; Navigate to target coordinates
                                                                        NavigateToNavCoordinates(dpsNavTargetX, dpsNavTargetY)
                                                                    }
                                                                    LoadDPSNavSettings() {
                                                                        global usePreviousSettings

                                                                        ; Only load DPS coordinates if user chose to use previous settings
                                                                        if (!usePreviousSettings) {
                                                                            return
                                                                        }

                                                                        IniRead, loadedEnabled, dpsnavsettings.ini, Navigation, Enabled, 0
                                                                        IniRead, loadedX, dpsnavsettings.ini, Navigation, TargetX, 
                                                                        IniRead, loadedY, dpsnavsettings.ini, Navigation, TargetY, 
                                                                        IniRead, loadedRadius, dpsnavsettings.ini, Navigation, Radius, 50

                                                                        if (loadedEnabled != "ERROR") {
                                                                            dpsNavEnabled := loadedEnabled
                                                                            ;GuiControl,, dpsNavEnabled, %dpsNavEnabled%
                                                                        }

                                                                        if (loadedX != "ERROR" && loadedX != "") {
                                                                            dpsNavTargetX := loadedX
                                                                            GuiControl,, dpsNavTargetXEdit, %dpsNavTargetX%
                                                                        }

                                                                        if (loadedY != "ERROR" && loadedY != "") {
                                                                            dpsNavTargetY := loadedY
                                                                            GuiControl,, dpsNavTargetYEdit, %dpsNavTargetY%
                                                                        }

                                                                        if (loadedRadius != "ERROR" && loadedRadius != "") {
                                                                            ; Validate radius (minimum 25)
                                                                            if (loadedRadius < 25)
                                                                                loadedRadius := 50
                                                                            dpsNavRadius := loadedRadius
                                                                            GuiControl,, dpsNavRadiusEdit, %dpsNavRadius%
                                                                        }
                                                                    }
                                                                    SetPylonPosition:
                                                                        MsgBox, 0, Pylon Setup, Press SPACEBAR at first pylon location, then SPACEBAR at second pylon location.

                                                                        KeyWait, Space, D
                                                                        keywait, Space, u
                                                                        MouseGetPos, PylonPos1X, PylonPos1Y
                                                                        ToolTip, Pylon 1 set. Press SPACEBAR for second position.

                                                                        KeyWait, Space, D
                                                                        keywait, Space, u
                                                                        MouseGetPos, PylonPos2X, PylonPos2Y

                                                                        IniWrite, %PylonPos1X%, pylonpositions.ini, Positions, Pylon1X
                                                                        IniWrite, %PylonPos1Y%, pylonpositions.ini, Positions, Pylon1Y
                                                                        IniWrite, %PylonPos2X%, pylonpositions.ini, Positions, Pylon2X
                                                                        IniWrite, %PylonPos2Y%, pylonpositions.ini, Positions, Pylon2Y

                                                                        ToolTip, Pylon positions saved!
                                                                        global pylonresetlocationset := true
                                                                        SetTimer, RemovePylonToolTip, 2000
                                                                    return

                                                                    RemovePylonToolTip:
                                                                        ToolTip
                                                                    return

                                                                    SendMessageClick2(x, y, winId := "") {
                                                                        if (winId = "")
                                                                            winId := win1

                                                                        ; Create lParam for coordinates (x and y are already client coordinates)
                                                                        lParam := (y << 16) | (x & 0xFFFF)

                                                                        ; Send mouse down and up messages
                                                                        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
                                                                        Sleep, 50
                                                                        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
                                                                        Sleep, 50
                                                                        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
                                                                        Sleep, 50
                                                                        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
                                                                    }

                                                                    ; ========= SAVE/LOAD ALL CHECKBOX SETTINGS =========
                                                                    SaveAllSettings:
                                                                        Gui, Submit, NoHide
                                                                        SaveAllCheckboxStates()
                                                                        MsgBox, 64, Settings Saved, All checkbox settings have been saved to INI file!
                                                                    return

                                                                    SaveAllCheckboxStates() {
                                                                        global iniFile
                                                                        global healanddps, dpstargetedhealing, returnafterheal, farming
                                                                        global destroyskypotionstimer, infinitemouse, ResurrectionEnabled
                                                                        global dpsNavEnabled, meleeAttackEnabled, SequentialDPSMode
                                                                        global refreshscrollEnabled
                                                                        global gnollbuff, dtbuff, NavCameraLockCheck

                                                                        FileEncoding, UTF-8
                                                                        ; Main tab checkboxes (excluding farming, dpstargetedhealing, destroyskypotionstimer - they always start unchecked)
                                                                        IniWrite, %healanddps%, %iniFile%, CheckboxStates, healanddps
                                                                        ; IniWrite, %dpstargetedhealing%, %iniFile%, CheckboxStates, dpstargetedhealing  ; Not saved - must be off by default
                                                                        IniWrite, %returnafterheal%, %iniFile%, CheckboxStates, returnafterheal
                                                                        ; IniWrite, %farming%, %iniFile%, CheckboxStates, farming  ; Not saved - must be off by default
                                                                        ; IniWrite, %destroyskypotionstimer%, %iniFile%, CheckboxStates, destroyskypotionstimer  ; Not saved - must be off by default
                                                                        IniWrite, %infinitemouse%, %iniFile%, CheckboxStates, infinitemouse
                                                                        IniWrite, %ResurrectionEnabled%, %iniFile%, CheckboxStates, ResurrectionEnabled
                                                                        IniWrite, %dpsNavEnabled%, %iniFile%, CheckboxStates, dpsNavEnabled

                                                                        ; DPS tab checkboxes
                                                                        IniWrite, %meleeAttackEnabled%, %iniFile%, CheckboxStates, meleeAttackEnabled
                                                                        IniWrite, %refreshscrollEnabled%, %iniFile%, CheckboxStates, refreshscrollEnabled
                                                                        IniWrite, %SequentialDPSMode%, %iniFile%, CheckboxStates, SequentialDPSMode

                                                                        ; Buffs tab checkboxes (excluding gnollbuff, dtbuff - they always start unchecked)
                                                                        ; IniWrite, %gnollbuff%, %iniFile%, CheckboxStates, gnollbuff  ; Not saved - must be off by default
                                                                        ; IniWrite, %dtbuff%, %iniFile%, CheckboxStates, dtbuff  ; Not saved - must be off by default

                                                                        ; Navigation tab checkboxes
                                                                        IniWrite, %NavCameraLockCheck%, %iniFile%, CheckboxStates, NavCameraLockCheck
                                                                        FileEncoding
                                                                    }

                                                                    LoadAllCheckboxStates() {
                                                                        global iniFile
                                                                        global healanddps, dpstargetedhealing, returnafterheal, farming
                                                                        global destroyskypotionstimer, infinitemouse, ResurrectionEnabled
                                                                        global dpsNavEnabled, meleeAttackEnabled, SequentialDPSMode
                                                                        global refreshscrollenabled
                                                                        global gnollbuff, dtbuff, NavCameraLockCheck

                                                                        ; Main tab checkboxes (excluding farming, dpstargetedhealing, destroyskypotionstimer - they always start unchecked)
                                                                        IniRead, healanddps, %iniFile%, CheckboxStates, healanddps, 0
                                                                        ; dpstargetedhealing always starts at 0 (not loaded from INI)
                                                                        dpstargetedhealing := 0
                                                                        IniRead, returnafterheal, %iniFile%, CheckboxStates, returnafterheal, 0
                                                                        ; farming always starts at 0 (not loaded from INI)
                                                                        farming := 0
                                                                        ; destroyskypotionstimer always starts at 0 (not loaded from INI)
                                                                        destroyskypotionstimer := 0
                                                                        IniRead, infinitemouse, %iniFile%, CheckboxStates, infinitemouse, 0
                                                                        IniRead, ResurrectionEnabled, %iniFile%, CheckboxStates, ResurrectionEnabled, 0
                                                                        IniRead, dpsNavEnabled, %iniFile%, CheckboxStates, dpsNavEnabled, 0

                                                                        ; DPS tab checkboxes
                                                                        IniRead, meleeAttackEnabled, %iniFile%, CheckboxStates, meleeAttackEnabled, 0
                                                                        IniRead, refreshscrollEnabled, %iniFile%, CheckboxStates, refreshscrollEnabled, 0
                                                                        IniRead, SequentialDPSMode, %iniFile%, CheckboxStates, SequentialDPSMode, 0

                                                                        ; Buffs tab checkboxes (excluding gnollbuff, dtbuff - they always start unchecked)
                                                                        ; gnollbuff always starts at 0 (not loaded from INI)
                                                                        gnollbuff := 0
                                                                        ; dtbuff always starts at 0 (not loaded from INI)
                                                                        dtbuff := 0

                                                                        ; Navigation tab checkboxes
                                                                        IniRead, NavCameraLockCheck, %iniFile%, CheckboxStates, NavCameraLockCheck, 1

                                                                        ; Update GUI controls to reflect loaded values
                                                                        GuiControl,, healanddps, %healanddps%
                                                                        GuiControl,, dpstargetedhealing, 0
                                                                        GuiControl,, returnafterheal, %returnafterheal%
                                                                        GuiControl,, farming, 0
                                                                        GuiControl,, destroyskypotionstimer, 0
                                                                        GuiControl,, infinitemouse, %infinitemouse%
                                                                        GuiControl,, ResurrectionEnabled, %ResurrectionEnabled%
                                                                        GuiControl,, dpsNavEnabled, %dpsNavEnabled%
                                                                        GuiControl,, meleeAttackEnabled, %meleeAttackEnabled%
                                                                        GuiControl,, refreshscrollEnabled, %refreshscrollEnabled%
                                                                        GuiControl,, SequentialDPSMode, %SequentialDPSMode%
                                                                        GuiControl,, gnollbuff, 0
                                                                        GuiControl,, dtbuff, 0
                                                                        GuiControl,, NavCameraLockCheck, %NavCameraLockCheck%
                                                                        ; Activate refresh scroll timer if enabled
                                                                        if (refreshscrollEnabled = 1 || refreshscrollEnabled = "1") {
                                                                            GuiControl, Show, refreshKey
                                                                            refreshScrollEndTime := A_TickCount + 3600000
                                                                            gosub, UseRefreshScroll
                                                                            SetTimer, UpdateRefreshScrollTimer, 1000
                                                                            SetTimer, userefreshscroll, 5000
                                                                        }

                                                                        ; Debug: Show what was loaded
                                                                        ; ToolTip, Loaded checkboxes: healanddps=%healanddps% farming=%farming% melee=%meleeAttackEnabled% sequential=%SequentialDPSMode%, 0, 0, 1
                                                                        SetTimer, RemoveLoadTooltip, -3000
                                                                    }

                                                                    LoadCheckboxStatesDelayed:
                                                                        ; Load all checkbox states from INI
                                                                        LoadAllCheckboxStates()

                                                                        ; Set the selectedKey dropdown to the loaded value
                                                                        GuiControl, Choose, selectedKey, %selectedKey%
                                                                        ; Set the DPS toggle hotkey control to the loaded value
                                                                        GuiControl,, DPSToggleHotkey, %DPSToggleHotkey%
                                                                        ; Set the melee attack input value
                                                                        GuiControl,, meleeAttackKey, %meleeAttackKey%
                                                                        ; Set the refresh scroll input value
                                                                        GuiControl,, refreshKey, %refreshKey%
                                                                        ; Set the max resurrections default value
                                                                        GuiControl,, MaxResurrectionsEdit, %MaxResurrections%
                                                                        ; Show/hide melee controls based on checkbox state
                                                                        if (meleeAttackEnabled = 1 || meleeAttackEnabled = "1") {
                                                                            GuiControl, Show, MeleeKeyLabel
                                                                            GuiControl, Show, meleeAttackKey
                                                                        } else {
                                                                            GuiControl, Hide, MeleeKeyLabel
                                                                            GuiControl, Hide, meleeAttackKey
                                                                        }
                                                                        if (refreshscrollEnabled = 1 || refreshscrollEnabled = "1") {
                                                                            GuiControl, Show, refreshKeyLabel
                                                                            GuiControl, Show, refreshKey
                                                                        } else {
                                                                            GuiControl, Hide, refreshKeyLabel
                                                                            GuiControl, Hide, refreshKey
                                                                        }

                                                                        ; Start death detection if auto-resurrection is enabled
                                                                        if (ResurrectionEnabled = 1 || ResurrectionEnabled = "1") {
                                                                            UpdateResurrectionStatus("Enabled - " . CurrentResurrections . "/" . MaxResurrections)
                                                                            StartDeathDetection()
                                                                        }
                                                                    return

                                                                    RemoveLoadTooltip:
                                                                        ToolTip,,,,1
                                                                    return

                                                                    LoadSettings() {
                                                                        global
                                                                        IniRead, pullAreas, %iniFile%, Settings, PullAreas, 3
                                                                        IniRead, clickLocations, %iniFile%, Settings, ClickLocations, 4
                                                                        IniRead, randomOffsetX, %iniFile%, Settings, RandomOffsetX, 5
                                                                        IniRead, randomOffsetY, %iniFile%, Settings, RandomOffsetY, 5
                                                                        IniRead, returnSleepTime, %iniFile%, Settings, ReturnSleepTime, 4500
                                                                        IniRead, mouseMoveDelay, %iniFile%, Settings, MouseMoveDelay, 90
                                                                        IniRead, mouseClickDelay, %iniFile%, Settings, MouseClickDelay, 50
                                                                        IniRead, selectedWindow, %iniFile%, Settings, SelectedWindow,
                                                                        IniRead, selectedKey, %iniFile%, Settings, FollowWhoKey, F2
                                                                        IniRead, DPSToggleHotkey, %iniFile%, Settings, DPSToggleHotkey, Insert
                                                                        ; Note: meleeAttackEnabled is loaded in LoadAllCheckboxStates()
                                                                        IniRead, meleeAttackKey, %SettingsFile%, Settings, meleeAttackKey, ""
                                                                        IniRead, refreshKey, %SettingsFile%, Settings, refreshKey, ""
                                                                        ;IniRead, refreshscrollEnabled, %SettingsFile%, Settings, refreshscrollEnabled, 0

                                                                        ; Apply to GUI after it's created
                                                                        GuiControl,, meleeAttackKey, %meleeAttackKey%
                                                                        GuiControl,, refreshKey, %refreshKey%
                                                                        GuiControl,, refreshscrollEnabled, %refreshscrollEnabled%

                                                                        ; Show/hide refresh key controls based on checkbox state
                                                                        if (refreshscrollEnabled) {
                                                                            GuiControl, Show, refreshKeyLabel
                                                                            GuiControl, Show, refreshKey
                                                                            ; Load Max Resurrections setting
                                                                            IniRead, MaxResurrections, %iniFile%, Settings, MaxResurrections, 8

                                                                            ; Set up DPS toggle hotkey if loaded
                                                                            if (DPSToggleHotkey != "" && DPSToggleHotkey != "ERROR") {
                                                                                hotkey, %DPSToggleHotkey%, ToggleDPSAction, On, UseErrorLevel
                                                                            }
                                                                        }

                                                                        IniRead, movementX1, %iniFile%, MovementArea, X1, 0
                                                                        IniRead, movementY1, %iniFile%, MovementArea, Y1, 0
                                                                        IniRead, movementX2, %iniFile%, MovementArea, X2, 0
                                                                        IniRead, movementY2, %iniFile%, MovementArea, Y2, 0

                                                                        IniRead, movement2X1, %iniFile%, MovementArea2, X1, 0
                                                                        IniRead, movement2Y1, %iniFile%, MovementArea2, Y1, 0
                                                                        IniRead, movement2X2, %iniFile%, MovementArea2, X2, 0
                                                                        IniRead, movement2Y2, %iniFile%, MovementArea2, Y2, 0
                                                                        IniRead, RandomDelayMin, %iniFile%, Delays, MinDelay
                                                                        IniRead, RandomDelayMax, %iniFile%, Delays, MaxDelay
                                                                        IniRead, pullHotkey, %iniFile%, Hotkeys, PullHotkey, 1
                                                                        if (movementX1 != 0 || movementY1 != 0 || movementX2 != 0 || movementY2 != 0)
                                                                            movementAreaSet := true
                                                                        if (movement2X1 != 0 || movement2Y1 != 0 || movement2X2 != 0 || movement2Y2 != 0)
                                                                            movementArea2Set := true

                                                                        clickCoords := []
                                                                        IniRead, coordCount, %iniFile%, ClickCoords, Count, 0
                                                                        Loop, %coordCount% {
                                                                            IniRead, coordX, %iniFile%, ClickCoords, X%A_Index%, 0
                                                                            IniRead, coordY, %iniFile%, ClickCoords, Y%A_Index%, 0
                                                                            IniRead, coordArea, %iniFile%, ClickCoords, Area%A_Index%, 1
                                                                            if (coordX != 0 || coordY != 0) {
                                                                                clickCoords.Push({x: coordX, y: coordY, area: coordArea})
                                                                            }
                                                                        }
                                                                    }

                                                                    SaveSettings() {
                                                                        global
                                                                        GuiControlGet, randomdelaymin,, randomdelaymin
                                                                        GuiControlGet, randomdelaymax,, randomdelaymax
                                                                        GuiControlGet, selectedKey,, selectedKey
                                                                        IniWrite, %pullAreas%, %iniFile%, Settings, PullAreas
                                                                        IniWrite, %clickLocations%, %iniFile%, Settings, ClickLocations
                                                                        IniWrite, %randomOffsetX%, %iniFile%, Settings, RandomOffsetX
                                                                        IniWrite, %randomOffsetY%, %iniFile%, Settings, RandomOffsetY
                                                                        IniWrite, %returnSleepTime%, %iniFile%, Settings, ReturnSleepTime
                                                                        IniWrite, %mouseMoveDelay%, %iniFile%, Settings, MouseMoveDelay
                                                                        IniWrite, %mouseClickDelay%, %iniFile%, Settings, MouseClickDelay
                                                                        IniWrite, ahk_id %win1%, %iniFile%, Settings, SelectedWindow
                                                                        IniWrite, %selectedKey%, %iniFile%, Settings, FollowWhoKey

                                                                        IniWrite, %movementX1%, %iniFile%, MovementArea, X1
                                                                        IniWrite, %movementY1%, %iniFile%, MovementArea, Y1
                                                                        IniWrite, %movementX2%, %iniFile%, MovementArea, X2
                                                                        IniWrite, %movementY2%, %iniFile%, MovementArea, Y2

                                                                        IniWrite, %movement2X1%, %iniFile%, MovementArea2, X1
                                                                        IniWrite, %movement2Y1%, %iniFile%, MovementArea2, Y1
                                                                        IniWrite, %movement2X2%, %iniFile%, MovementArea2, X2
                                                                        IniWrite, %movement2Y2%, %iniFile%, MovementArea2, Y2
                                                                        IniWrite, %RandomDelayMin%, %iniFile%, Delays, MinDelay
                                                                        IniWrite, %RandomDelayMax%, %iniFile%, Delays, MaxDelay
                                                                        IniWrite, %pullHotkey%, %iniFile%, Hotkeys, PullHotkey
                                                                        coordCount := clickCoords.Length()

                                                                        IniWrite, %coordCount%, %iniFile%, ClickCoords, Count
                                                                        Loop, %coordCount% {
                                                                            coord := clickCoords[A_Index]
                                                                            coordX := coord.x
                                                                            coordY := coord.y
                                                                            coordArea := coord.area

                                                                            IniWrite, %coordX%, %iniFile%, ClickCoords, X%A_Index%
                                                                            IniWrite, %coordY%, %iniFile%, ClickCoords, Y%A_Index%
                                                                            IniWrite, %coordArea%, %iniFile%, ClickCoords, Area%A_Index%
                                                                        }
                                                                        if (TargetGamePID && navCameraFile) {
                                                                            IniWrite, %TargetGamePID%, pathingsettings.ini, Settings, WindowPID
                                                                            IniWrite, %navCameraFile%, pathingsettings.ini, Settings, CameraFile
                                                                        }
                                                                        if (win2PID) {
                                                                            IniWrite, %win2PID%, pathingsettings.ini, Settings, Win2PID
                                                                        }

                                                                    }

                                                                    StartWindowMonitor:
                                                                        StartWindowMonitor()
                                                                    return

                                                                    StopWindowMonitor:
                                                                        StopWindowMonitor()
                                                                    return
                                                                    ; DPS Settings Update Functions
                                                                    UpdateDpsEnabled:
                                                                        Gui, Submit, NoHide
                                                                        dpsEnabled := DpsEnabledCheckbox
                                                                    statusText := dpsEnabled ? "DPS: Enabled" : "DPS: Disabled"
                                                                        GuiControl,, DpsStatusText, %statusText%
                                                                    return

                                                                    UpdateDpsHotkey:
                                                                        Gui, Submit, NoHide
                                                                        dpsHotkey := DpsHotkeyEdit
                                                                    return

                                                                    UpdateDpsDuration:
                                                                        Gui, Submit, NoHide
                                                                        dpsDuration := DpsDurationEdit
                                                                        ; Validate that it's a number
                                                                        if dpsDuration is not number
                                                                        {
                                                                            dpsDuration := 3000
                                                                            GuiControl,, DpsDurationEdit, %dpsDuration%
                                                                        }
                                                                    return

                                                                    TestDpsHotkey:
                                                                        if (dpsHotkey != "" && selectedWindow != "") {
                                                                            GuiControl,, DpsStatusText, Testing DPS hotkey...
                                                                            ExecuteDpsSequence()
                                                                            GuiControl,, DpsStatusText, DPS test completed
                                                                        } else {
                                                                            GuiControl,, DpsStatusText, Set hotkey and select window first
                                                                        }
                                                                    return

                                                                    SaveDpsSettings:
                                                                        Gui, Submit, NoHide
                                                                        ; You can add file saving logic here if needed
                                                                        GuiControl,, DpsStatusText, DPS settings saved
                                                                    return

                                                                    ; DPS Execution Function
                                                                    ExecuteDpsSequence() {
                                                                        if (dpsHotkey = "" || selectedWindow = "")
                                                                            return
                                                                        sendlevel 1

                                                                        send, {%dpsHotkey% down}

                                                                        Sleep, %dpsDuration%

                                                                        send, {%dpsHotkey% up}
                                                                        sendlevel 0
                                                                    }

                                                                    UpdatePullAreas:
                                                                        GuiControlGet, pullAreas,, PullAreasEdit
                                                                    return

                                                                    UpdateClickLocations:
                                                                        GuiControlGet, clickLocations,, ClickLocationsEdit
                                                                    return

                                                                    UpdateOffsetX:
                                                                        GuiControlGet, randomOffsetX,, OffsetXEdit
                                                                    return

                                                                    UpdateOffsetY:
                                                                        GuiControlGet, randomOffsetY,, OffsetYEdit
                                                                    return

                                                                    UpdateSleepTime:
                                                                        GuiControlGet, returnSleepTime,, SleepTimeEdit
                                                                    return

                                                                    UpdateMouseMoveDelay:
                                                                        GuiControlGet, mouseMoveDelay,, MouseMoveDelayEdit
                                                                    return

                                                                    UpdateMouseClickDelay:
                                                                        GuiControlGet, mouseClickDelay,, MouseClickDelayEdit
                                                                    return

                                                                    SaveDelaySettings:
                                                                        GuiControlGet, mouseMoveDelay,, MouseMoveDelayEdit
                                                                        GuiControlGet, mouseClickDelay,, MouseClickDelayEdit
                                                                        GuiControlGet, returnSleepTime,, SleepTimeEdit

                                                                        ; Add these lines to get the random delay values:
                                                                        GuiControlGet, randomdelaymin,, randomdelaymin
                                                                        GuiControlGet, randomdelaymax,, randomdelaymax

                                                                        SaveSettings()
                                                                    return

                                                                    SetMovementArea:
                                                                        Gui, Hide
                                                                        MsgBox, 4,, Click OK then drag to select movement detection area
                                                                        IfMsgBox, Yes
                                                                        {
                                                                            Gui, 2:New, +AlwaysOnTop -Caption +ToolWindow +Border, Selection
                                                                            Gui, 2:Color, Red

                                                                            CoordMode, Mouse, Screen
                                                                            KeyWait, LButton, U
                                                                            KeyWait, LButton, D
                                                                            MouseGetPos, movementX1, movementY1

                                                                            Gui, 2:Show, x%movementX1% y%movementY1% w1 h1
                                                                            WinSet, Transparent, 128, Selection

                                                                            while GetKeyState("LButton", "P") {
                                                                                MouseGetPos, currentX, currentY
                                                                                boxX := movementX1 < currentX ? movementX1 : currentX
                                                                                boxY := movementY1 < currentY ? movementY1 : currentY
                                                                                boxW := Abs(currentX - movementX1)
                                                                                boxH := Abs(currentY - movementY1)
                                                                                Gui, 2:Show, x%boxX% y%boxY% w%boxW% h%boxH%
                                                                                Sleep, 10
                                                                            }

                                                                            MouseGetPos, movementX2, movementY2
                                                                            Gui, 2:Destroy

                                                                            if (movementX1 > movementX2) {
                                                                                temp := movementX1
                                                                                movementX1 := movementX2
                                                                                movementX2 := temp
                                                                            }
                                                                            if (movementY1 > movementY2) {
                                                                                temp := movementY1
                                                                                movementY1 := movementY2
                                                                                movementY2 := temp
                                                                            }

                                                                            movementAreaSet := true

                                                                            MsgBox, 4,, Set optional second movement area?
                                                                            IfMsgBox, Yes
                                                                            {
                                                                                Gui, 2:New, +AlwaysOnTop -Caption +ToolWindow +Border, Selection2
                                                                                Gui, 2:Color, Blue

                                                                                KeyWait, LButton, U
                                                                                KeyWait, LButton, D
                                                                                MouseGetPos, movement2X1, movement2Y1

                                                                                Gui, 2:Show, x%movement2X1% y%movement2Y1% w1 h1
                                                                                WinSet, Transparent, 128, Selection2

                                                                                while GetKeyState("LButton", "P") {
                                                                                    MouseGetPos, currentX, currentY
                                                                                    boxX := movement2X1 < currentX ? movement2X1 : currentX
                                                                                    boxY := movement2Y1 < currentY ? movement2Y1 : currentY
                                                                                    boxW := Abs(currentX - movement2X1)
                                                                                    boxH := Abs(currentY - movement2Y1)
                                                                                    Gui, 2:Show, x%boxX% y%boxY% w%boxW% h%boxH%
                                                                                    Sleep, 10
                                                                                }

                                                                                MouseGetPos, movement2X2, movement2Y2
                                                                                Gui, 2:Destroy

                                                                                if (movement2X1 > movement2X2) {
                                                                                    temp := movement2X1
                                                                                    movement2X1 := movement2X2
                                                                                    movement2X2 := temp
                                                                                }
                                                                                if (movement2Y1 > movement2Y2) {
                                                                                    temp := movement2Y1
                                                                                    movement2Y1 := movement2Y2
                                                                                    movement2Y2 := temp
                                                                                }

                                                                                movementArea2Set := true
                                                                                GuiControl,, MovementStatus, Areas: Set (2)
                                                                            } else {
                                                                                GuiControl,, MovementStatus, Area: Set (1)
                                                                            }

                                                                            SaveSettings()
                                                                        }
                                                                        Gui, 1:Show,, Templar Puller
                                                                    return

                                                                    SetClickLocations:
                                                                        ;MsgBox, YES
                                                                        ReturnToMainCharacter()

                                                                        clickCoords := []
                                                                        totalClicks := pullAreas * clickLocations

                                                                        GuiControl,, StatusText, Click %totalClicks% locations. Current: 1

                                                                        Loop, %totalClicks% {
                                                                            MsgBox, 4,, Right Click location %A_Index% of %totalClicks%
                                                                            IfMsgBox, Yes
                                                                            {
                                                                                KeyWait, rbutton, D
                                                                                keywait, rbutton, U
                                                                                CoordMode, Mouse, Screen
                                                                                MouseGetPos, clickX, clickY
                                                                                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                                                                ; Account for window border/title bar
                                                                                borderX := 8
                                                                                borderY := 31
                                                                                relativeX := clickX - winX - borderX
                                                                                relativeY := clickY - winY - borderY

                                                                                clickCoords.Push({x: relativeX, y: relativeY, area: Ceil(A_Index / clickLocations)})
                                                                                GuiControl,, StatusText, Click %totalClicks% locations. Current: %A_Index%

                                                                                if (Mod(A_Index, clickLocations) = 0 && A_Index < totalClicks) {
                                                                                    ReturnToMainCharacter()
                                                                                }

                                                                                Sleep, 200
                                                                            }
                                                                            else
                                                                            {
                                                                                break
                                                                            }
                                                                        }

                                                                        coordsCount := clickCoords.Length()
                                                                        SaveSettings()
                                                                        if (coordsCount = totalClicks) {
                                                                            GuiControl,, StatusText, Status: Ready to start pulling!
                                                                        } else {
                                                                            GuiControl,, StatusText, Status: Setup incomplete.
                                                                        }
                                                                    return

                                                                    StartPulling:

                                                                        coordsCount := clickCoords.Length()
                                                                        if (!movementAreaSet || coordsCount = 0) {
                                                                            MsgBox, Please set movement area and click locations first!
                                                                            return
                                                                        }

                                                                        if (selectedWindow != "") {
                                                                            ;WinActivate, ahk_id %win1%
                                                                            Sleep, 200
                                                                        }

                                                                        pullingActive := true
                                                                        currentPullArea := 1
                                                                        currentClickIndex := 1

                                                                        SetTimer, PullingLoop, 50
                                                                        GuiControl,, StatusText, Status: Pulling active...
                                                                    return

                                                                    StopPulling:
                                                                        pullingActive := false
                                                                        SetTimer, PullingLoop, Off
                                                                        GuiControl,, StatusText, Status: Stopped.
                                                                    return

                                                                    ReturnToCharacter:
                                                                        if (selectedWindow != "") {
                                                                            ;WinActivate, ahk_id %win1%
                                                                            Sleep, 200
                                                                        }
                                                                        ReturnToMainCharacter()
                                                                    return

                                                                    SaveCoords:
                                                                        SaveSettings()
                                                                        GuiControl,, StatusText, Status: Coordinates saved to INI file.
                                                                    return

                                                                    LoadCoords:
                                                                        LoadSettings()
                                                                        coordsCount := clickCoords.Length()
                                                                        GuiControl,, StatusText, Status: Loaded %coordsCount% coordinates from INI file.
                                                                    return

                                                                    ; Updated Pulling Loop with DPS Integration
                                                                    PullingLoop:

                                                                        if (!pullingActive)
                                                                            return
                                                                        CoordMode, Pixel, Screen
                                                                        coordmode, mouse, screen
                                                                        areaClicks := []
                                                                        for index, coord in clickCoords {
                                                                            if (coord["area"] = currentPullArea) {
                                                                                areaClicks.Push({x: coord["x"], y: coord["y"], originalIndex: index})
                                                                            }
                                                                        }
                                                                        CoordMode, mouse, client
                                                                        areaClicksCount := areaClicks.Length()

                                                                        if (currentClickIndex <= areaClicksCount) {
                                                                            coord := areaClicks[currentClickIndex]
                                                                            offsetX := Random(-randomOffsetX, randomOffsetX)
                                                                            offsetY := Random(-randomOffsetY, randomOffsetY)

                                                                            clickX := coord["x"] + offsetX
                                                                            clickY := coord["y"] + offsetY

                                                                            ControlSend,, 1, ahk_id %win1% 
                                                                            Sleep, 80
                                                                            origX := coord["x"]
                                                                            origY := coord["y"]

                                                                            lParam1 := clickX | (clickY << 16)
                                                                            SendMessage, 0x0200, 0x0000, %lParam1%,, ahk_id %win1%
                                                                            Sleep, %mouseMoveDelay%
                                                                            SendMessage, 0x0201, 0x0000, %lParam1%,, ahk_id %win1%
                                                                            Sleep, %mouseClickDelay%
                                                                            SendMessage, 0x0202, 0x0000, %lParam1%,, ahk_id %win1%
                                                                            Random, randomdelay, %RandomDelayMin%, %RandomDelayMax%
                                                                            Sleep, %randomdelay%
                                                                            if (movingg)
                                                                            {
                                                                                WaitForMovementStop()
                                                                            }
                                                                            if (healanddps)
                                                                            {
                                                                                gosub, DynamicHealthCheck
                                                                            }
                                                                            if (templardps)
                                                                            {
                                                                                TryCastCC()
                                                                                TryCastDPSSkills()
                                                                            }
                                                                            ;Check DPS Navigation if enabled
                                                                            if (dpsNavEnabled && dpsNavTargetX != "" && dpsNavTargetY != "") {
                                                                                Loop {
                                                                                    CheckDPSNavigation()
                                                                                    GetNavCurrentCoordinates(currentX, currentY)
                                                                                    if (Abs(currentX - dpsNavTargetX) <= 50 && Abs(currentY - dpsNavTargetY) <= 50) {
                                                                                        controlsend,, {tab}, ahk_id %win1%
                                                                                        break
                                                                                    }
                                                                                    Sleep, 100
                                                                                }
                                                                                if (arrived)
                                                                                {
                                                                                    ; SendMessageClick3(pylonPos1X, pylonPos1Y, win1)
                                                                                    ; Sleep, 100
                                                                                    ; SendMessageClick3(pylonPos2X, pylonPos2Y, win1)
                                                                                    ; Sleep, 100
                                                                                    ; SendMessageClick3(pylonPos2X, pylonPos2Y, win1)
                                                                                    ; Sleep, 100
                                                                                    ; SendMessageClick3(pylonPos2X, pylonPos2Y, win1)
                                                                                    ; Sleep, 100
                                                                                    ; decopetorplayertargetted:="|<>7D7D7D-0.90$71.000000000000000000000000000000000000000000000000S0000G00S0U0W0000U00a1012xvqzgLV5zU25+4c+Id2OI04DsEHofz7jc08QEUgdJU8ME0F8FZNGN0EEU0wSxuSoXkUxk00000000000000000000000000000000000000000000000000000000000E"

                                                                                    ; decopetorplayertargetted.="|<>*86$56.zzzzzzzzzzzzzzzzzzzzzzzzzzzzzyTzzzrjvzz3zzzzlwTzUTxyRyCDzk3m8WTl7zs0QFF7y3zw03081zlzy00zkTzsDz00TyDzwFzU0DzrzyCDk07zzzz7lw03zzzzvyzU1y000zzzw0zzzzzzzzcTzzzzzzzxDzzzzzzzzbzzzzzzzzzzzzzzzzy"

                                                                                    ; if (ok:=FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, decopetorplayertargetted))
                                                                                    ; {
                                                                                    sendmessage, 0x100, ox1b, 0, , ahk_id %win1% ; esc_KEYDOWN
                                                                                    Sleep, 50
                                                                                    sendmessage, 0x101, ox1b, 0, , ahk_id %win1% ; esc_KEYUP
                                                                                    sendmessage, 0x100, ox1b, 0, , ahk_id %win1% ; esc_KEYDOWN
                                                                                    Sleep, 50
                                                                                    sendmessage, 0x101, ox1b, 0, , ahk_id %win1% ; esc_KEYUP

                                                                                    ;}
                                                                                    arrived := false
                                                                                }

                                                                            }

                                                                            currentClickIndex++
                                                                            GuiControl,, StatusText, Status: Area %currentPullArea%, Click %currentClickIndex%/%areaClicksCount%
                                                                        } else {
                                                                            if (autofolloww = true)
                                                                            {
                                                                                ReturnToMainCharacter()
                                                                            }

                                                                            ; NEW: DPS Logic after returning to character
                                                                            if (dpsEnabled && dpsHotkey != "") {
                                                                                GuiControl,, StatusText, Status: Executing DPS sequence...
                                                                                Sleep, 500 ; Small delay after returning to character
                                                                                ExecuteDpsSequence()
                                                                                GuiControl,, StatusText, Status: DPS sequence completed
                                                                                Sleep, 200 ; Small delay after DPS
                                                                            }

                                                                            currentPullArea++
                                                                            currentClickIndex := 1

                                                                            if (currentPullArea > pullAreas) {
                                                                                currentPullArea := 1
                                                                            }

                                                                            GuiControl,, StatusText, Status: Moving to area %currentPullArea%
                                                                        }
                                                                    return
                                                                    StartWindowMonitor() {
                                                                        global MonitorWindowID, BaselinePixels, MonitorActive

                                                                        ; Use your existing selected window
                                                                        MonitorWindowID := win1 ; Replace with your window variable

                                                                        if (!MonitorWindowID || MonitorWindowID = "") {
                                                                            MsgBox, No window selected! Please select a window first.
                                                                            return
                                                                        }

                                                                        ; Take baseline screenshot of the area
                                                                        TakeBaselineSnapshot()

                                                                        if (BaselinePixels != "") {
                                                                            MonitorActive := true
                                                                            SetTimer, CheckWindowArea, 2000 ; Check every 2 seconds
                                                                            MsgBox, 0, Monitor, Window monitoring started! Baseline captured., 1
                                                                        } else {
                                                                            MsgBox, 0, Monitor, Failed to capture baseline!, 2
                                                                        }
                                                                    }

                                                                    ; Stop monitoring
                                                                    StopWindowMonitor() {
                                                                        global MonitorActive
                                                                        MonitorActive := false
                                                                        SetTimer, CheckWindowArea, Off
                                                                        MsgBox, 0, Monitor, Window monitoring stopped!, 1
                                                                    }

                                                                    ; Take baseline screenshot using multiple pixel sampling
                                                                    TakeBaselineSnapshot() {
                                                                        global MonitorWindowID, BaselinePixels

                                                                        ; Get window position
                                                                        WinGetPos, winX, winY,,, ahk_id %MonitorWindowID%

                                                                        if (winX = "" || winY = "") {
                                                                            BaselinePixels := ""
                                                                            return
                                                                        }

                                                                        ; Sample multiple pixels across the area for comparison
                                                                        BaselinePixels := ""

                                                                        ; Sample 9 points across the area (3x3 grid)
                                                                        Loop, 3 {
                                                                            row := A_Index
                                                                            Loop, 3 {
                                                                                col := A_Index

                                                                                ; Calculate pixel position
                                                                                pixelX := winX + 8 + ((148-8) * col / 4)
                                                                                pixelY := winY + 28 + ((58-28) * row / 4)

                                                                                ; Get pixel color
                                                                                PixelGetColor, color, %pixelX%, %pixelY%, RGB
                                                                                BaselinePixels .= color . "|"
                                                                            }
                                                                        }

                                                                        ; Remove trailing |
                                                                        BaselinePixels := RTrim(BaselinePixels, "|")
                                                                    }

                                                                    ; Check if area has changed
                                                                    CheckWindowArea:
                                                                        global MonitorWindowID, BaselinePixels, MonitorActive

                                                                        if (!MonitorActive)
                                                                            return

                                                                        ; Check if window still exists
                                                                        WinGetPos, winX, winY,,, ahk_id %MonitorWindowID%

                                                                        if (winX = "" || winY = "") {
                                                                            MsgBox, 0, Monitor, Target window lost - stopping monitor!, 2
                                                                            StopWindowMonitor()
                                                                            return
                                                                        }

                                                                        ; Sample the same pixels
                                                                        CurrentPixels := ""

                                                                        ; Sample same 9 points
                                                                        Loop, 3 {
                                                                            row := A_Index
                                                                            Loop, 3 {
                                                                                col := A_Index

                                                                                ; Calculate pixel position
                                                                                pixelX := winX + 8 + ((148-8) * col / 4)
                                                                                pixelY := winY + 28 + ((58-28) * row / 4)

                                                                                ; Get pixel color
                                                                                PixelGetColor, color, %pixelX%, %pixelY%, RGB
                                                                                CurrentPixels .= color . "|"
                                                                            }
                                                                        }

                                                                        ; Remove trailing |
                                                                        CurrentPixels := RTrim(CurrentPixels, "|")

                                                                        ; Compare pixel patterns
                                                                        if (CurrentPixels != BaselinePixels) {
                                                                            ; Area changed - reload script
                                                                            MsgBox, 0, Monitor, Area changed detected - Reloading script!, 1
                                                                            Reload
                                                                        }
                                                                    return
                                                                    WaitForMovementStopold() {
                                                                        if (!movementAreaSet)
                                                                            return

                                                                        centerX := movementX1 + (movementX2 - movementX1) // 2
                                                                        centerY := movementY1 + (movementY2 - movementY1) // 2

                                                                        if (!movementArea2Set) {
                                                                            PixelGetColor, initialColor, %centerX%, %centerY%
                                                                            Loop, 20 {
                                                                                Sleep, 50
                                                                                PixelGetColor, currentColor, %centerX%, %centerY%
                                                                                if (currentColor != initialColor)
                                                                                    break
                                                                            }
                                                                            Loop {
                                                                                PixelGetColor, color1, %centerX%, %centerY%
                                                                                Sleep, 50
                                                                                PixelGetColor, color2, %centerX%, %centerY%
                                                                                if (color1 = color2) {
                                                                                    sleep, 120
                                                                                    break
                                                                                }
                                                                            }
                                                                            return
                                                                        }

                                                                        center2X := movement2X1 + (movement2X2 - movement2X1) // 2
                                                                        center2Y := movement2Y1 + (movement2Y2 - movement2Y1) // 2

                                                                        PixelGetColor, initialColor, %centerX%, %centerY%
                                                                        PixelGetColor, initial2Color, %center2X%, %center2Y%

                                                                        Loop, 20{
                                                                            Sleep, 50
                                                                            PixelGetColor, currentColor, %centerX%, %centerY%
                                                                            if (currentColor != initialColor)
                                                                                break
                                                                            PixelGetColor, current2Color, %center2X%, %center2Y%
                                                                            if (current2Color != initial2Color)
                                                                                break
                                                                        }

                                                                        checkArea1 := true
                                                                        Loop {
                                                                            if (checkArea1) {
                                                                                PixelGetColor, color1, %centerX%, %centerY%
                                                                                Sleep, 50
                                                                                PixelGetColor, color2, %centerX%, %centerY%
                                                                                if (color1 = color2) {
                                                                                    sleep, 50
                                                                                    break
                                                                                }
                                                                            } else {
                                                                                PixelGetColor, color1, %center2X%, %center2Y%
                                                                                Sleep, 50
                                                                                PixelGetColor, color2, %center2X%, %center2Y%
                                                                                if (color1 = color2) {
                                                                                    sleep, 50
                                                                                    break
                                                                                }
                                                                            }
                                                                            checkArea1 := !checkArea1
                                                                        }
                                                                    }

                                                                    WaitForMovementStop() {
                                                                        if (!movementAreaSet)
                                                                            return

                                                                        centerX := movementX1 + (movementX2 - movementX1) // 2
                                                                        centerY := movementY1 + (movementY2 - movementY1) // 2

                                                                        ; Wait for movement to stop with stability checking
                                                                        stabilityCount := 0
                                                                        PixelGetColor, lastColor, %centerX%, %centerY%, RGB Fast

                                                                        Loop {
                                                                            Sleep, 40
                                                                            PixelGetColor, currentColor, %centerX%, %centerY%, RGB Fast

                                                                            if (currentColor = lastColor) {
                                                                                stabilityCount++
                                                                                if (stabilityCount >= 4) { ; 4 stable readings = ~160ms stable
                                                                                    break
                                                                                }
                                                                            } else {
                                                                                stabilityCount := 0
                                                                                lastColor := currentColor
                                                                            }
                                                                        }

                                                                        Sleep, 50 ; Small final delay
                                                                    }

                                                                    ReturnToMainCharacter() {
                                                                        global selectedKey, TargetGameWindow

                                                                        selectedcharacteroptions := "|<>*74$17.zzzzzzzzzzzlE44F44IE0E04404EDxzzzzzzy003zzw"
                                                                        selectedcharacteroptions .= "|<>**50$18.zzz51F8W90I108131V1X10q10Q1zzzU"

                                                                        follow := "|<>**50$48.0000000000000000000000000000000007sT00000Dsz0000CBDpzz00FBxpjz00FBPJPh00FBLIvp00TBrIur00lhTJuP00UhMp7v00UjDzzy00UU000000zU000000U0000000U0000000U"
                                                                        follow .= "|<>**50$49.ldyjzs004rnKTw002OqerO001B7Iup003aveR/U00PLpSak005f6crM002wzzzs00100000007U0000002"

                                                                        ; Use the selected key from the dropdown (default F2)
                                                                    keyToSend := selectedKey != "" ? selectedKey : "F2"
                                                                        ControlSend,, {%keyToSend%}, ahk_id %TargetGameWindow% 
                                                                        Sleep, 200

                                                                        foundOptions := false
                                                                        Loop, 20 {
                                                                            if (FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, selectedcharacteroptions)) {
                                                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                                                relativeX := X - winX
                                                                                relativeY := Y - winY
                                                                                ControlClick, x%relativeX% y%relativeY%, ahk_id %TargetGameWindow%
                                                                                Sleep, 10
                                                                                foundOptions := true
                                                                                break
                                                                            }
                                                                            Sleep, 50
                                                                        }

                                                                        if (!foundOptions)
                                                                            return

                                                                        Loop, 20 {
                                                                            if (FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, follow)) {
                                                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                                                relativeX := X - winX
                                                                                relativeY := Y - winY
                                                                                ControlClick, x%relativeX% y%relativeY%, ahk_id %TargetGameWindow%
                                                                                Sleep, 10
                                                                                ; if (moving)
                                                                                ; {
                                                                                ;     WaitForMovementStop()
                                                                                ; }

                                                                                ; Sleep, %returnSleepTime%
                                                                                ; ControlSend,, {Escape}{Escape}{Escape}, ahk_id %win1% 
                                                                                break
                                                                            }
                                                                            Sleep, 50
                                                                        }
                                                                    }

                                                                    Random(min, max) {
                                                                        Random, result, %min%, %max%
                                                                    return result
                                                                }

                                                                ; Function to set random KeyDelay

                                                                SetRandomKeyDelay() {
                                                                    global

                                                                    Random, delay, RandomKeyDelayMin, RandomKeyDelayMax
                                                                    Random, pressDuration, RandomKeyPressDurationMin, RandomKeyPressDurationMax

                                                                    CurrentKeyDelay := delay
                                                                    CurrentPressDuration := pressDuration

                                                                    SetKeyDelay, %delay%, %pressDuration%
                                                                }

                                                                ; Disable node/waypoint dragging - nodes and waypoints are click-through
                                                                ; SetTimer, MonitorNodeDragging, 50

                                                                MonitorNodeDragging:
                                                                    ; Dragging disabled - nodes and waypoints are now click-through only
                                                                return

                                                                ; Old dragging code kept for reference but disabled
    /*
    ; Check if left mouse button is pressed over a node or waypoint GUI
    if (GetKeyState("LButton", "P")) {
        if (!NodeBeingDragged && !WaypointBeingDragged) {
            ; Check if mouse is over any node or waypoint GUI
            MouseGetPos,,, hoveredWin
            hoveredWinTitle := ""
            WinGetTitle, hoveredWinTitle, ahk_id %hoveredWin%
            
            ; Check if it's a target node GUI
            if (InStr(hoveredWinTitle, "TargetNode")) {
                ; Extract node ID from window title (format: "TargetNode1", "TargetNode2", etc.)
                nodeID := StrReplace(hoveredWinTitle, "TargetNode", "")
                if (nodeID > 0) {
                    NodeBeingDragged := true
                    DraggedNodeID := nodeID
                    ; Pause update timer while dragging
                    SetTimer, UpdateAllTargetNodes, Off
                }
            }
            ; Check if it's a waypoint GUI
            else if (InStr(hoveredWinTitle, "WaypointGUI")) {
                ; Extract waypoint index from window title (format: "WaypointGUI1", "WaypointGUI2", etc.)
                waypointIndex := StrReplace(hoveredWinTitle, "WaypointGUI", "")
                if (waypointIndex > 0) {
                    WaypointBeingDragged := true
                    DraggedWaypointIndex := waypointIndex
                    ; Pause update timer while dragging
                    SetTimer, UpdateAllWaypoints, Off
                }
            }
        }
    } else {
        ; Left button released
        if (NodeBeingDragged) {
            ; Update the world coordinates of the dragged node
            UpdateNodeWorldCoordinates(DraggedNodeID)
            NodeBeingDragged := false
            DraggedNodeID := 0
            ; Resume update timer after a longer delay to let position settle
            SetTimer, ResumeNodeUpdates, -1000
        }
        if (WaypointBeingDragged) {
            ; Update the world coordinates of the dragged waypoint
            UpdateWaypointWorldCoordinates(DraggedWaypointIndex)
            WaypointBeingDragged := false
            DraggedWaypointIndex := 0
            ; Resume update timer after a longer delay to let position settle
            SetTimer, ResumeWaypointUpdates, -1000
        }
    }
                                                                */
                                                                return

                                                                ResumeNodeUpdates:
                                                                    if (TargetNodes.Length() > 0) {
                                                                        SetTimer, UpdateAllTargetNodes, 500
                                                                    }
                                                                return

                                                                ResumeWaypointUpdates:
                                                                    if (Waypoints.Length() > 0) {
                                                                        SetTimer, UpdateAllWaypoints, 500
                                                                    }
                                                                return

                                                                WM_LBUTTONDOWN() {
                                                                    PostMessage, 0xA1, 2
                                                                return
                                                            }

                                                            SetMovementMode:
                                                                Gui, Submit, NoHide
                                                                if (ClickMode) {
                                                                    MovementMode := "click"
                                                                    GuiControl,, MovementStatus, Mode: Click-to-Move
                                                                } else if (WASDMode) {
                                                                    MovementMode := "wasd"
                                                                    GuiControl,, MovementStatus, Mode: WASD Movement
                                                                }
                                                            return

                                                            SaveClickDistance:
                                                                Gui, Submit, NoHide
                                                                if (MaxClickEdit > 0 && MaxClickEdit <= 200) {
                                                                    MaxClickDistance := MaxClickEdit
                                                                    MsgBox, 0,, Max click distance set to %MaxClickDistance% pixels, 1
                                                                } else {
                                                                    MsgBox, 0, Error, Please enter a value between 1-200 pixels!
                                                                }
                                                            return

                                                            SaveTolerance:
                                                                Gui, Submit, NoHide
                                                                if (ToleranceX > 0 && ToleranceY > 0) {
                                                                    DistanceToleranceX := ToleranceX
                                                                    DistanceToleranceY := ToleranceY
                                                                    MsgBox, 0,, Tolerance set to X:%DistanceToleranceX% Y:%DistanceToleranceY%, 1
                                                                } else {
                                                                    MsgBox, 0, Error, Please enter valid positive numbers!
                                                                }
                                                            return

                                                            WaypointCmds:
                                                                if (!SelectedRouteFile) {
                                                                    MsgBox, 0, Error, Please select a route file first!
                                                                    return
                                                                }
                                                                ShowWaypointCommandsGUI()
                                                            return

                                                            ShowWaypointCommandsGUI() {
                                                                global
                                                                Gui, Commands: New, +ToolWindow, Waypoint Commands
                                                                Gui, Commands: Color, 0x2d2d30
                                                                Gui, Commands: Font, s8 cWhite, Segoe UI

                                                                Gui, Commands: Add, Text, x10 y10 w400 h15 c0x007ACC Center, WAYPOINT COMMAND EDITOR

                                                                ; Waypoint selection section
                                                                Gui, Commands: Add, Text, x10 y35 w80 h15 cWhite, Waypoint Number:
                                                                Gui, Commands: Add, Edit, x95 y32 w40 h22 vWaypointNum Background0xFFFFFF cBlack
                                                                Gui, Commands: Add, Button, x140 y30 w70 h25 gLoadWaypointCmd, Load
                                                                Gui, Commands: Add, Button, x215 y30 w70 h25 gShowExamples, Examples
                                                                Gui, Commands: Add, Button, x290 y30 w70 h25 gListWaypoints, List Points
                                                                Gui, Commands: Add, Button, x365 y30 w70 h25 gSelectWin2, Select Win2

                                                                ; Command editing area
                                                                Gui, Commands: Add, Text, x10 y65 w440 h15 cWhite, Command Editor (simple commands, functions, and full scripts):
                                                                Gui, Commands: Add, Edit, x10 y85 w440 h140 vCommandText Multi VScroll Background0xFFFFFF cBlack

                                                                ; Action buttons
                                                                Gui, Commands: Add, Button, x10 y235 w75 h25 gSaveWaypointCmd, Save
                                                                Gui, Commands: Add, Button, x90 y235 w75 h25 gClearWaypointCmd, Clear
                                                                Gui, Commands: Add, Button, x170 y235 w75 h25 gTestWaypointCmd, Test
                                                                Gui, Commands: Add, Button, x370 y235 w80 h25 gCloseCommandGUI, Close

                                                                ; Status line
                                                                Gui, Commands: Add, Text, x10 y270 w440 h15 vCommandStatus cWhite, Ready to edit commands

                                                                Gui, Commands: Show, w460 h295
                                                            }

                                                            LoadWaypointCmd:
                                                                Gui, Commands: Submit, NoHide
                                                                if (WaypointNum && WaypointCommands.HasKey(WaypointNum)) {
                                                                    GuiControl, Commands:, CommandText, % WaypointCommands[WaypointNum]
                                                                    GuiControl, Commands:, CommandStatus, Loaded command for waypoint %WaypointNum%
                                                                } else {
                                                                    ; Try loading directly from INI in case it wasn't loaded into memory
                                                                    IniRead, command, %SelectedRouteFile%, Commands, Waypoint%WaypointNum%, ERROR
                                                                    if (command != "ERROR") {
                                                                        ; Convert delimiter back to newlines
                                                                        command := StrReplace(command, "||NEWLINE||", "`n")
                                                                        WaypointCommands[WaypointNum] := command
                                                                        GuiControl, Commands:, CommandText, %command%
                                                                        GuiControl, Commands:, CommandStatus, Loaded command for waypoint %WaypointNum%
                                                                    } else {
                                                                        GuiControl, Commands:, CommandText,
                                                                        GuiControl, Commands:, CommandStatus, No command found for waypoint %WaypointNum%
                                                                        }
                                                                }
                                                            return

                                                            SaveWaypointCmd:
                                                                Gui, Commands: Submit, NoHide
                                                                if (WaypointNum && CommandText) {
                                                                    ; Convert newlines to a delimiter for INI storage
                                                                    commandForStorage := StrReplace(CommandText, "`n", "||NEWLINE||")
                                                                    commandForStorage := StrReplace(commandForStorage, "`r", "") ; Remove carriage returns

                                                                    WaypointCommands[WaypointNum] := CommandText
                                                                    ; Save command to the INI file with delimiter
                                                                    IniWrite, %commandForStorage%, %SelectedRouteFile%, Commands, Waypoint%WaypointNum%
                                                                    GuiControl, Commands:, CommandStatus, ✅ Command saved for waypoint %WaypointNum%
                                                                        MsgBox, 0,, Command saved for waypoint %WaypointNum%, 1
                                                                } else {
                                                                    GuiControl, Commands:, CommandStatus, ❌ Error: Please enter waypoint number and command!
                                                                    MsgBox, 0, Error, Please enter waypoint number and command!
                                                                }
                                                            return

                                                            ClearWaypointCmd:
                                                                Gui, Commands: Submit, NoHide
                                                                if (WaypointNum && WaypointCommands.HasKey(WaypointNum)) {
                                                                    WaypointCommands.Delete(WaypointNum)
                                                                    ; Remove command from INI file
                                                                    IniDelete, %SelectedRouteFile%, Commands, Waypoint%WaypointNum%
                                                                    GuiControl, Commands:, CommandText,
                                                                    GuiControl, Commands:, CommandStatus, 🗑️ Command cleared for waypoint %WaypointNum%
                                                                        MsgBox, 0,, Command cleared for waypoint %WaypointNum%, 1
                                                                } else {
                                                                    GuiControl, Commands:, CommandStatus, ❌ No command to clear for waypoint %WaypointNum%
                                                                    }
                                                            return

                                                            ListWaypoints:
                                                                waypointCount := Waypoints.Length()
                                                                if (waypointCount = 0) {
                                                                    GuiControl, Commands:, CommandStatus, ❌ No waypoints loaded in current route
                                                                    return
                                                                }

                                                                waypointList := "Available waypoints:`n"
                                                                for index, waypoint in Waypoints {
                                                                    hasCommand := WaypointCommands.HasKey(index) ? " 📝" : ""
                                                                        waypointList .= "Waypoint " . index . ": X=" . waypoint.x . " Y=" . waypoint.y . hasCommand . "`n"
                                                                    }

                                                                    MsgBox, 0, Waypoint List, %waypointList%
                                                                    return

                                                                    TestWaypointCmd:
                                                                        Gui, Commands: Submit, NoHide
                                                                        if (CommandText) {
                                                                            MsgBox, 4,, Test this waypoint command?`n`nThis will execute the command immediately.
                                                                            IfMsgBox Yes
                                                                            {
                                                                                ; Create a temporary waypoint entry and execute it
                                                                                tempWaypoint := 999
                                                                                WaypointCommands[tempWaypoint] := CommandText
                                                                                ExecuteWaypointCommands(tempWaypoint)
                                                                                WaypointCommands.Delete(tempWaypoint)
                                                                            }
                                                                        } else {
                                                                            MsgBox, 0, Error, Please enter a command to test!
                                                                        }
                                                                    return

                                                                    ShowExamples:
                                                                        exampleText := ""
                                                                        exampleText .= "==== AVAILABLE COMMANDS ====`n`n"

                                                                        exampleText .= "BASIC:`n"
                                                                        exampleText .= " sleep,milliseconds - Wait/delay`n"
                                                                        exampleText .= " send,{key} - Send keypress to active window`n"
                                                                        exampleText .= " controlsend,{key} - Send key to game window (background)`n"
                                                                        exampleText .= " msgbox,message - Show popup message`n"
                                                                        exampleText .= " tooltip,text - Display tooltip`n"
                                                                        exampleText .= " winactivate - Bring game window to front`n"
                                                                        exampleText .= " coords - Show current coordinates`n`n"
                                                                        exampleText .= " CheckAndExecuteTimerFlags() - Check and execute timer-based flags (AKA buffs/Dura/Etc)`n`n"

                                                                        exampleText .= "CLICKING:`n"
                                                                        exampleText .= " click,x,y - Click at screen coordinates`n"
                                                                        exampleText .= " controlclick,x,y - Click at window coordinates (background)`n"
                                                                        exampleText .= " holyground(delay, key, nodeNum) - Click at designated node`n"
                                                                        exampleText .= " worldclick,nodeNum - Click at saved node location`n"
                                                                        exampleText .= " shiftclick,nodeNum - Shift+click at node (for looting)`n`n"

                                                                        exampleText .= "PATTERNS:`n"
                                                                        exampleText .= " clickpattern,patternName - Find and click pattern`n"
                                                                        exampleText .= " controlclickpattern,patternName - Find and ctrl+click pattern`n"
                                                                        exampleText .= " loopclickuntilpatternfound,node1,node2,maxclickcount,pattern - Click nodes until pattern appears`n"
                                                                        exampleText .= " loopclickuntilpatternmissing,node,pattern,max,back - Click until pattern gone`n"
                                                                        exampleText .= " ifpatternfoundgoto,pattern,waypointNum - Skip to waypoint if pattern visible`n`n"
                                                                        exampleText .= " loopsearchuntilpatternfound,tries,pattern:`n"

                                                                        exampleText .= "COMBAT:`n"
                                                                        exampleText .= " trycastheal - Cast heal skill (from patterns)`n"
                                                                        exampleText .= " trycastdps - Cast DPS skill (with cooldown)`n"
                                                                        exampleText .= " loopcastuntilmobdead - Auto-combat until mob dies`n"
                                                                        exampleText .= " checkmobhealth - Check if mob health bar exists`n"
                                                                        exampleText .= " farmuntilpattern,patternName - Tab+kill mobs until pattern shows`n`n"

                                                                        exampleText .= "NETWORK COMMANDS (AHKsock):`n"
                                                                        exampleText .= " netskill,key,target - Send key to specific windows via network`n"
                                                                        exampleText .= " Examples: netskill,1,win1 | netskill,3,win1 win2 | netskill,F5,all`n"
                                                                        exampleText .= " netcombat,duration,target - Start combat on specific windows`n"
                                                                        exampleText .= " Examples: netcombat,10,win1 | netcombat,15,win2 win3 | netcombat,20,all`n"
                                                                        exampleText .= " netnav,target,destination - Navigate to waypoint or node`n"
                                                                        exampleText .= " Examples: netnav,all,WP 13 | netnav,win1 win2,NODE 3 | netnav,win1,WP 5`n`n"

                                                                        exampleText .= "NAVIGATION:`n"
                                                                        exampleText .= " gotowaypoint,waypointNum - Jump to specific waypoint`n"
                                                                        exampleText .= " goto,waypointNum - Same as gotowaypoint`n"
                                                                        exampleText .= " nextwaypoint - Skip to next waypoint`n"
                                                                        exampleText .= " previouswaypoint - Go back one waypoint`n"
                                                                        exampleText .= " netnav,target,destination - Network navigation (WP/NODE)`n"
                                                                        exampleText .= " Examples: netnav,all,WP 13 | netnav,win1,NODE 5`n`n"

                                                                        exampleText .= "SPECIAL:`n"
                                                                        exampleText .= " sendhotkey,key - Trigger hotkey in other scripts`n"
                                                                        exampleText .= " reenterbd5 - Auto re-enter BD dungeon`n`n"

                                                                        exampleText .= "==== USAGE ====`n"
                                                                        exampleText .= "Combine commands with | symbol:`n"
                                                                        exampleText .= " sleep,1000 | send,{1} | worldclick,5`n`n"

                                                                        exampleText .= "Use in waypoint commands field`n"
                                                                        exampleText .= "or in route .ini files"

                                                                        ; Create scrollable GUI instead of MsgBox
                                                                        Gui, Examples:New
                                                                        Gui, Examples:Add, Edit, x10 y10 w600 h500 vExamplesDisplay ReadOnly +VScroll, %exampleText%
                                                                        Gui, Examples:Add, Button, x260 y520 w100 gExamplesClose Default, Close
                                                                        Gui, Examples:Show, w620 h560, Available Commands
                                                                    return

                                                                    ExamplesClose:
                                                                    ExamplesGuiClose:
                                                                        Gui, Examples:Destroy
                                                                    return

                                                                    CloseCommandGUI:
                                                                        Gui, Commands: Destroy
                                                                    return

                                                                    SelectWin2Btn:
                                                                        SelectWin2()
                                                                    return

                                                                    TransparencyChange:
                                                                        Gui, Submit, NoHide
                                                                        guiTransparency := TransparencySlider
                                                                        GuiControl,, TransparencyText, %guiTransparency%
                                                                        WinSet, Transparent, %guiTransparency%, Advanced Navigation Control
                                                                    return

                                                                    CheckWindowActivity:
                                                                        if (TargetGameWindow) {
                                                                            WinGetActiveTitle, activeTitle
                                                                            WinGet, activeID, ID, A

                                                                            isTargetActive := (activeID = TargetGameWindow)
                                                                            isGUIActive := (activeTitle = "Advanced Navigation Control")
                                                                            shouldShowGUI := isTargetActive || isGUIActive

                                                                            if (shouldShowGUI && !WasWindowActive) {
                                                                                Gui, 1:Show,, Advanced Navigation Control
                                                                                WinSet, AlwaysOnTop, On, Advanced Navigation Control
                                                                            } else if (!shouldShowGUI && WasWindowActive) {
                                                                                WinSet, AlwaysOnTop, Off, Advanced Navigation Control
                                                                                Gui, 1:Hide
                                                                            }

                                                                            WasWindowActive := shouldShowGUI
                                                                        }
                                                                    return

                                                                    UpdateCoordinatesDisplay:
                                                                        if (TargetGameWindow) {
                                                                            GetCurrentCoordinates(coordX, coordY)
                                                                            if (coordX != "" && coordY != "") {
                                                                                GuiControl,, CurrentCoords, Current: X: %coordX% Y: %coordY%
                                                                            } else {
                                                                                GuiControl,, CurrentCoords, Current: X: --- Y: ---
                                                                            }
                                                                        } else {
                                                                            GuiControl,, CurrentCoords, Current: X: --- Y: ---
                                                                        }
                                                                    return

                                                                    UpdateRadiusGUI:
                                                                        GuiControl,, RadiusEdit, %CameraRadius%
                                                                    return

                                                                    f8::
                                                                        Gosub, AddWaypoint
                                                                    return

                                                                    ; f9::RecordCalibrationClick()  ; Disabled - calibration feature hidden

                                                                    #If CameraLocked && TargetGameWindow && WinActive("ahk_id " . TargetGameWindow)
                                                                    RButton::return
                                                                WheelUp::return
                                                                WheelDown::return
                                                                #If

                                                                ToggleWaypoints:
                                                                    Gui, Submit, NoHide
                                                                    ShowWaypoints := ShowWaypointsCheck

                                                                    ; Show or hide all waypoint GUIs
                                                                    for waypointIndex, guiName in WaypointGUIs {
                                                                        if (ShowWaypoints) {
                                                                            Gui, %guiName%:Show, NA
                                                                        } else {
                                                                            Gui, %guiName%:Hide
                                                                        }
                                                                    }
                                                                return

                                                                ToggleTargetNodes:
                                                                    Gui, Submit, NoHide
                                                                    ShowTargetNodes := ShowTargetNodesCheck

                                                                    ; Show or hide all target node GUIs
                                                                    for nodeID, guiName in NodeGUIs {
                                                                        if (ShowTargetNodes) {
                                                                            Gui, %guiName%:Show, NA
                                                                        } else {
                                                                            Gui, %guiName%:Hide
                                                                        }
                                                                    }
                                                                return

                                                                AddTargetNode:
                                                                    if (!TargetGameWindow) {
                                                                        MsgBox, No target window selected!
                                                                        return
                                                                    }

                                                                    ; Cancel waypoint placement mode if active
                                                                    if (PlacingWaypointMode) {
                                                                        PlacingWaypointMode := false
                                                                        SetTimer, CheckForWaypointPlacement, Off
                                                                    }

                                                                    ; Enable continuous placement mode like waypoints
                                                                    PlacingNodeMode := true
                                                                    ToolTip, Right-click in the game window to add target nodes. Press ESC to finish., 1
                                                                    SetTimer, CheckForNodePlacement, 50
                                                                return

                                                                CheckForNodePlacement:
                                                                    if (!PlacingNodeMode) {
                                                                        SetTimer, CheckForNodePlacement, Off
                                                                        ToolTip,, 1
                                                                        return
                                                                    }

                                                                    ; Check for ESC to cancel
                                                                    if (GetKeyState("Escape", "P")) {
                                                                        PlacingNodeMode := false
                                                                        SetTimer, CheckForNodePlacement, Off
                                                                        ToolTip,, 1
                                                                        return
                                                                    }

                                                                    ; Check if right mouse button is pressed
                                                                    if (GetKeyState("RButton", "P")) {
                                                                        ; Get mouse position when right-clicked (screen coordinates)
                                                                        MouseGetPos, screenX, screenY, clickedWin

                                                                        ; Verify click was in game window
                                                                        if (clickedWin != TargetGameWindow) {
                                                                            ToolTip, Wrong window! Clicked: %clickedWin%`nTarget: %TargetGameWindow%, 1
                                                                            SetTimer, ClearTooltip, -3000
                                                                            KeyWait, RButton
                                                                            return
                                                                        }

                                                                        ; Get current player coordinates
                                                                        GetCurrentCoordinates(playerX, playerY)
                                                                        if (playerX = "" || playerY = "") {
                                                                            ToolTip, Could not get current coordinates!, 1
                                                                            KeyWait, RButton
                                                                            return
                                                                        }

                                                                        ; Get game window position (including title bar and borders)
                                                                        WinGetPos, winX, winY, winW, winH, ahk_id %TargetGameWindow%

                                                                        ; IMPORTANT: We need to use CoordMode to ensure we're getting screen coordinates
                                                                        ; MouseGetPos already gives screen coords, which is what we want for GUI placement

                                                                        ; Calculate pixel offset from character center (window-relative coordinates)
                                                                        baseScreenX := winX + 516
                                                                        baseScreenY := winY + 410
                                                                        screenRelativeX := screenX - baseScreenX
                                                                        screenRelativeY := screenY - baseScreenY

                                                                        ; Reverse NavigateToCoordinatesClick calculations
                                                                        ; NOTE: NavigateToCoordinatesClick uses "clickY = baseClickY - rotatedY" (MINUS!)
                                                                        ; So to reverse: rotatedY = baseClickY - clickY = -(clickY - baseClickY) = -screenRelativeY
                                                                        rotatedX := screenRelativeX
                                                                        rotatedY := -screenRelativeY ; NEGATIVE because of the minus in NavigateToCoordinatesClick!

                                                                        ; Undo rotation (inverse of NavigateToCoordinatesClick rotation with -CameraAngle)
                                                                        cos_angle := Cos(-CameraAngle)
                                                                        sin_angle := Sin(-CameraAngle)

                                                                        ; Forward rotation: rotatedX = scaledX * cos - scaledY * sin
                                                                        ; Forward rotation: rotatedY = scaledX * sin + scaledY * cos
                                                                        ; Inverse: scaledX = rotatedX * cos + rotatedY * sin
                                                                        ; Inverse: scaledY = -rotatedX * sin + rotatedY * cos
                                                                        scaledX := rotatedX * cos_angle + rotatedY * sin_angle
                                                                        scaledY := -rotatedX * sin_angle + rotatedY * cos_angle

                                                                        ; Undo distance correction (NavigateToCoordinatesClick: scaledX *= 0.94, scaledY *= 1.19)
                                                                        scaledX := scaledX / 0.94
                                                                        scaledY := scaledY / 1.19

                                                                        ; Calculate Y scaling (same formula as NavigateToCoordinatesClick)
                                                                        if (CameraRadius <= 900) {
                                                                            pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                                        } else if (CameraRadius <= 1000) {
                                                                            t := (CameraRadius - 900) / 100
                                                                            pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                                        } else if (CameraRadius <= 1500) {
                                                                            t := (CameraRadius - 1000) / 500
                                                                            pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                                        } else {
                                                                            t := (CameraRadius - 1500) / 500
                                                                            pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                                        }

                                                                        ; Undo scaling (reverse of: scaledX = -deltaX * 1.21, scaledY = -deltaY * pixelsPerGameUnitY)
                                                                        worldDeltaX := -scaledX / 1.21
                                                                        worldDeltaY := -scaledY / pixelsPerGameUnitY

                                                                        ; Calculate world coordinates
                                                                        nodeWorldX := Round(playerX + worldDeltaX, 2)
                                                                        nodeWorldY := Round(playerY + worldDeltaY, 2)

                                                                        ; Get node ID (reuse deleted IDs if available)
                                                                        if (AvailableNodeIDs.Length() > 0) {
                                                                            ; Pop the lowest available ID (get last item and remove it)
                                                                            nodeID := AvailableNodeIDs.Pop()
                                                                        } else {
                                                                            ; No deleted IDs available, use next sequential ID
                                                                            nodeID := NextNodeID
                                                                            NextNodeID++
                                                                        }

                                                                        node := {id: nodeID, worldX: nodeWorldX, worldY: nodeWorldY}
                                                                        TargetNodes.Push(node)

                                                                        ; Create visual node directly at click position (not recalculated)
                                                                        guiName := "TargetNode" . nodeID

                                                                        ; Use global NodeSize variable
                                                                        nodeW := NodeSize
                                                                        nodeH := NodeSize

                                                                        Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                                                        Gui, %guiName%:Color, FF0000
                                                                        Gui, %guiName%:Font, s8 cWhite Bold
                                                                        nodeIDText := nodeID
                                                                        Gui, %guiName%:Add, Text, x0 y0 w%nodeW% h%nodeH% Center BackgroundTrans, %nodeIDText%

                                                                        ; Place GUI at exact click position (MouseGetPos gives screen coords, which is what we need)
                                                                        ; Center the node on the cursor
                                                                        halfSize := NodeSize // 2
                                                                        nodeX := screenX - halfSize
                                                                        nodeY := screenY - halfSize

                                                                        ; Show the GUI at the click position
                                                                        Gui, %guiName%:Show, x%nodeX% y%nodeY% w%nodeW% h%nodeH% NoActivate
                                                                        WinSet, Transparent, 150, %guiName%
                                                                        ; Make it click-through using DllCall
                                                                        WinGet, nodeHwnd, ID, %guiName%
                                                                        ; Get current extended style
                                                                        exStyle := DllCall("GetWindowLong", "Ptr", nodeHwnd, "Int", -20, "UInt")
                                                                        ; Add WS_EX_TRANSPARENT (0x20) and WS_EX_LAYERED (0x80000)
                                                                        exStyle := exStyle | 0x20 | 0x80000
                                                                        ; Set the new extended style
                                                                        DllCall("SetWindowLong", "Ptr", nodeHwnd, "Int", -20, "UInt", exStyle)

                                                                        ; Store GUI name
                                                                        NodeGUIs[nodeID] := guiName

                                                                        ; Start update timer if not already running
                                                                        SetTimer, UpdateAllTargetNodes, 500

                                                                        ; Update status
                                                                        nodeCount := TargetNodes.Length()
                                                                        GuiControl,, NodeStatus, Nodes: %nodeCount% placed

                                                                        ; Save nodes to file
                                                                        SaveNodes()

                                                                        ; Show confirmation and stay in placement mode
                                                                        ToolTip, Node #%nodeID% placed at X:%nodeWorldX% Y:%nodeWorldY%`nRight-click for more or press ESC to finish, 1
                                                                            SetTimer, ClearTooltip, -2000

                                                                        ; Wait for mouse button release before continuing
                                                                        KeyWait, RButton

                                                                        ; Stay in placement mode for adding more nodes
                                                                    }
                                                                return

                                                                PlaceNodeAtClick:
                                                                    ; This is now unused but kept for compatibility
                                                                return

                                                                ReloadNodes:
                                                                    if (!SelectedRouteFile) {
                                                                        MsgBox, No route file selected! Please select a route first.
                                                                        return
                                                                    }

                                                                    ; Clear existing node GUIs
                                                                    for nodeID in NodeGUIs {
                                                                        guiName := NodeGUIs[nodeID]
                                                                        if (guiName != "") {
                                                                            Gui, %guiName%:Destroy
                                                                            Sleep, 10
                                                                        }
                                                                    }

                                                                    ; Clear arrays
                                                                    TargetNodes := []
                                                                    NodeGUIs := {}

                                                                    ; Reload nodes from file
                                                                    LoadNodes()

                                                                    ; Update status
                                                                    nodeCount := TargetNodes.Length()
                                                                    GuiControl,, NodeStatus, Nodes: %nodeCount% placed

                                                                    MsgBox, Nodes reloaded from file!`n%nodeCount% nodes loaded.
                                                                return

                                                                ClearAllNodes:
                                                                    ; Destroy all node GUIs with delay to prevent errors
                                                                    for nodeID in NodeGUIs {
                                                                        guiName := NodeGUIs[nodeID]
                                                                        if (guiName != "") {
                                                                            Gui, %guiName%:Destroy
                                                                            Sleep, 50 ; Add delay between destroying each GUI
                                                                        }
                                                                    }

                                                                    ; Clear arrays
                                                                    TargetNodes := []
                                                                    NodeGUIs := {}
                                                                    NextNodeID := 1
                                                                    AvailableNodeIDs := []

                                                                    ; Stop the update timer
                                                                    SetTimer, UpdateAllTargetNodes, Off

                                                                    ; Save cleared nodes to file
                                                                    SaveNodes()

                                                                    ; Update status
                                                                    GuiControl,, NodeStatus, Nodes: 0 placed
                                                                    MsgBox, All nodes cleared!
                                                                return

                                                                DeleteNode:
                                                                    Gui, Submit, NoHide

                                                                    if (DeleteNodeID = "" || DeleteNodeID < 1) {
                                                                        MsgBox, Please enter a valid node ID number!
                                                                        return
                                                                    }

                                                                    ; Find the node in the array
                                                                    nodeIndex := 0
                                                                    for index, node in TargetNodes {
                                                                        if (node.id = DeleteNodeID) {
                                                                            nodeIndex := index
                                                                            break
                                                                        }
                                                                    }

                                                                    if (nodeIndex = 0) {
                                                                        MsgBox, Node #%DeleteNodeID% not found!
                                                                        return
                                                                    }

                                                                    ; Destroy the GUI
                                                                    guiName := NodeGUIs[DeleteNodeID]
                                                                    if (guiName != "") {
                                                                        Gui, %guiName%:Destroy
                                                                    }

                                                                    ; Remove from arrays
                                                                    TargetNodes.RemoveAt(nodeIndex)
                                                                    NodeGUIs.Delete(DeleteNodeID)

                                                                    ; Add the deleted ID to available IDs (for reuse) and sort
                                                                    AvailableNodeIDs.Push(DeleteNodeID)

                                                                    ; Sort available IDs in descending order (so we pop the lowest)
                                                                    Loop % AvailableNodeIDs.Length() - 1 {
                                                                        i := A_Index
                                                                        Loop % AvailableNodeIDs.Length() - i {
                                                                            j := A_Index
                                                                            if (AvailableNodeIDs[j] < AvailableNodeIDs[j+1]) {
                                                                                temp := AvailableNodeIDs[j]
                                                                                AvailableNodeIDs[j] := AvailableNodeIDs[j+1]
                                                                                AvailableNodeIDs[j+1] := temp
                                                                            }
                                                                        }
                                                                    }

                                                                    ; Save to file
                                                                    SaveNodes()

                                                                    ; Update status
                                                                    nodeCount := TargetNodes.Length()
                                                                    GuiControl,, NodeStatus, Nodes: %nodeCount% placed
                                                                    GuiControl,, DeleteNodeID, ; Clear the input field

                                                                    ;MsgBox, Node #%DeleteNodeID% deleted!
                                                                return

                                                                ApplyClickThrough:
                                                                    ; Manually apply click-through to all existing node and waypoint GUIs
                                                                    fixedCount := 0

                                                                    ; Fix all node GUIs
                                                                    for nodeID, guiName in NodeGUIs {
                                                                        WinGet, hwnd, ID, %guiName%
                                                                        if (hwnd) {
                                                                            MakeWindowClickThroughByHandle(hwnd)
                                                                            fixedCount++
                                                                        }
                                                                    }

                                                                    ; Fix all waypoint GUIs
                                                                    for waypointIndex, guiName in WaypointGUIs {
                                                                        WinGet, hwnd, ID, %guiName%
                                                                        if (hwnd) {
                                                                            MakeWindowClickThroughByHandle(hwnd)
                                                                            fixedCount++
                                                                        }
                                                                    }

                                                                    MsgBox, Applied click-through to %fixedCount% windows!
                                                                return

                                                                DebugCalibration:
                                                                    ; Create debugnav.ini path
                                                                    debugINI := A_ScriptDir . "\debugnav.ini"

                                                                    ; Auto-sync TargetGameWindow with win1 if not set
                                                                    if (!TargetGameWindow && win1) {
                                                                        TargetGameWindow := win1
                                                                    }

                                                                    if (!TargetGameWindow) {
                                                                        MsgBox, No game window selected! Please select a window first.
                                                                        return
                                                                    }

                                                                    ; Step 1: Capture current position
                                                                    MsgBox, 64, Debug Calibration - Step 1, Step 1: Stand at your current position.`n`nPress OK when ready to capture your coordinates.

                                                                    GetCurrentCoordinates(startX, startY)
                                                                    if (startX = "" || startY = "") {
                                                                        MsgBox, 16, Error, Could not read coordinates! Make sure they are visible.
                                                                        return
                                                                    }

                                                                    MsgBox, 64, Captured, Starting Position Captured:`nX: %startX%`nY: %startY%`n`nNow move your character to a new position.

                                                                    ; Step 2: Move and capture new position
                                                                    MsgBox, 64, Debug Calibration - Step 2, Step 2: Move to a new position (recommend 50-100 units away).`n`nPress OK when ready to capture new coordinates.

                                                                    GetCurrentCoordinates(endX, endY)
                                                                    if (endX = "" || endY = "") {
                                                                        MsgBox, 16, Error, Could not read coordinates! Make sure they are visible.
                                                                        return
                                                                    }

                                                                    ; Step 3: Right-click where you moved to
                                                                    MsgBox, 64, Debug Calibration - Step 3, New Position Captured:`nX: %endX%`nY: %endY%`n`nNow RIGHT-CLICK on the exact spot your character is standing.

                                                                    ; Activate the game window
                                                                    ;WinActivate, ahk_id %TargetGameWindow%
                                                                    Sleep, 200

                                                                    ; Wait for right-click
                                                                    KeyWait, RButton, D

                                                                    ; Get the click position
                                                                    CoordMode, Mouse, Screen
                                                                    MouseGetPos, clickX, clickY, clickWinID

                                                                    if (clickWinID != TargetGameWindow) {
                                                                        MsgBox, Click was not in the game window! Calibration cancelled.
                                                                        return
                                                                    }

                                                                    ; Get window position
                                                                    WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                                                    ; Calculate window-relative click position
                                                                    relativeClickX := clickX - winX
                                                                    relativeClickY := clickY - winY

                                                                    ; Calculate deltas
                                                                    worldDeltaX := endX - startX
                                                                    worldDeltaY := endY - startY

                                                                    ; ===== COMPREHENSIVE COORDINATE CONVERSION CALCULATIONS =====

                                                                    ; Base screen center
                                                                    baseScreenX := winX + 516
                                                                    baseScreenY := winY + 410

                                                                    ; Screen pixel deltas from center
                                                                    pixelDeltaX := clickX - baseScreenX
                                                                    pixelDeltaY := clickY - baseScreenY

                                                                    ; Calculate Y scaling based on camera radius (EXACT copy from AddTargetNode)
                                                                    if (CameraRadius <= 900) {
                                                                        pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                                    } else if (CameraRadius <= 1000) {
                                                                        t := (CameraRadius - 900) / (1000 - 900)
                                                                        pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                                    } else if (CameraRadius <= 1500) {
                                                                        t := (CameraRadius - 1000) / (1500 - 1000)
                                                                        pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                                    } else {
                                                                        pixelsPerGameUnitY := 0.75
                                                                    }

                                                                    ; Inverse rotation (undo camera angle)
                                                                    cos_angle := Cos(CameraAngle)
                                                                    sin_angle := Sin(CameraAngle)
                                                                    unrotatedX := pixelDeltaX * cos_angle + pixelDeltaY * sin_angle
                                                                    unrotatedY := -pixelDeltaX * sin_angle + pixelDeltaY * cos_angle

                                                                    ; Undo distance correction
                                                                    unscaledX := unrotatedX / 0.94
                                                                    unscaledY := unrotatedY / 1.19

                                                                    ; Undo base scaling to get world deltas
                                                                    calculatedWorldDeltaX := -unscaledX / 1.21
                                                                    calculatedWorldDeltaY := unscaledY / pixelsPerGameUnitY

                                                                    ; Calculate what the world coordinates SHOULD be based on the click
                                                                    calculatedWorldX := startX + calculatedWorldDeltaX
                                                                    calculatedWorldY := startY + calculatedWorldDeltaY

                                                                    ; Calculate the error between where we are vs where click says we should be
                                                                    errorWorldX := endX - calculatedWorldX
                                                                    errorWorldY := endY - calculatedWorldY

                                                                    ; Calculate what screen position the endX/endY SHOULD produce
                                                                    ; (Forward conversion to verify)
                                                                    forwardDeltaX := endX - startX
                                                                    forwardDeltaY := endY - startY

                                                                    ; Apply base scaling
                                                                    forwardScaledX := -forwardDeltaX * 1.21
                                                                    forwardScaledY := forwardDeltaY * pixelsPerGameUnitY

                                                                    ; Apply distance correction
                                                                    forwardScaledX := forwardScaledX * 0.94
                                                                    forwardScaledY := forwardScaledY * 1.19

                                                                    ; Apply rotation
                                                                    forwardRotatedX := forwardScaledX * cos_angle - forwardScaledY * sin_angle
                                                                    forwardRotatedY := forwardScaledX * sin_angle + forwardScaledY * cos_angle

                                                                    ; Calculate expected screen position
                                                                    expectedScreenX := baseScreenX + Round(forwardRotatedX)
                                                                    expectedScreenY := baseScreenY + Round(forwardRotatedY)

                                                                    ; Calculate screen position error
                                                                    screenErrorX := clickX - expectedScreenX
                                                                    screenErrorY := clickY - expectedScreenY

                                                                    ; ===== SAVE ALL DATA TO INI =====
                                                                    FileEncoding, UTF-8

                                                                    ; Clear existing file
                                                                    FileDelete, %debugINI%

                                                                    ; Write starting position
                                                                    IniWrite, %startX%, %debugINI%, Position1, WorldX
                                                                    IniWrite, %startY%, %debugINI%, Position1, WorldY

                                                                    ; Write ending position (actual)
                                                                    IniWrite, %endX%, %debugINI%, Position2_Actual, WorldX
                                                                    IniWrite, %endY%, %debugINI%, Position2_Actual, WorldY

                                                                    ; Write calculated position (from click)
                                                                    IniWrite, %calculatedWorldX%, %debugINI%, Position2_Calculated, WorldX
                                                                    IniWrite, %calculatedWorldY%, %debugINI%, Position2_Calculated, WorldY

                                                                    ; Write click data
                                                                    IniWrite, %clickX%, %debugINI%, Click, ScreenX
                                                                    IniWrite, %clickY%, %debugINI%, Click, ScreenY
                                                                    IniWrite, %relativeClickX%, %debugINI%, Click, WindowRelativeX
                                                                    IniWrite, %relativeClickY%, %debugINI%, Click, WindowRelativeY

                                                                    ; Write expected screen position
                                                                    IniWrite, %expectedScreenX%, %debugINI%, ExpectedClick, ScreenX
                                                                    IniWrite, %expectedScreenY%, %debugINI%, ExpectedClick, ScreenY

                                                                    ; Write deltas (actual movement)
                                                                    IniWrite, %worldDeltaX%, %debugINI%, Deltas_Actual, WorldDeltaX
                                                                    IniWrite, %worldDeltaY%, %debugINI%, Deltas_Actual, WorldDeltaY

                                                                    ; Write calculated deltas (from click conversion)
                                                                    IniWrite, %calculatedWorldDeltaX%, %debugINI%, Deltas_Calculated, WorldDeltaX
                                                                    IniWrite, %calculatedWorldDeltaY%, %debugINI%, Deltas_Calculated, WorldDeltaY

                                                                    ; Write errors
                                                                    IniWrite, %errorWorldX%, %debugINI%, Errors, WorldErrorX
                                                                    IniWrite, %errorWorldY%, %debugINI%, Errors, WorldErrorY
                                                                    IniWrite, %screenErrorX%, %debugINI%, Errors, ScreenErrorX
                                                                    IniWrite, %screenErrorY%, %debugINI%, Errors, ScreenErrorY

                                                                    ; Write intermediate calculations
                                                                    IniWrite, %pixelDeltaX%, %debugINI%, Intermediate, PixelDeltaX_FromCenter
                                                                    IniWrite, %pixelDeltaY%, %debugINI%, Intermediate, PixelDeltaY_FromCenter
                                                                    IniWrite, %unrotatedX%, %debugINI%, Intermediate, UnrotatedX
                                                                    IniWrite, %unrotatedY%, %debugINI%, Intermediate, UnrotatedY
                                                                    IniWrite, %unscaledX%, %debugINI%, Intermediate, UnscaledX
                                                                    IniWrite, %unscaledY%, %debugINI%, Intermediate, UnscaledY
                                                                    IniWrite, %pixelsPerGameUnitY%, %debugINI%, Intermediate, PixelsPerGameUnitY

                                                                    ; Write window position
                                                                    IniWrite, %winX%, %debugINI%, Window, X
                                                                    IniWrite, %winY%, %debugINI%, Window, Y
                                                                    IniWrite, %baseScreenX%, %debugINI%, Window, BaseCenterX
                                                                    IniWrite, %baseScreenY%, %debugINI%, Window, BaseCenterY

                                                                    ; Write camera data
                                                                    IniWrite, %CameraAngle%, %debugINI%, Camera, Angle
                                                                    IniWrite, %CameraRadius%, %debugINI%, Camera, Radius
                                                                    IniWrite, %cos_angle%, %debugINI%, Camera, CosAngle
                                                                    IniWrite, %sin_angle%, %debugINI%, Camera, SinAngle

                                                                    FileEncoding

                                                                    ; Show comprehensive summary
                                                                    summaryMsg := "DEBUG CALIBRATION SAVED to debugnav.ini`n`n"
                                                                    summaryMsg .= "=== WORLD POSITIONS ===`n"
                                                                    summaryMsg .= "Start: X=" . startX . " Y=" . startY . "`n"
                                                                    summaryMsg .= "End (Actual): X=" . endX . " Y=" . endY . "`n"
                                                                    summaryMsg .= "End (Calculated from click): X=" . Round(calculatedWorldX, 2) . " Y=" . Round(calculatedWorldY, 2) . "`n"
                                                                    summaryMsg .= "Actual Delta: X=" . Round(worldDeltaX, 2) . " Y=" . Round(worldDeltaY, 2) . "`n"
                                                                    summaryMsg .= "Calculated Delta: X=" . Round(calculatedWorldDeltaX, 2) . " Y=" . Round(calculatedWorldDeltaY, 2) . "`n`n"
                                                                    summaryMsg .= "=== WORLD COORDINATE ERROR ===`n"
                                                                    summaryMsg .= "Error X: " . Round(errorWorldX, 2) . " units`n"
                                                                    summaryMsg .= "Error Y: " . Round(errorWorldY, 2) . " units`n`n"
                                                                    summaryMsg .= "=== SCREEN POSITIONS ===`n"
                                                                    summaryMsg .= "Click (Actual): X=" . clickX . " Y=" . clickY . "`n"
                                                                    summaryMsg .= "Click (Expected): X=" . expectedScreenX . " Y=" . expectedScreenY . "`n"
                                                                    summaryMsg .= "Screen Error: X=" . screenErrorX . " Y=" . screenErrorY . " pixels`n"
                                                                    summaryMsg .= "Window Relative: X=" . relativeClickX . " Y=" . relativeClickY . "`n`n"
                                                                    summaryMsg .= "=== CAMERA ===`n"
                                                                    summaryMsg .= "Angle: " . Round(CameraAngle, 4) . "`n"
                                                                    summaryMsg .= "Radius: " . CameraRadius . "`n"
                                                                    summaryMsg .= "Y Scale Factor: " . Round(pixelsPerGameUnitY, 4)

                                                                    MsgBox, 64, Calibration Complete, %summaryMsg%
                                                                return

                                                                DebugNodeClicks:
                                                                    ; Create debugnodes.ini path
                                                                    debugNodesINI := A_ScriptDir . "\debugnodes.ini"

                                                                    ; Auto-sync TargetGameWindow with win1 if not set
                                                                    if (!TargetGameWindow && win1) {
                                                                        TargetGameWindow := win1
                                                                    }

                                                                    if (!TargetGameWindow) {
                                                                        MsgBox, No game window selected! Please select a window first.
                                                                        return
                                                                    }

                                                                    ; Clear existing file
                                                                    FileDelete, %debugNodesINI%
                                                                    FileEncoding, UTF-8

                                                                    ; Capture starting position
                                                                    GetCurrentCoordinates(startX, startY)
                                                                    if (startX = "" || startY = "") {
                                                                        MsgBox, 16, Error, Could not read starting coordinates!
                                                                        return
                                                                    }

                                                                    IniWrite, %startX%, %debugNodesINI%, Start, WorldX
                                                                    IniWrite, %startY%, %debugNodesINI%, Start, WorldY
                                                                    IniWrite, %CameraAngle%, %debugNodesINI%, Start, CameraAngle
                                                                    IniWrite, %CameraRadius%, %debugNodesINI%, Start, CameraRadius

                                                                    ; Get window position
                                                                    WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                                    IniWrite, %winX%, %debugNodesINI%, Window, X
                                                                    IniWrite, %winY%, %debugNodesINI%, Window, Y

                                                                    ; Process 3 nodes
                                                                    Loop, 3 {
                                                                        nodeNum := A_Index

                                                                        ; Step 1: Ask user to place node
                                                                        MsgBox, 64, Node %nodeNum% - Step 1, Node %nodeNum%: RIGHT-CLICK to place a temporary node where you want to test.

                                                                        ;WinActivate, ahk_id %TargetGameWindow%
                                                                        Sleep, 200

                                                                        ; Wait for right-click to place node
                                                                        KeyWait, RButton, D
                                                                        CoordMode, Mouse, Screen
                                                                        MouseGetPos, placeClickX, placeClickY, clickWinID

                                                                        if (clickWinID != TargetGameWindow) {
                                                                            MsgBox, Click was not in game window! Debug cancelled.
                                                                            return
                                                                        }

                                                                        ; Save placement click position
                                                                        IniWrite, %placeClickX%, %debugNodesINI%, Node%nodeNum%, PlaceClickX
                                                                        IniWrite, %placeClickY%, %debugNodesINI%, Node%nodeNum%, PlaceClickY

                                                                        ; Calculate world coordinates using our inverse conversion
                                                                        baseScreenX := winX + 516
                                                                        baseScreenY := winY + 410
                                                                        screenRelativeX := placeClickX - baseScreenX
                                                                        screenRelativeY := placeClickY - baseScreenY

                                                                        rotatedX := screenRelativeX
                                                                        rotatedY := screenRelativeY

                                                                        cos_angle := Cos(-CameraAngle)
                                                                        sin_angle := Sin(-CameraAngle)

                                                                        scaledX := rotatedX * cos_angle + rotatedY * sin_angle
                                                                        scaledY := -rotatedX * sin_angle + rotatedY * cos_angle

                                                                        scaledX := scaledX / 0.94
                                                                        scaledY := scaledY / 1.19

                                                                        if (CameraRadius <= 900) {
                                                                            pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                                        } else if (CameraRadius <= 1000) {
                                                                            t := (CameraRadius - 900) / 100
                                                                            pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                                        } else if (CameraRadius <= 1500) {
                                                                            t := (CameraRadius - 1000) / 500
                                                                            pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                                        } else {
                                                                            t := (CameraRadius - 1500) / 500
                                                                            pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                                        }

                                                                        worldDeltaX := -scaledX / 1.21
                                                                        worldDeltaY := -scaledY / pixelsPerGameUnitY

                                                                        calculatedWorldX := Round(startX + worldDeltaX, 2)
                                                                        calculatedWorldY := Round(startY + worldDeltaY, 2)

                                                                        IniWrite, %calculatedWorldX%, %debugNodesINI%, Node%nodeNum%, CalculatedWorldX
                                                                        IniWrite, %calculatedWorldY%, %debugNodesINI%, Node%nodeNum%, CalculatedWorldY

                                                                        ; Create a visible hollow bounding box at the click position (30x30 box)
                                                                        boxSize := 30
                                                                        halfSize := boxSize // 2
                                                                        boxX := placeClickX - halfSize
                                                                        boxY := placeClickY - halfSize
                                                                        borderThickness := 2

                                                                        ; Top border
                                                                        topGuiName := "DebugNode" . nodeNum . "Top"
                                                                        Gui, %topGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                        Gui, %topGuiName%:Color, 0000FF
                                                                        Gui, %topGuiName%:Show, x%boxX% y%boxY% w%boxSize% h%borderThickness% NoActivate
                                                                        WinSet, Transparent, 200, %topGuiName%

                                                                        ; Bottom border
                                                                        bottomY := boxY + boxSize - borderThickness
                                                                        bottomGuiName := "DebugNode" . nodeNum . "Bottom"
                                                                        Gui, %bottomGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                        Gui, %bottomGuiName%:Color, 0000FF
                                                                        Gui, %bottomGuiName%:Show, x%boxX% y%bottomY% w%boxSize% h%borderThickness% NoActivate
                                                                        WinSet, Transparent, 200, %bottomGuiName%

                                                                        ; Left border
                                                                        leftGuiName := "DebugNode" . nodeNum . "Left"
                                                                        Gui, %leftGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                        Gui, %leftGuiName%:Color, 0000FF
                                                                        Gui, %leftGuiName%:Show, x%boxX% y%boxY% w%borderThickness% h%boxSize% NoActivate
                                                                        WinSet, Transparent, 200, %leftGuiName%

                                                                        ; Right border
                                                                        rightX := boxX + boxSize - borderThickness
                                                                        rightGuiName := "DebugNode" . nodeNum . "Right"
                                                                        Gui, %rightGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                        Gui, %rightGuiName%:Color, 0000FF
                                                                        Gui, %rightGuiName%:Show, x%rightX% y%boxY% w%borderThickness% h%boxSize% NoActivate
                                                                        WinSet, Transparent, 200, %rightGuiName%

                                                                        ; Add number label in the center
                                                                        labelX := placeClickX - 8
                                                                        labelY := placeClickY - 8
                                                                        labelGuiName := "DebugNode" . nodeNum . "Label"
                                                                        Gui, %labelGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                        Gui, %labelGuiName%:Color, 0x000000
                                                                        Gui, %labelGuiName%:Font, s10 cBlue Bold
                                                                        Gui, %labelGuiName%:Add, Text, x0 y0 w16 h16 Center BackgroundTrans, %nodeNum%
                                                                        Gui, %labelGuiName%:Show, x%labelX% y%labelY% w16 h16 NoActivate
                                                                        WinSet, Transparent, 200, %labelGuiName%

                                                                        Sleep, 500

                                                                        ; Step 2: Click at the calculated world coordinates using ClickAtWorldCoordinates
                                                                        MsgBox, 64, Node %nodeNum% - Step 2, Node %nodeNum%: The script will now click at the calculated world coordinates using ClickAtWorldCoordinates (same as worldclick command).`n`nWatch where it clicks!

                                                                        ; Destroy the bounding box before clicking so it doesn't interfere with visibility
                                                                        guiName := "DebugNode" . nodeNum . "Top"
                                                                        Gui, %guiName%:Destroy
                                                                        guiName := "DebugNode" . nodeNum . "Bottom"
                                                                        Gui, %guiName%:Destroy
                                                                        guiName := "DebugNode" . nodeNum . "Left"
                                                                        Gui, %guiName%:Destroy
                                                                        guiName := "DebugNode" . nodeNum . "Right"
                                                                        Gui, %guiName%:Destroy
                                                                        guiName := "DebugNode" . nodeNum . "Label"
                                                                        Gui, %guiName%:Destroy

                                                                        ; Use ClickAtWorldCoordinates to see where it actually clicks (same as worldclick command)
                                                                        ClickAtWorldCoordinates(calculatedWorldX, calculatedWorldY)

                                                                        Sleep, 1000

                                                                        ; Step 3: Ask user to click where it actually should be
                                                                        MsgBox, 64, Node %nodeNum% - Step 3, Node %nodeNum%: Now RIGHT-CLICK on the CENTER of where the node actually is (where your character moved to).

                                                                        ;WinActivate, ahk_id %TargetGameWindow%
                                                                        Sleep, 200

                                                                        KeyWait, RButton, D
                                                                        MouseGetPos, actualClickX, actualClickY, clickWinID2

                                                                        if (clickWinID2 <> TargetGameWindow) {
                                                                            MsgBox, Click was not in game window! Debug cancelled.
                                                                            return
                                                                        }

                                                                        IniWrite, %actualClickX%, %debugNodesINI%, Node%nodeNum%, ActualCenterClickX
                                                                        IniWrite, %actualClickY%, %debugNodesINI%, Node%nodeNum%, ActualCenterClickY

                                                                        ; Calculate error
                                                                        errorX := actualClickX - placeClickX
                                                                        errorY := actualClickY - placeClickY

                                                                        IniWrite, %errorX%, %debugNodesINI%, Node%nodeNum%, ErrorPixelsX
                                                                        IniWrite, %errorY%, %debugNodesINI%, Node%nodeNum%, ErrorPixelsY

                                                                        ; Capture current world position after movement
                                                                        Sleep, 500
                                                                        GetCurrentCoordinates(afterWorldX, afterWorldY)
                                                                        if (afterWorldX != "" && afterWorldY != "") {
                                                                            IniWrite, %afterWorldX%, %debugNodesINI%, Node%nodeNum%, ActualWorldX
                                                                            IniWrite, %afterWorldY%, %debugNodesINI%, Node%nodeNum%, ActualWorldY

                                                                            worldErrorX := afterWorldX - calculatedWorldX
                                                                            worldErrorY := afterWorldY - calculatedWorldY

                                                                            IniWrite, %worldErrorX%, %debugNodesINI%, Node%nodeNum%, WorldErrorX
                                                                            IniWrite, %worldErrorY%, %debugNodesINI%, Node%nodeNum%, WorldErrorY
                                                                        }

                                                                        Sleep, 500
                                                                    }

                                                                    ; Clean up temporary debug node bounding boxes
                                                                    Loop, 3 {
                                                                        nodeNum := A_Index
                                                                        guiName := "DebugNode" . nodeNum . "Top"
                                                                        Gui, %guiName%:Destroy
                                                                        guiName := "DebugNode" . nodeNum . "Bottom"
                                                                        Gui, %guiName%:Destroy
                                                                        guiName := "DebugNode" . nodeNum . "Left"
                                                                        Gui, %guiName%:Destroy
                                                                        guiName := "DebugNode" . nodeNum . "Right"
                                                                        Gui, %guiName%:Destroy
                                                                        guiName := "DebugNode" . nodeNum . "Label"
                                                                        Gui, %guiName%:Destroy
                                                                    }

                                                                    FileEncoding

                                                                    MsgBox, 64, Debug Complete, Debug data saved to debugnodes.ini!`n`nCheck the file for click accuracy data for all 3 nodes.
                                                                        return

                                                                MoveWaypointByNumber:
                                                                    ; Ask user for waypoint number
                                                                    InputBox, waypointNumToMove, Move Waypoint, Enter the waypoint number to move:, , 300, 150
                                                                    if (ErrorLevel) {
                                                                        return ; User cancelled
                                                                    }

                                                                    ; Validate input
                                                                    if (waypointNumToMove = "" || waypointNumToMove < 1) {
                                                                        MsgBox, Invalid waypoint number!
                                                                        return
                                                                    }

                                                                    ; Check if waypoint exists
                                                                    waypointCount := Waypoints.Length()
                                                                    if (waypointNumToMove > waypointCount) {
                                                                        MsgBox, Waypoint #%waypointNumToMove% does not exist! (Only %waypointCount% waypoints in current path)
                                                                        return
                                                                    }

                                                                    ; Auto-sync TargetGameWindow with win1 if not set
                                                                    if (!TargetGameWindow && win1) {
                                                                        TargetGameWindow := win1
                                                                    }

                                                                    if (!TargetGameWindow) {
                                                                        MsgBox, No game window selected! Please select a window first.
                                                                        return
                                                                    }

                                                                    ; Activate the game window
                                                                    WinActivate, ahk_id %TargetGameWindow%
                                                                    Sleep, 200

                                                                    ; Show instruction
                                                                    MsgBox, 64, Move Waypoint, Right-click on the new position for waypoint #%waypointNumToMove% in the game window., 3

                                                                    ; Wait for right-click
                                                                    KeyWait, RButton, D

                                                                    ; Get the click position (use CoordMode to ensure we get screen coordinates)
                                                                    CoordMode, Mouse, Screen
                                                                    MouseGetPos, clickX, clickY, clickWinID

                                                                    ; Verify click was in game window
                                                                    if (clickWinID != TargetGameWindow) {
                                                                        MsgBox, Click was not in the game window! Move cancelled.
                                                                        return
                                                                    }

                                                                    ; Get current player coordinates
                                                                    GetCurrentCoordinates(playerX, playerY)
                                                                    if (playerX = "" || playerY = "") {
                                                                        MsgBox, Could not read current coordinates! Make sure coordinates are visible.
                                                                        return
                                                                    }

                                                                    ; Get game window position
                                                                    WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                                                    ; Calculate pixel offset from character center (window-relative coordinates)
                                                                    baseScreenX := winX + 516
                                                                    baseScreenY := winY + 410
                                                                    screenRelativeX := clickX - baseScreenX
                                                                    screenRelativeY := clickY - baseScreenY

                                                                    ; Reverse NavigateToCoordinatesClick calculations
                                                                    ; NOTE: NavigateToCoordinatesClick uses "clickY = baseClickY - rotatedY" (MINUS!)
                                                                    ; So to reverse: rotatedY = baseClickY - clickY = -(clickY - baseClickY) = -screenRelativeY
                                                                    rotatedX := screenRelativeX
                                                                    rotatedY := -screenRelativeY ; NEGATIVE because of the minus in NavigateToCoordinatesClick!

                                                                    ; Undo rotation (inverse of NavigateToCoordinatesClick rotation with -CameraAngle)
                                                                    cos_angle := Cos(-CameraAngle)
                                                                    sin_angle := Sin(-CameraAngle)

                                                                    ; Forward rotation: rotatedX = scaledX * cos - scaledY * sin
                                                                    ; Forward rotation: rotatedY = scaledX * sin + scaledY * cos
                                                                    ; Inverse: scaledX = rotatedX * cos + rotatedY * sin
                                                                    ; Inverse: scaledY = -rotatedX * sin + rotatedY * cos
                                                                    scaledX := rotatedX * cos_angle + rotatedY * sin_angle
                                                                    scaledY := -rotatedX * sin_angle + rotatedY * cos_angle

                                                                    ; Undo distance correction (NavigateToCoordinatesClick: scaledX *= 0.94, scaledY *= 1.19)
                                                                    scaledX := scaledX / 0.94
                                                                    scaledY := scaledY / 1.19

                                                                    ; Calculate Y scaling (same formula as NavigateToCoordinatesClick)
                                                                    if (CameraRadius <= 900) {
                                                                        pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                                    } else if (CameraRadius <= 1000) {
                                                                        t := (CameraRadius - 900) / 100
                                                                        pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                                    } else if (CameraRadius <= 1500) {
                                                                        t := (CameraRadius - 1000) / 500
                                                                        pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                                    } else {
                                                                        t := (CameraRadius - 1500) / 500
                                                                        pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                                    }

                                                                    ; Undo scaling (reverse of: scaledX = -deltaX * 1.21, scaledY = -deltaY * pixelsPerGameUnitY)
                                                                    worldDeltaX := -scaledX / 1.21
                                                                    worldDeltaY := -scaledY / pixelsPerGameUnitY

                                                                    ; Calculate world coordinates
                                                                    newWorldX := Round(playerX + worldDeltaX, 2)
                                                                    newWorldY := Round(playerY + worldDeltaY, 2)

                                                                    ; Update the waypoint
                                                                    Waypoints[waypointNumToMove].x := newWorldX
                                                                    Waypoints[waypointNumToMove].y := newWorldY

                                                                    ; Destroy old GUI if it exists
                                                                    oldGuiName := WaypointGUIs[waypointNumToMove]
                                                                    if (oldGuiName != "") {
                                                                        Gui, %oldGuiName%:Destroy
                                                                        WaypointGUIs.Delete(waypointNumToMove)
                                                                    }

                                                                    ; Save waypoint to INI file
                                                                    if (SelectedRouteFile) {
                                                                        FileEncoding, UTF-8
                                                                        IniWrite, %newWorldX%, %SelectedRouteFile%, Waypoints, X%waypointNumToMove%
                                                                        IniWrite, %newWorldY%, %SelectedRouteFile%, Waypoints, Y%waypointNumToMove%
                                                                        FileEncoding
                                                                    }

                                                                    ; Create visual waypoint directly at click position
                                                                    guiName := "Waypoint" . waypointNumToMove
                                                                    WaypointGUIs[waypointNumToMove] := guiName

                                                                    Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                                                    Gui, %guiName%:Color, 00FF00
                                                                    Gui, %guiName%:Font, s8 cWhite Bold

                                                                    waypointText := waypointNumToMove
                                                                    Gui, %guiName%:Add, Text, x0 y0 w%WaypointSize% h%WaypointSize% Center BackgroundTrans, %waypointText%

                                                                    ; Place GUI at exact click position - center the waypoint on the cursor
                                                                    halfSize := WaypointSize // 2
                                                                    waypointX := clickX - halfSize
                                                                    waypointY := clickY - halfSize

                                                                    ; Show the GUI at the click position
                                                                    Gui, %guiName%:Show, x%waypointX% y%waypointY% w%WaypointSize% h%WaypointSize% NA
                                                                    WinSet, Transparent, 150, %guiName%

                                                                    ; Make it click-through
                                                                    WinGet, waypointHwnd, ID, %guiName%
                                                                    if (waypointHwnd) {
                                                                        exStyle := DllCall("GetWindowLong", "Ptr", waypointHwnd, "Int", -20, "UInt")
                                                                        exStyle := exStyle | 0x20 | 0x80000
                                                                        DllCall("SetWindowLong", "Ptr", waypointHwnd, "Int", -20, "UInt", exStyle)
                                                                    }

                                                                    ; Start the update timer if not already running
                                                                    SetTimer, UpdateAllWaypoints, 500

                                                                    ToolTip, Waypoint #%waypointNumToMove% moved to X:%newWorldX% Y:%newWorldY%, 0, 0
                                                                    SetTimer, ClearTooltip, -2000
                                                                return

                                                                ; Update status
                                                                GuiControl,, NodeStatus, Nodes: 0 placed
                                                                MsgBox, All nodes cleared!
                                                                return

                                                                ListNodes:
                                                                    if (TargetNodes.Length() = 0) {
                                                                        MsgBox, No nodes placed yet!
                                                                        return
                                                                    }

                                                                    nodeList := "PLACED TARGET NODES:`n`n"
                                                                    for index, node in TargetNodes {
                                                                        nodeList .= "Node #" . node.id . ": X=" . node.worldX . " Y=" . node.worldY . "`n"
                                                                    }
                                                                    nodeList .= "`nUsage in commands:`nworldclick,1 (clicks node #1)`nworldclick,2 (clicks node #2)`netc."

                                                                    MsgBox, %nodeList%
                                                                return

                                                                MoveNode:
                                                                    ; Ask user for node number
                                                                    InputBox, nodeNumToMove, Move Node, Enter the node ID to move:, , 300, 150
                                                                    if (ErrorLevel) {
                                                                        return ; User cancelled
                                                                    }

                                                                    ; Validate input
                                                                    if (nodeNumToMove = "" || nodeNumToMove < 1) {
                                                                        MsgBox, Invalid node ID!
                                                                        return
                                                                    }

                                                                    ; Check if node exists
                                                                    nodeExists := false
                                                                    for index, node in TargetNodes {
                                                                        if (node.id = nodeNumToMove) {
                                                                            nodeExists := true
                                                                            break
                                                                        }
                                                                    }

                                                                    if (!nodeExists) {
                                                                        MsgBox, Node #%nodeNumToMove% does not exist!
                                                                        return
                                                                    }

                                                                    ; Auto-sync TargetGameWindow with win1 if not set
                                                                    if (!TargetGameWindow && win1) {
                                                                        TargetGameWindow := win1
                                                                    }

                                                                    if (!TargetGameWindow) {
                                                                        MsgBox, No game window selected! Please select a window first.
                                                                        return
                                                                    }

                                                                    ; Activate the game window
                                                                    WinActivate, ahk_id %TargetGameWindow%
                                                                    Sleep, 200

                                                                    ; Show instruction
                                                                    MsgBox, 64, Move Node, Right-click on the new position for node #%nodeNumToMove% in the game window., 3

                                                                    ; Wait for right-click
                                                                    KeyWait, RButton, D

                                                                    ; Get the click position (use CoordMode to ensure we get screen coordinates)
                                                                    CoordMode, Mouse, Screen
                                                                    MouseGetPos, clickX, clickY, clickWinID

                                                                    ; Verify click was in game window
                                                                    if (clickWinID <> TargetGameWindow) {
                                                                        MsgBox, Click was not in the game window! Move cancelled.
                                                                        return
                                                                    }

                                                                    ; Get current player coordinates
                                                                    GetCurrentCoordinates(playerX, playerY)
                                                                    if (playerX = "" || playerY = "") {
                                                                        MsgBox, Could not read current coordinates! Make sure coordinates are visible.
                                                                        return
                                                                    }

                                                                    ; Get game window position
                                                                    WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                                                    ; Calculate pixel offset from character center (window-relative coordinates)
                                                                    baseScreenX := winX + 516
                                                                    baseScreenY := winY + 410
                                                                    screenRelativeX := clickX - baseScreenX
                                                                    screenRelativeY := clickY - baseScreenY

                                                                    ; Reverse NavigateToCoordinatesClick calculations
                                                                    ; NOTE: NavigateToCoordinatesClick uses "clickY = baseClickY - rotatedY" (MINUS!)
                                                                    ; So to reverse: rotatedY = baseClickY - clickY = -(clickY - baseClickY) = -screenRelativeY
                                                                    rotatedX := screenRelativeX
                                                                    rotatedY := -screenRelativeY ; NEGATIVE because of the minus in NavigateToCoordinatesClick!

                                                                    ; Undo rotation (inverse of NavigateToCoordinatesClick rotation with -CameraAngle)
                                                                    cos_angle := Cos(-CameraAngle)
                                                                    sin_angle := Sin(-CameraAngle)

                                                                    ; Forward rotation: rotatedX = scaledX * cos - scaledY * sin
                                                                    ; Forward rotation: rotatedY = scaledX * sin + scaledY * cos
                                                                    ; Inverse: scaledX = rotatedX * cos + rotatedY * sin
                                                                    ; Inverse: scaledY = -rotatedX * sin + rotatedY * cos
                                                                    scaledX := rotatedX * cos_angle + rotatedY * sin_angle
                                                                    scaledY := -rotatedX * sin_angle + rotatedY * cos_angle

                                                                    ; Undo distance correction (NavigateToCoordinatesClick: scaledX *= 0.94, scaledY *= 1.19)
                                                                    scaledX := scaledX / 0.94
                                                                    scaledY := scaledY / 1.19

                                                                    ; Calculate Y scaling (same formula as NavigateToCoordinatesClick)
                                                                    if (CameraRadius <= 900) {
                                                                        pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                                    } else if (CameraRadius <= 1000) {
                                                                        t := (CameraRadius - 900) / 100
                                                                        pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                                    } else if (CameraRadius <= 1500) {
                                                                        t := (CameraRadius - 1000) / 500
                                                                        pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                                    } else {
                                                                        t := (CameraRadius - 1500) / 500
                                                                        pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                                    }

                                                                    ; Undo scaling (reverse of: scaledX = -deltaX * 1.21, scaledY = -deltaY * pixelsPerGameUnitY)
                                                                    worldDeltaX := -scaledX / 1.21
                                                                    worldDeltaY := -scaledY / pixelsPerGameUnitY

                                                                    ; Calculate world coordinates
                                                                    newWorldX := Round(playerX + worldDeltaX, 2)
                                                                    newWorldY := Round(playerY + worldDeltaY, 2)

                                                                    ; Update the node in the array
                                                                    for index, node in TargetNodes {
                                                                        if (node.id = nodeNumToMove) {
                                                                            TargetNodes[index].worldX := newWorldX
                                                                            TargetNodes[index].worldY := newWorldY
                                                                            break
                                                                        }
                                                                    }

                                                                    ; Destroy old GUI if it exists
                                                                    oldGuiName := NodeGUIs[nodeNumToMove]
                                                                    if (oldGuiName != "") {
                                                                        Gui, %oldGuiName%:Destroy
                                                                    }

                                                                    ; Save nodes to file
                                                                    SaveNodes()

                                                                    ; Create visual node directly at click position (like AddTargetNode does)
                                                                    guiName := "TargetNode" . nodeNumToMove
                                                                    NodeGUIs[nodeNumToMove] := guiName

                                                                    ; Use global NodeSize variable
                                                                    nodeW := NodeSize
                                                                    nodeH := NodeSize

                                                                    Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                                                    Gui, %guiName%:Color, FF0000
                                                                    Gui, %guiName%:Font, s8 cWhite Bold
                                                                    nodeIDText := nodeNumToMove
                                                                    Gui, %guiName%:Add, Text, x0 y0 w%nodeW% h%nodeH% Center BackgroundTrans, %nodeIDText%

                                                                    ; Place GUI at exact click position - center the node on the cursor
                                                                    halfSize := NodeSize // 2
                                                                    nodeX := clickX - halfSize
                                                                    nodeY := clickY - halfSize

                                                                    ; Show the GUI at the click position
                                                                    Gui, %guiName%:Show, x%nodeX% y%nodeY% w%nodeW% h%nodeH% NoActivate
                                                                    WinSet, Transparent, 150, %guiName%

                                                                    ; Make it click-through
                                                                    WinGet, nodeHwnd, ID, %guiName%
                                                                    if (nodeHwnd) {
                                                                        MakeWindowClickThroughByHandle(nodeHwnd)
                                                                    }

                                                                    ; Start the update timer if not already running
                                                                    SetTimer, UpdateAllTargetNodes, 500

                                                                    ToolTip, Node #%nodeNumToMove% moved to X:%newWorldX% Y:%newWorldY%, 0, 0
                                                                    SetTimer, ClearTooltip, -2000
                                                                return

                                                                MonitorNodeMoves:
                                                                    if (!NodeMoveMode)
                                                                        return

                                                                    ; Check if left mouse button is pressed over a node GUI
                                                                    if (GetKeyState("LButton", "P")) {
                                                                        if (!NodeBeingDragged) {
                                                                            ; Check if mouse is over any node GUI
                                                                            MouseGetPos,,, hoveredWin
                                                                            hoveredWinTitle := ""
                                                                            WinGetTitle, hoveredWinTitle, ahk_id %hoveredWin%

                                                                            ; Check if it's a target node GUI
                                                                            if (InStr(hoveredWinTitle, "TargetNode")) {
                                                                                ; Extract node ID from window title
                                                                                nodeID := StrReplace(hoveredWinTitle, "TargetNode", "")
                                                                                if (nodeID > 0) {
                                                                                    NodeBeingDragged := true
                                                                                    DraggedNodeID := nodeID
                                                                                    ToolTip, Moving Node #%nodeID%... Release to set position. Press ESC when all moves are done., 0, 0, 1
                                                                                }
                                                                            }
                                                                        }
                                                                    } else {
                                                                        ; Left button released
                                                                        if (NodeBeingDragged) {
                                                                            ; Update the world coordinates of the dragged node
                                                                            UpdateNodeWorldCoordinatesInMoveMode(DraggedNodeID)
                                                                            NodeBeingDragged := false
                                                                            DraggedNodeID := 0
                                                                            ToolTip, MOVE MODE: Drag nodes to reposition them. Press ESC to save and exit., 0, 0, 1
                                                                        }
                                                                    }
                                                                return

                                                                MsgBox, %nodeList%
                                                                return

                                                                ShowRouteInfo:
                                                                    info := "=== ROUTE DEBUG INFO ===`n`n"

                                                                    if (SelectedRouteFile) {
                                                                        info .= "📁 Route File: " . SelectedRouteFile . "`n"
                                                                        info .= " File Exists: " . (FileExist(SelectedRouteFile) ? "YES" : "NO") . "`n`n"
                                                                    } else {
                                                                        info .= "❌ NO ROUTE FILE SELECTED!`n"
                                                                        info .= " → Click 'Select Route' to load existing route`n"
                                                                        info .= " → Click 'New Path' to create new route`n`n"
                                                                    }

                                                                    info .= "🟢 Waypoints in memory: " . Waypoints.Length() . "`n"

                                                                    if (SelectedRouteFile && FileExist(SelectedRouteFile)) {
                                                                        IniRead, fileWaypointCount, %SelectedRouteFile%, Waypoints, Count, 0
                                                                        info .= "📄 Waypoints in file: " . fileWaypointCount . "`n`n"

                                                                        if (fileWaypointCount > 0) {
                                                                            info .= "First 3 waypoints from file:`n"
                                                                            Loop, 3 {
                                                                                if (A_Index > fileWaypointCount)
                                                                                    break
                                                                                IniRead, x, %SelectedRouteFile%, Waypoints, X%A_Index%, ERROR
                                                                                IniRead, y, %SelectedRouteFile%, Waypoints, Y%A_Index%, ERROR
                                                                                info .= " #" . A_Index . ": X=" . x . " Y=" . y . "`n"
                                                                            }
                                                                        }
                                                                    }

                                                                    info .= "`n🔴 Target Nodes: " . TargetNodes.Length()
                                                                    info .= "`n🎮 Game Window: " . (TargetGameWindow ? "Selected" : "NOT SELECTED")

                                                                    MsgBox, 0, Route Information, %info%, 10
                                                                return

                                                                AddWaypoint:
                                                                    if (!SelectedRouteFile) {
                                                                        MsgBox, No route file selected! Create or select a route first.`n`nPlease click "Select Route" to load an existing route`nor click "New Path" to create a new route.
                                                                        return
                                                                    }

                                                                    if (!TargetGameWindow) {
                                                                        MsgBox, No target window selected! Please click "Select Window" first.
                                                                        return
                                                                    }

                                                                    ; Cancel node placement mode if active
                                                                    if (PlacingNodeMode) {
                                                                        PlacingNodeMode := false
                                                                        SetTimer, CheckForNodePlacement, Off
                                                                    }

                                                                    PlacingWaypointMode := true
                                                                    ToolTip, Right-click in the game window to add a waypoint. Press ESC to cancel., 1
                                                                    SetTimer, CheckForWaypointPlacement, 100
                                                                return

                                                                CheckForWaypointPlacement:
                                                                    if (!PlacingWaypointMode) {
                                                                        SetTimer, CheckForWaypointPlacement, Off
                                                                        ToolTip,, 1
                                                                        return
                                                                    }

                                                                    if (GetKeyState("Escape", "P")) {
                                                                        PlacingWaypointMode := false
                                                                        SetTimer, CheckForWaypointPlacement, Off
                                                                        ToolTip,, 1
                                                                        return
                                                                    }

                                                                    if (GetKeyState("RButton", "P")) {
                                                                        ; Get mouse position
                                                                        MouseGetPos, mouseX, mouseY, mouseWin

                                                                        ; Debug: Show what window we clicked
                                                                        ToolTip, Clicked window: %mouseWin%`nTarget: %TargetGameWindow%`nMouse: %mouseX%`, %mouseY%, 1

                                                                        ; Verify we clicked in the game window (compare window IDs)
                                                                        if (mouseWin != TargetGameWindow) {
                                                                            ToolTip, Wrong window! Clicked: %mouseWin%`nTarget: %TargetGameWindow%, 1
                                                                            SetTimer, ClearTooltip, -3000
                                                                            return
                                                                        }

                                                                        ; Get window position
                                                                        WinGetPos, winX, winY, winW, winH, ahk_id %TargetGameWindow%

                                                                        ; Get player's current position
                                                                        GetCurrentCoordinates(playerX, playerY)
                                                                        if (playerX = "" || playerY = "") {
                                                                            ToolTip, Could not get current coordinates!, 1
                                                                            return
                                                                        }

                                                                        ; Calculate relative screen position from character center
                                                                        charScreenX := winX + 516
                                                                        charScreenY := winY + 410

                                                                        screenDeltaX := mouseX - charScreenX
                                                                        screenDeltaY := mouseY - charScreenY

                                                                        ; Reverse rotation (use global CameraAngle)
                                                                        rotatedX := screenDeltaX * Cos(-CameraAngle) - screenDeltaY * Sin(-CameraAngle)
                                                                        rotatedY := screenDeltaX * Sin(-CameraAngle) + screenDeltaY * Cos(-CameraAngle)

                                                                        ; Reverse distance correction
                                                                        scaledX := rotatedX / 0.94
                                                                        scaledY := rotatedY / 1.19

                                                                        ; Reverse coordinate scaling
                                                                        deltaX := -scaledX / 1.21 ; Negative because X was negated
                                                                        deltaY := scaledY / 0.95

                                                                        ; Calculate world coordinates
                                                                        worldX := playerX + deltaX
                                                                        worldY := playerY + deltaY

                                                                        ; Add waypoint to array
                                                                        Waypoints.Push({x: worldX, y: worldY})
                                                                        waypointIndex := Waypoints.Length()

                                                                        ; Make LOCAL copies to prevent any interference
                                                                        saveWaypointIndex := waypointIndex
                                                                        saveWorldX := worldX
                                                                        saveWorldY := worldY

                                                                        ; LOG FILE for debugging
                                                                        logFile := A_ScriptDir . "\waypoint_save_log.txt"
                                                                        FormatTime, timeStamp, , yyyy-MM-dd HH:mm:ss
                                                                        FileAppend, [%timeStamp%] Attempting to save Waypoint #%saveWaypointIndex%`n, %logFile%

                                                                        ; Save to file with ROBUST verification and retry logic
                                                                        maxRetries := 3
                                                                        saveSuccess := false

                                                                        Loop, %maxRetries% {
                                                                            attemptNum := A_Index

                                                                            FileAppend, [%timeStamp%] Attempt %attemptNum%: Writing Count=%saveWaypointIndex% X=%saveWorldX% Y=%saveWorldY%`n, %logFile%

                                                                            ; Write all three values using LOCAL copies
                                                                            IniWrite, %saveWaypointIndex%, %SelectedRouteFile%, Waypoints, Count
                                                                            Sleep, 20
                                                                            IniWrite, %saveWorldX%, %SelectedRouteFile%, Waypoints, X%saveWaypointIndex%
                                                                            Sleep, 20
                                                                            IniWrite, %saveWorldY%, %SelectedRouteFile%, Waypoints, Y%saveWaypointIndex%
                                                                            Sleep, 100 ; Wait for filesystem

                                                                            ; VERIFY that both X and Y were written successfully using LOCAL copies
                                                                            IniRead, verifyX, %SelectedRouteFile%, Waypoints, X%saveWaypointIndex%, ERROR
                                                                            IniRead, verifyY, %SelectedRouteFile%, Waypoints, Y%saveWaypointIndex%, ERROR
                                                                            IniRead, verifyCount, %SelectedRouteFile%, Waypoints, Count, ERROR

                                                                            ; Trim any whitespace
                                                                            verifyX := Trim(verifyX)
                                                                            verifyY := Trim(verifyY)
                                                                            verifyCount := Trim(verifyCount)

                                                                            FileAppend, [%timeStamp%] Attempt %attemptNum%: Verification Count=%verifyCount% X=%verifyX% Y=%verifyY%`n, %logFile%

                                                                            ; Check if both values are valid AND count matches
                                                                            if (verifyX != "ERROR" && verifyY != "ERROR" && verifyX != "" && verifyY != "" && verifyCount = saveWaypointIndex) {
                                                                                ; Also verify the values match what we tried to write
                                                                                if (Abs(verifyX - saveWorldX) < 0.01 && Abs(verifyY - saveWorldY) < 0.01) {
                                                                                    saveSuccess := true
                                                                                    FileAppend, [%timeStamp%] SUCCESS on attempt %attemptNum%`n`n, %logFile%
                                                                                    break
                                                                                } else {
                                                                                    FileAppend, [%timeStamp%] Values don't match! Expected X=%saveWorldX% Y=%saveWorldY%`n, %logFile%
                                                                                }
                                                                            } else {
                                                                                FileAppend, [%timeStamp%] Missing values or count mismatch! Count=%verifyCount% (expected %saveWaypointIndex%) X=%verifyX% Y=%verifyY%`n, %logFile%
                                                                            }

                                                                            ; If not last attempt, wait before retry
                                                                            if (attemptNum < maxRetries) {
                                                                                Sleep, 200
                                                                            }
                                                                        }

                                                                        if (!saveSuccess) {
                                                                            ; All retries failed! Remove from array and show error
                                                                            Waypoints.Pop()
                                                                            ; Also try to clean up partial writes using LOCAL copies
                                                                            IniDelete, %SelectedRouteFile%, Waypoints, X%saveWaypointIndex%
                                                                            IniDelete, %SelectedRouteFile%, Waypoints, Y%saveWaypointIndex%
                                                                            ; Restore previous count
                                                                            prevCount := saveWaypointIndex - 1
                                                                            IniWrite, %prevCount%, %SelectedRouteFile%, Waypoints, Count

                                                                            FileAppend, [%timeStamp%] ❌ FAILED after %maxRetries% attempts - removed from array`n`n, %logFile%

                                                                            ToolTip, ❌ FAILED TO SAVE WAYPOINT after %maxRetries% attempts!`nX=%verifyX% Y=%verifyY%`nFile may be locked or disk full!`nCheck waypoint_save_log.txt, 1
                                                                            SetTimer, ClearTooltip, -5000
                                                                            KeyWait, RButton
                                                                            return
                                                                        }

                                                                        ; Create visual waypoint only after successful save using LOCAL copies
                                                                        CreateVisualWaypoint(saveWaypointIndex, saveWorldX, saveWorldY)

                                                                        ; Start update timer if not already running
                                                                        SetTimer, UpdateAllWaypoints, 500

                                                                        ; Update GUI
                                                                        SplitPath, SelectedRouteFile, fileName
                                                                        GuiControl,, RouteStatus, Route: %fileName% (%saveWaypointIndex% waypoints)
                                                                        GuiControl, Enable, PrevWaypointBtn
                                                                        GuiControl, Enable, NextWaypointBtn
                                                                        GuiControl, Enable, GotoBtn

                                                                        ; Show success tooltip
                                                                        ToolTip, ✓ Waypoint %saveWaypointIndex% saved: X=%saveWorldX% Y=%saveWorldY%`nRight-click for more or press ESC to finish, 1
                                                                            SetTimer, ClearTooltip, -2000

                                                                        ; Wait for mouse button release before continuing
                                                                        KeyWait, RButton

                                                                        ; Stay in placement mode for adding more waypoints
                                                                        ; User can press ESC to exit
                                                                    }
                                                                return
                                                                ; Replace your LoadWaypoints function with this improved version:
                                                                LoadWaypoints() {
                                                                    if (!SelectedRouteFile || !FileExist(SelectedRouteFile)) {
                                                                        return
                                                                    }

                                                                    IniRead, waypointCount, %SelectedRouteFile%, Waypoints, Count, 0
                                                                    Waypoints := []
                                                                    WaypointCommands := {} ; Clear existing commands

                                                                    ; Debug: Show what count was read
                                                                    debugInfo := "Loading from: " . SelectedRouteFile . "`n"
                                                                    debugInfo .= "File says: " . waypointCount . " waypoints`n`n"

                                                                    ; Load waypoints - only add to array if both X and Y are valid
                                                                    actualCount := 0
                                                                    skippedWaypoints := ""
                                                                    Loop, %waypointCount% {
                                                                        IniRead, x, %SelectedRouteFile%, Waypoints, X%A_Index%, ERROR
                                                                        IniRead, y, %SelectedRouteFile%, Waypoints, Y%A_Index%, ERROR

                                                                        ; Clean up any whitespace
                                                                        x := Trim(x)
                                                                        y := Trim(y)

                                                                        ; Check if coordinates are valid (not ERROR, not empty, and numeric)
                                                                        if (x != "ERROR" && y != "ERROR" && x != "" && y != "" && x is number && y is number) {
                                                                            Waypoints.Push({x: x+0, y: y+0}) ; +0 converts to number
                                                                            actualCount++

                                                                            ; Load commands for this waypoint and convert delimiters back to newlines
                                                                            IniRead, command, %SelectedRouteFile%, Commands, Waypoint%A_Index%, ERROR
                                                                            if (command != "ERROR" && command != "") {
                                                                                ; Convert delimiter back to newlines
                                                                                command := StrReplace(command, "||NEWLINE||", "`n")
                                                                                WaypointCommands[A_Index] := command
                                                                            }
                                                                        } else {
                                                                            ; Track which waypoints were skipped and why
                                                                            reason := ""
                                                                            if (x = "ERROR" || x = "")
                                                                                reason .= "Missing X "
                                                                            if (y = "ERROR" || y = "")
                                                                                reason .= "Missing Y "
                                                                            if (x != "ERROR" && x != "" && !(x is number))
                                                                                reason .= "Invalid X "
                                                                            if (y != "ERROR" && y != "" && !(y is number))
                                                                                reason .= "Invalid Y "
                                                                            skippedWaypoints .= "WP#" . A_Index . ": " . reason . "`n"
                                                                        }
                                                                    }

                                                                    ; Check if actual loaded waypoints match the count
                                                                    loadedCount := Waypoints.Length()

                                                                    ; Build detailed debug message
                                                                    debugInfo .= "Successfully loaded: " . loadedCount . " waypoints`n"
                                                                    if (skippedWaypoints != "") {
                                                                        debugInfo .= "`nSKIPPED WAYPOINTS:`n" . skippedWaypoints
                                                                    }

                                                                    ; Show debug info
                                                                    MsgBox, 0, Load Complete, %debugInfo%, 8

                                                                    ; DON'T auto-correct the count - let user see the discrepancy
                                                                    ; If we auto-correct, we might be hiding a real problem
                                                                    ; User should manually fix the INI file or clear and recreate waypoints

                                                                    ; Don't create visual waypoints here - let the update timer create them on-demand
                                                                    ; This prevents GUI creation conflicts when loading many waypoints
                                                                    DestroyAllVisualWaypoints()

                                                                    ; Start the update timer - it will create GUIs as needed for nearby waypoints
                                                                    if (Waypoints.Length() > 0) {
                                                                        SetTimer, UpdateAllWaypoints, 500
                                                                    }
                                                                }

                                                                SaveNodes() {
                                                                    if (!SelectedRouteFile) {
                                                                        MsgBox, No route file selected!
                                                                        return
                                                                    }

                                                                    ; Clear existing nodes from file
                                                                    IniDelete, %SelectedRouteFile%, Nodes

                                                                    ; Save node count
                                                                    nodeCount := TargetNodes.Length()
                                                                    IniWrite, %nodeCount%, %SelectedRouteFile%, Nodes, Count

                                                                    ; Save each node
                                                                    for index, node in TargetNodes {
                                                                        IniWrite, % node.id, %SelectedRouteFile%, Nodes, ID%index%
                                                                        IniWrite, % node.worldX, %SelectedRouteFile%, Nodes, X%index%
                                                                        IniWrite, % node.worldY, %SelectedRouteFile%, Nodes, Y%index%
                                                                    }

                                                                    ; Update NextNodeID
                                                                    IniWrite, %NextNodeID%, %SelectedRouteFile%, Nodes, NextID
                                                                }

                                                                LoadNodes() {
                                                                    if (!SelectedRouteFile || !FileExist(SelectedRouteFile)) {
                                                                        return
                                                                    }

                                                                    ; Clear existing nodes with delay to prevent errors
                                                                    for nodeID in NodeGUIs {
                                                                        guiName := NodeGUIs[nodeID]
                                                                        if (guiName != "") {
                                                                            Gui, %guiName%:Destroy
                                                                            Sleep, 50 ; Add delay between destroying each GUI
                                                                        }
                                                                    }
                                                                    TargetNodes := []
                                                                    NodeGUIs := {}

                                                                    ; Read node count
                                                                    IniRead, nodeCount, %SelectedRouteFile%, Nodes, Count, 0

                                                                    if (nodeCount = 0) {
                                                                        NextNodeID := 1
                                                                        return
                                                                    }

                                                                    ; Load each node (just the data, not the visuals)
                                                                    Loop, %nodeCount% {
                                                                        IniRead, nodeID, %SelectedRouteFile%, Nodes, ID%A_Index%, ERROR
                                                                        IniRead, worldX, %SelectedRouteFile%, Nodes, X%A_Index%, ERROR
                                                                        IniRead, worldY, %SelectedRouteFile%, Nodes, Y%A_Index%, ERROR

                                                                        if (nodeID != "ERROR" && worldX != "ERROR" && worldY != "ERROR") {
                                                                            node := {id: nodeID, worldX: worldX+0, worldY: worldY+0}
                                                                            TargetNodes.Push(node)
                                                                        }
                                                                    }

                                                                    ; Load NextNodeID
                                                                    IniRead, savedNextID, %SelectedRouteFile%, Nodes, NextID, 1
                                                                    NextNodeID := savedNextID

                                                                    ; Start the update timer - it will create GUIs as needed for nearby nodes
                                                                    if (TargetNodes.Length() > 0) {
                                                                        SetTimer, UpdateAllTargetNodes, 500
                                                                    }
                                                                }

                                                                SelectRoute:
                                                                    FileSelectFile, selectedFile, 1,, Select Route File, INI Files (*.ini)
                                                                    if (selectedFile != "") {
                                                                        SelectedRouteFile := selectedFile
                                                                        NavSelectedRouteFile := selectedFile ; Also set the nav variable

                                                                        ; Load waypoints and nodes
                                                                        LoadWaypoints()
                                                                        LoadNodes()

                                                                        ; Update status
                                                                        SplitPath, selectedFile, fileName
                                                                        waypointCount := Waypoints.Length()
                                                                        nodeCount := TargetNodes.Length()
                                                                        GuiControl,, RouteStatus, Route: %fileName% (%waypointCount% waypoints)
                                                                        GuiControl,, NodeStatus, Nodes: %nodeCount% placed
                                                                        GuiControl,, NavRouteStatus, Route: %fileName% (%waypointCount% waypoints)

                                                                        ; Enable navigation buttons if waypoints exist
                                                                        if (waypointCount > 0) {
                                                                            GuiControl, Enable, PrevWaypointBtn
                                                                            GuiControl, Enable, NextWaypointBtn
                                                                            GuiControl, Enable, GotoBtn
                                                                        }

                                                                        MsgBox, Route loaded: %fileName%`nWaypoints: %waypointCount%`nNodes: %nodeCount%
                                                                        UpdateStatusBar()
                                                                    }
                                                                return

                                                                ClearWaypoints:
                                                                    if (!SelectedRouteFile) {
                                                                        MsgBox, No route file selected!
                                                                        return
                                                                    }

                                                                    MsgBox, 4,, Clear all waypoints and commands from current route?
                                                                    IfMsgBox Yes
                                                                    {
                                                                        ; Destroy visual waypoints
                                                                        DestroyAllVisualWaypoints()

                                                                        Waypoints := []
                                                                        WaypointCommands := {} ; Clear commands too
                                                                        IniWrite, 0, %SelectedRouteFile%, Waypoints, Count
                                                                        Loop, 200 {
                                                                            IniDelete, %SelectedRouteFile%, Waypoints, X%A_Index%
                                                                            IniDelete, %SelectedRouteFile%, Waypoints, Y%A_Index%
                                                                            ; Also clear any commands for these waypoints
                                                                            IniDelete, %SelectedRouteFile%, Commands, Waypoint%A_Index%
                                                                        }
                                                                        MsgBox, All waypoints and commands cleared!
                                                                    }
                                                                return

                                                                OpenFunctionBlockingGUI:
                                                                    ; Destroy existing GUI if it exists to avoid conflicts
                                                                    Gui, FuncBlock:Destroy

                                                                    ; Create the Function Blocking Settings GUI
                                                                    Gui, FuncBlock:Add, Text,, Function Blocking During Navigation
                                                                    Gui, FuncBlock:Add, Text, x10 y30 w80 h20, Block From WP:
                                                                    Gui, FuncBlock:Add, Edit, x95 y30 w40 h20 vFBTimerBlockStart
                                                                    Gui, FuncBlock:Add, Text, x140 y30 w30 h25, to WP:
                                                                    Gui, FuncBlock:Add, Edit, x175 y30 w40 h20 vFBTimerBlockEnd

                                                                    Gui, FuncBlock:Add, Text, x10 y60 w60 h15, Functions:
                                                                    Gui, FuncBlock:Add, Checkbox, x10 y80 w80 h25 vFBBlockHealing, Block Healing
                                                                    Gui, FuncBlock:Add, Checkbox, x100 y80 w80 h25 vFBBlockDPS, Block DPS
                                                                    Gui, FuncBlock:Add, Checkbox, x190 y80 w100 h25 vFBBlockKeySequence, Block Buffs
                                                                    Gui, FuncBlock:Add, Checkbox, x10 y110 w100 h25 vFBBlockGnoll, Block Gnoll Buff
                                                                    Gui, FuncBlock:Add, Checkbox, x120 y110 w120 h25 vFBBlockDeathTyrant, Block Death Tyrant
                                                                    Gui, FuncBlock:Add, Checkbox, x10 y140 w120 h25 vFBBlockPotionDestroyer, Block Potion Destroyer

                                                                    Gui, FuncBlock:Add, Button, x10 y170 w100 h25 gFBAddTimerBlock, Add Block Rule
                                                                    Gui, FuncBlock:Add, Button, x120 y170 w100 h25 gFBClearTimerBlocks, Clear All Rules
                                                                    Gui, FuncBlock:Add, Button, x230 y170 w60 h25 gFBClose, Close

                                                                    Gui, FuncBlock:Add, Text, x10 y205 w280 h40 vFBTimerBlockStatus, No blocking rules set
                                                                    Gui, FuncBlock:Add, Text, x10 y250 w280 h10, Note: Blocks timers until certain waypoints are reached.

                                                                    ; Show the GUI
                                                                    Gui, FuncBlock:Show, w300 h270, Function Blocking Settings
                                                                return

                                                                FBClose:
                                                                    Gui, FuncBlock:Destroy
                                                                return

                                                                FBAddTimerBlock:
                                                                    Gui, FuncBlock:Submit, NoHide

                                                                    ; Validate input
                                                                    if (FBTimerBlockStart = "" || FBTimerBlockEnd = "" || FBTimerBlockStart < 1 || FBTimerBlockEnd < 1) {
                                                                        MsgBox, Please enter valid waypoint numbers (1 or higher)
                                                                        return
                                                                    }

                                                                    if (FBTimerBlockStart > FBTimerBlockEnd) {
                                                                        MsgBox, Start waypoint must be less than or equal to end waypoint
                                                                        return
                                                                    }

                                                                    ; Build function list based on checkboxes
                                                                    functionsToBlock := []
                                                                    if (FBBlockHealing) {
                                                                        functionsToBlock.Push("CheckHealth")
                                                                    }
                                                                    if (FBBlockDPS) {
                                                                        functionsToBlock.Push("DPSLoop")
                                                                    }
                                                                    if (FBBlockKeySequence) {
                                                                        functionsToBlock.Push("CheckExecutions")
                                                                    }
                                                                    if (FBBlockGnoll) {
                                                                        functionsToBlock.Push("gnoll")
                                                                    }
                                                                    if (FBBlockDeathTyrant) {
                                                                        functionsToBlock.Push("DeathTyrant")
                                                                    }
                                                                    if (FBBlockPotionDestroyer) {
                                                                        functionsToBlock.Push("DestroySkyPotions")
                                                                    }

                                                                    if (functionsToBlock.Length() = 0) {
                                                                        MsgBox, Please select at least one function to block
                                                                        return
                                                                    }

                                                                    ; Add the blocking rule
                                                                    SetNavFunctionBlock(FBTimerBlockStart, FBTimerBlockEnd, functionsToBlock)

                                                                    ; Update status display
                                                                    functionNames := ""
                                                                    for index, func in functionsToBlock {
                                                                        functionNames .= func . (index < functionsToBlock.Length() ? ", " : "")
                                                                    }
                                                                    GuiControl, FuncBlock:, FBTimerBlockStatus, WP %FBTimerBlockStart%-%FBTimerBlockEnd%: %functionNames%

                                                                    ; Clear input fields
                                                                    GuiControl, FuncBlock:, FBTimerBlockStart,
                                                                    GuiControl, FuncBlock:, FBTimerBlockEnd,
                                                                    GuiControl, FuncBlock:, FBBlockHealing, 0
                                                                    GuiControl, FuncBlock:, FBBlockDPS, 0
                                                                    GuiControl, FuncBlock:, FBBlockKeySequence, 0
                                                                    GuiControl, FuncBlock:, FBBlockGnoll, 0
                                                                    GuiControl, FuncBlock:, FBBlockDeathTyrant, 0
                                                                    GuiControl, FuncBlock:, FBBlockPotionDestroyer, 0

                                                                    MsgBox, Function blocking rule added: Waypoints %FBTimerBlockStart%-%FBTimerBlockEnd%
                                                                return

                                                                FBClearTimerBlocks:
                                                                    global NavFunctionBlockRanges
                                                                    NavFunctionBlockRanges := {}
                                                                    GuiControl, FuncBlock:, FBTimerBlockStatus, No blocking rules set
                                                                    MsgBox, All function blocking rules cleared
                                                                return

                                                                AddTimerBlock:
                                                                    Gui, Submit, NoHide

                                                                    ; Validate input
                                                                    if (TimerBlockStart = "" || TimerBlockEnd = "" || TimerBlockStart < 1 || TimerBlockEnd < 1) {
                                                                        MsgBox, Please enter valid waypoint numbers (1 or higher)
                                                                        return
                                                                    }

                                                                    if (TimerBlockStart > TimerBlockEnd) {
                                                                        MsgBox, Start waypoint must be less than or equal to end waypoint
                                                                        return
                                                                    }

                                                                    ; Build function list based on checkboxes
                                                                    functionsToBlock := []
                                                                    if (BlockHealing) {
                                                                        functionsToBlock.Push("CheckHealth")
                                                                    }
                                                                    if (BlockDPS) {
                                                                        functionsToBlock.Push("DPSLoop")
                                                                    }
                                                                    if (BlockKeySequence) {
                                                                        functionsToBlock.Push("CheckExecutions")
                                                                    }

                                                                    if (functionsToBlock.Length() = 0) {
                                                                        MsgBox, Please select at least one function to block
                                                                        return
                                                                    }

                                                                    ; Add the blocking rule
                                                                    SetNavFunctionBlock(TimerBlockStart, TimerBlockEnd, functionsToBlock)

                                                                    ; Update status display
                                                                    functionNames := ""
                                                                    for index, func in functionsToBlock {
                                                                        functionNames .= func . (index < functionsToBlock.Length() ? ", " : "")
                                                                    }
                                                                    GuiControl,, TimerBlockStatus, WP %TimerBlockStart%-%TimerBlockEnd%: %functionNames%

                                                                    ; Clear input fields
                                                                    GuiControl,, TimerBlockStart,
                                                                    GuiControl,, TimerBlockEnd,
                                                                    GuiControl,, BlockHealing, 0
                                                                    GuiControl,, BlockDPS, 0
                                                                    GuiControl,, BlockKeySequence, 0

                                                                    MsgBox, Function blocking rule added: Waypoints %TimerBlockStart%-%TimerBlockEnd%
                                                                return

                                                                ClearTimerBlocks:
                                                                    global NavFunctionBlockRanges
                                                                    NavFunctionBlockRanges := {}
                                                                    GuiControl,, TimerBlockStatus, No blocking rules set
                                                                    MsgBox, All function blocking rules cleared
                                                                return

                                                                DeleteWaypoint:
                                                                    Gui, Submit, NoHide

                                                                    if (DeleteWaypointID = "" || DeleteWaypointID < 1) {
                                                                        MsgBox, Please enter a valid waypoint number!
                                                                        return
                                                                    }

                                                                    waypointTotal := Waypoints.Length()
                                                                    if (DeleteWaypointID > waypointTotal) {
                                                                        MsgBox, Waypoint #%DeleteWaypointID% does not exist! (Only %waypointTotal% waypoints)
                                                                        return
                                                                    }

                                                                    ; Destroy the GUI for this waypoint
                                                                    guiName := WaypointGUIs[DeleteWaypointID]
                                                                    if (guiName != "") {
                                                                        Gui, %guiName%:Destroy
                                                                    }
                                                                    WaypointGUIs.Delete(DeleteWaypointID)

                                                                    ; Remove waypoint from array
                                                                    Waypoints.RemoveAt(DeleteWaypointID)

                                                                    ; Remove command for this waypoint
                                                                    WaypointCommands.Delete(DeleteWaypointID)

                                                                    ; Now we need to rebuild the GUIs map since indices shifted
                                                                    ; Destroy all remaining waypoint GUIs
                                                                    for waypointIndex, guiName in WaypointGUIs {
                                                                        if (guiName != "") {
                                                                            Gui, %guiName%:Destroy
                                                                        }
                                                                    }
                                                                    WaypointGUIs := {}

                                                                    ; Rebuild commands map (shift indices down)
                                                                    newCommands := {}
                                                                    for waypointIndex, cmd in WaypointCommands {
                                                                        if (waypointIndex < DeleteWaypointID) {
                                                                            newCommands[waypointIndex] := cmd
                                                                        } else if (waypointIndex > DeleteWaypointID) {
                                                                            newCommands[waypointIndex - 1] := cmd
                                                                        }
                                                                    }
                                                                    WaypointCommands := newCommands

                                                                    ; Save updated waypoints to file
                                                                    if (!SelectedRouteFile) {
                                                                        MsgBox, No route file selected!
                                                                        return
                                                                    }

                                                                    ; First clear all waypoint data
                                                                    Loop, 200 {
                                                                        IniDelete, %SelectedRouteFile%, Waypoints, X%A_Index%
                                                                        IniDelete, %SelectedRouteFile%, Waypoints, Y%A_Index%
                                                                        IniDelete, %SelectedRouteFile%, Commands, Waypoint%A_Index%
                                                                    }

                                                                    ; Write updated waypoints
                                                                    waypointCount := Waypoints.Length()
                                                                    IniWrite, %waypointCount%, %SelectedRouteFile%, Waypoints, Count

                                                                    for index, waypoint in Waypoints {
                                                                        wpX := waypoint.x
                                                                        wpY := waypoint.y
                                                                        IniWrite, %wpX%, %SelectedRouteFile%, Waypoints, X%index%
                                                                        IniWrite, %wpY%, %SelectedRouteFile%, Waypoints, Y%index%
                                                                    }

                                                                    ; Write updated commands
                                                                    for waypointIndex, cmd in WaypointCommands {
                                                                        IniWrite, %cmd%, %SelectedRouteFile%, Commands, Waypoint%waypointIndex%
                                                                    }

                                                                    ; Update status
                                                                    waypointCount := Waypoints.Length()
                                                                    SplitPath, SelectedRouteFile, fileName
                                                                    GuiControl,, RouteStatus, Route: %fileName% (%waypointCount% waypoints)
                                                                    GuiControl,, DeleteWaypointID, ; Clear input field

                                                                    ; Restart update timer to recreate GUIs
                                                                    if (waypointCount > 0) {
                                                                        SetTimer, UpdateAllWaypoints, 500
                                                                    }

                                                                    ;MsgBox, Waypoint #%DeleteWaypointID% deleted! Remaining waypoints renumbered.
                                                                return

                                                                DestroyAllVisualWaypoints() {
                                                                    global WaypointGUIs, Waypoints

                                                                    ; Destroy all waypoint GUIs with delay to prevent errors
                                                                    for waypointIndex, guiName in WaypointGUIs {
                                                                        Gui, %guiName%:Destroy
                                                                        Sleep, 50 ; Add delay between destroying each GUI
                                                                    }
                                                                    WaypointGUIs := {}

                                                                    ; Stop update timer if no waypoints
                                                                    if (Waypoints.Length() = 0) {
                                                                        SetTimer, UpdateAllWaypoints, Off
                                                                    }
                                                                }

                                                                StartTravel() {
                                                                    if (SelectedRouteFile = "") {
                                                                        MsgBox, 0, Error, Please select a route first!
                                                                        return
                                                                    }
                                                                    waypointCount := Waypoints.Length()
                                                                    if (waypointCount = 0) {
                                                                        MsgBox, No waypoints loaded. Please select a route first.
                                                                        return
                                                                    }

                                                                    ; Reset navigation state to fix reverse direction bug
                                                                    IsTraveling := false
                                                                    SetTimer, TravelLoop, Off
                                                                    SetTimer, UpdateCoordinatesDisplay, Off
                                                                    Sleep, 100

                                                                    ; Now start fresh
                                                                    IsTraveling := true
                                                                    SingleWaypointMode := false ; Full route travel
                                                                    CurrentWaypoint := 1
                                                                    GuiControl, Disable, StartBtn
                                                                    GuiControl, Enable, StopBtn
                                                                    SetTimer, UpdateCoordinatesDisplay, 50
                                                                    SetTimer, TravelLoop, 50
                                                                }

                                                                StopTravel:
                                                                    IsTraveling := false
                                                                    SetTimer, UpdateCoordinatesDisplay, off
                                                                    SetTimer, TravelLoop, Off
                                                                    ReleaseAllWASDKeys()
                                                                    GuiControl, Enable, StartBtn
                                                                    GuiControl, Disable, StopBtn
                                                                    GuiControl,, RouteStatus, Travel stopped
                                                                return

                                                                PrevWaypoint:
                                                                    waypointCount := Waypoints.Length()
                                                                    if (waypointCount = 0) {
                                                                        MsgBox, No waypoints loaded!
                                                                        return
                                                                    }
                                                                    targetWaypoint := CurrentWaypoint - 1
                                                                    if (targetWaypoint < 1) {
                                                                        targetWaypoint := waypointCount
                                                                    }
                                                                    GoToWaypoint(targetWaypoint)
                                                                return

                                                                NextWaypoint:
                                                                    waypointCount := Waypoints.Length()
                                                                    if (waypointCount = 0) {
                                                                        MsgBox, No waypoints loaded!
                                                                        return
                                                                    }
                                                                    targetWaypoint := CurrentWaypoint + 1
                                                                    if (targetWaypoint > waypointCount) {
                                                                        targetWaypoint := 1
                                                                    }
                                                                    GoToWaypoint(targetWaypoint)
                                                                return

                                                                GotoSpecificWaypoint:
                                                                    Gui, Submit, NoHide
                                                                    waypointCount := Waypoints.Length()
                                                                    if (waypointCount = 0) {
                                                                        MsgBox, No waypoints loaded!
                                                                        return
                                                                    }
                                                                    if (GotoWaypoint > 0 && GotoWaypoint <= waypointCount) {
                                                                        GoToWaypoint(GotoWaypoint)
                                                                    } else {
                                                                        MsgBox, Invalid waypoint number! Valid range: 1-%waypointCount%
                                                                    }
                                                                return

                                                                GoToWaypoint(waypointNum) {
                                                                    waypointCount := Waypoints.Length()
                                                                    if (waypointNum < 1 || waypointNum > waypointCount) {
                                                                        return
                                                                    }
                                                                    IsTraveling := true
                                                                    SingleWaypointMode := true ; Single waypoint travel
                                                                    CurrentWaypoint := waypointNum
                                                                    GuiControl, Disable, StartBtn
                                                                    GuiControl, Enable, StopBtn
                                                                    GuiControl,, RouteStatus, Going to waypoint %waypointNum%
                                                                    SetTimer, TravelLoop, 50
                                                                }

                                                                TravelLoop:
                                                                    waypointCount := Waypoints.Length()
                                                                    if (!IsTraveling || CurrentWaypoint > waypointCount) {
                                                                        IsTraveling := false
                                                                        SetTimer, TravelLoop, Off
                                                                        ; Release all WASD keys when travel stops
                                                                        ReleaseAllWASDKeys()
                                                                        GuiControl, Enable, StartBtn
                                                                        GuiControl, Disable, StopBtn
                                                                        ; Reset stuck detection
                                                                        LastStuckCheckTime := 0
                                                                        StuckMoveAttempts := 0
                                                                        ; Restore any blocked functions when travel ends
                                                                        RestoreBlockedFunctions()
                                                                        return
                                                                    }

                                                                    ; Check if we should block/unblock functions at this waypoint
                                                                    CheckWaypointFunctionBlocking()

                                                                    waypoint := Waypoints[CurrentWaypoint]
                                                                    GetCurrentCoordinates(coordsX, coordsY)

                                                                    ; Wait until coordinates are successfully read
                                                                    if (coordsX = "" || coordsY = "") {
                                                                        Sleep, 100
                                                                        return
                                                                    }

                                                                    ; Check if stuck (coordinates haven't changed for 3+ seconds)
                                                                    ; Only check if NOT executing commands
                                                                    currentTime := A_TickCount

                                                                    if (!IsExecutingCommand) {
                                                                        if (LastStuckCheckTime = 0) {
                                                                            ; Initialize stuck check
                                                                            LastStuckCheckTime := currentTime
                                                                            LastStuckCheckX := coordsX
                                                                            LastStuckCheckY := coordsY
                                                                        } else if (currentTime - LastStuckCheckTime >= 3000) {
                                                                            ; 3 seconds have passed, check if position changed
                                                                            distance := Sqrt((coordsX - LastStuckCheckX)**2 + (coordsY - LastStuckCheckY)**2)

                                                                            if (distance < 5) {
                                                                                ; Stuck! Try to unstuck
                                                                                unstuckResult := TryUnstuck()

                                                                                if (!unstuckResult && StuckMoveAttempts = 0) {
                                                                                    ; Failed after 3 attempts, waypoint was incremented
                                                                                    ; Try one more time with new waypoint, if fails go back
                                                                                    Sleep, 1000
                                                                                    GetCurrentCoordinates(checkX, checkY)
                                                                                    checkDistance := Sqrt((checkX - coordsX)**2 + (checkY - coordsY)**2)

                                                                                    if (checkDistance < 5) {
                                                                                        ; Still stuck, go to previous waypoint
                                                                                        CurrentWaypoint := CurrentWaypoint - 2
                                                                                        if (CurrentWaypoint < 1) {
                                                                                            CurrentWaypoint := 1
                                                                                        }
                                                                                        ToolTip, Next waypoint also stuck. Going to previous waypoint %CurrentWaypoint%..., 0, 0
                                                                                        SetTimer, ClearTooltip, -3000
                                                                                    }
                                                                                }
                                                                            }

                                                                            ; Reset stuck check timer
                                                                            LastStuckCheckTime := currentTime
                                                                            LastStuckCheckX := coordsX
                                                                            LastStuckCheckY := coordsY
                                                                        }
                                                                    } else {
                                                                        ; Reset stuck check when executing commands
                                                                        LastStuckCheckTime := 0
                                                                        StuckMoveAttempts := 0
                                                                    }

                                                                    ; Use configurable distance tolerance
                                                                    if (Abs(coordsX - waypoint.x) <= DistanceToleranceX && Abs(coordsY - waypoint.y) <= DistanceToleranceY) {
                                                                        ; Reset stuck detection when waypoint reached
                                                                        LastStuckCheckTime := 0
                                                                        StuckMoveAttempts := 0

                                                                        ; Execute waypoint commands if they exist
                                                                        ExecuteWaypointCommands(CurrentWaypoint)

                                                                        if (SingleWaypointMode) {
                                                                            ; Single waypoint mode - stop when reached
                                                                            IsTraveling := false
                                                                            SetTimer, TravelLoop, Off
                                                                            ReleaseAllWASDKeys()
                                                                            GuiControl, Enable, StartBtn
                                                                            GuiControl, Disable, StopBtn
                                                                            GuiControl,, RouteStatus, Reached waypoint %CurrentWaypoint%
                                                                            SingleWaypointMode := false
                                                                            return
                                                                        } else {
                                                                            ; Full route mode - continue to next waypoint
                                                                            CurrentWaypoint++
                                                                            NewText := "Reached waypoint " . (CurrentWaypoint-1) . "/" . waypointCount
                                                                            GuiControl,, RouteStatus, %NewText%

                                                                            if (CurrentWaypoint > waypointCount) {
                                                                                CurrentWaypoint := 1
                                                                            }
                                                                        }
                                                                    } else {
                                                                        ; Use the selected movement mode
                                                                        if (MovementMode = "click") {
                                                                            NavigateToCoordinatesClick(waypoint.x, waypoint.y)
                                                                        } else {
                                                                            NavigateToCoordinatesWASD(waypoint.x, waypoint.y)
                                                                        }
                                                                    }
                                                                return

                                                                ExecuteWaypointCommands(waypointNum) {
                                                                    global IsExecutingCommand

                                                                    if (!WaypointCommands.HasKey(waypointNum)) {
                                                                        ; Debug: Show if no command exists for this waypoint
                                                                        ; MsgBox, 0, Debug, No command for waypoint %waypointNum%, 1
                                                                        return
                                                                    }

                                                                    ; Set flag to indicate commands are executing
                                                                    IsExecutingCommand := true

                                                                    commandText := WaypointCommands[waypointNum]
                                                                    ; Debug: Show what command is being executed
                                                                    ; MsgBox, 0, Debug, Executing command for waypoint %waypointNum%: %commandText%, 2

                                                                    ; Check if it's a function call or contains complex AHK code
                                                                    ; Must have () to be considered a function call, not just any word
                                                                    if (RegExMatch(commandText, "^[a-zA-Z_][a-zA-Z0-9_]*\s*\(.*\)\s*$") || InStr(commandText, "`n") || InStr(commandText, "FindText") || InStr(commandText, "if (")) {
                                                                        ; Execute as script block (including function calls)
                                                                        ExecuteScriptBlock(commandText)
                                                                        IsExecutingCommand := false
                                                                        return
                                                                    }

                                                                    ; Parse simple commands separated by |
                                                                    commands := StrSplit(commandText, "|")
                                                                    for index, command in commands {
                                                                        command := Trim(command)
                                                                        if (command = "") {
                                                                            continue
                                                                        }

                                                                        ; Parse command type and parameters
                                                                        commandParts := StrSplit(command, ",", " ")
                                                                        commandType := Trim(commandParts[1])

                                                                        ; Convert to lowercase for case-insensitive matching
                                                                        commandTypeLower := ""
                                                                        StringLower, commandTypeLower, commandType

                                                                        if (commandTypeLower = "sleep") {
                                                                            sleepTime := Trim(commandParts[2])
                                                                            Sleep, %sleepTime%
                                                                        } else if (commandTypeLower = "send") {
                                                                            keys := Trim(commandParts[2])
                                                                            Send, %keys%
                                                                        } else if (commandTypeLower = "controlsend") {
                                                                            ; Format: controlsend, {keys} OR controlsend, {keys}, win2
                                                                            ; Default uses win1 (TargetGameWindow), or specify win2
                                                                            keys := Trim(commandParts[2])
                                                                            targetWin := TargetGameWindow ; Default to win1

                                                                            if (commandParts.Length() >= 3) {
                                                                                winSpec := Trim(commandParts[3])
                                                                                if (winSpec = "win2" && win2) {
                                                                                    targetWin := win2
                                                                                }
                                                                            }

                                                                            if (targetWin) {
                                                                                ControlSend,, %keys%, ahk_id %targetWin%
                                                                            } else {
                                                                                MsgBox, Error: Window not set! Use "Select Win2" button first.
                                                                            }
                                                                        } else if (commandTypeLower = "sendlevel") {
                                                                            level := Trim(commandParts[2])
                                                                            SendLevel %level%
                                                                        } else if (commandTypeLower = "msgbox") {
                                                                            message := Trim(commandParts[2])
                                                                            MsgBox, 0, Waypoint Command, %message%, 2
                                                                        } else if (commandTypeLower = "click") {
                                                                            if (commandParts.Length() >= 3) {
                                                                                clickX := Trim(commandParts[2])
                                                                                clickY := Trim(commandParts[3])

                                                                                ; Use SendMessage for clicking
                                                                                lParam := (clickY << 16) | (clickX & 0xFFFF)
                                                                                SendMessage, 0x0200, 0, %lParam%, , ahk_id %win1% ; WM_MOUSEMOVE
                                                                                Sleep, 20
                                                                                SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                                                                Sleep, 20
                                                                                SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                                                                Sleep, 30
                                                                            }
                                                                        } else if (commandTypeLower = "controlclick") {
                                                                            ; Click at window-relative coordinates in win1
                                                                            ; Format: controlclick,X,Y where X and Y are window coordinates (not screen)
                                                                            if (commandParts.Length() >= 3) {
                                                                                winClickX := Trim(commandParts[2])
                                                                                winClickY := Trim(commandParts[3])

                                                                                if (TargetGameWindow) {
                                                                                    ; Send click messages to the game window at the specified coordinates
                                                                                    ; WM_LBUTTONDOWN = 0x201, WM_LBUTTONUP = 0x202
                                                                                    SendMessage, 0x201, 1, % (winClickY << 16) | (winClickX & 0xFFFF), , ahk_id %TargetGameWindow%
                                                                                    Sleep, 20
                                                                                    SendMessage, 0x202, 0, % (winClickY << 16) | (winClickX & 0xFFFF), , ahk_id %TargetGameWindow%
                                                                                    Sleep, 30
                                                                                } else {
                                                                                    MsgBox, 0, Error, No game window selected!, 2
                                                                                }
                                                                            }
                                                                        } else if (commandTypeLower = "worldclick") {
                                                                            ; Click at in-game world coordinates (not screen coordinates)
                                                                            ; Format: worldclick,X,Y where X and Y are game world coordinates
                                                                            ; OR: worldclick,1 to click at node #1, worldclick,2 for node #2, etc.
                                                                            if (commandParts.MaxIndex() >= 2) {
                                                                                nodeNum := Trim(commandParts[2])
                                                                                clickatnode(nodeNum)
                                                                            } else {

                                                                            }
                                                                        } else if (commandTypeLower = "holyground") {
                                                                            ; Format: holyground,delay,key,node OR holyground,delay,key,node1,node2 OR holyground,delay,key,node1,node2,node3
                                                                            if (commandParts.MaxIndex() >= 4) {
                                                                                delay := Trim(commandParts[2])
                                                                                key := Trim(commandParts[3])
                                                                                nodeNum1 := Trim(commandParts[4])

                                                                                ; Check if we have 1, 2, or 3 nodes
                                                                                if (commandParts.MaxIndex() >= 6) {
                                                                                    ; 3 nodes provided
                                                                                    nodeNum2 := Trim(commandParts[5])
                                                                                    nodeNum3 := Trim(commandParts[6])
                                                                                    holyground(delay, key, nodeNum1, nodeNum2, nodeNum3)
                                                                                } else if (commandParts.MaxIndex() >= 5) {
                                                                                    ; 2 nodes provided
                                                                                    nodeNum2 := Trim(commandParts[5])
                                                                                    holyground(delay, key, nodeNum1, nodeNum2)
                                                                                } else {
                                                                                    ; Only 1 node provided
                                                                                    holyground(delay, key, nodeNum1)
                                                                                }
                                                                            } else {
                                                                                MsgBox, 0, Error, holyground requires at least 3 parameters: delay`,key`,node, 3
                                                                            }
                                                                        } else if (commandTypeLower = "winactivate") {
                                                                            WinActivate, ahk_id %TargetGameWindow%
                                                                        } else if (commandTypeLower = "coords") {
                                                                            ; Get and display current coordinates
                                                                            GetCurrentCoordinates(cx, cy)
                                                                            MsgBox, 0, Current Position, X: %cx% Y: %cy%, 2
                                                                        } else if (commandTypeLower = "tooltip") {
                                                                            message := Trim(commandParts[2])
                                                                            ToolTip, %message%
                                                                            SetTimer, ClearTooltip, -3000
                                                                        } else if (commandTypeLower = "trycastheal") {
                                                                            ; Try to cast the highest priority heal skill available
                                                                            ; Usage: trycastheal
                                                                            TryCastHealingSkill()()
                                                                        } else if (commandTypeLower = "trycastdps") {
                                                                            ; Try to cast a DPS skill (respects 1-second global cooldown)
                                                                            ; Usage: trycastdps
                                                                            TryCastDPSSkills()()
                                                                        } else if (commandTypeLower = "loopcastuntilmobdead") {
                                                                            ; Loop casting heal and DPS until mob health bar is not found
                                                                            ; Usage: loopcastuntilmobdead
                                                                            LoopCastUntilMobDead()
                                                                        } else if (commandTypeLower = "checkmobhealth") {
                                                                            ; Check if mob health bar exists, skip remaining commands if not found
                                                                            ; Usage: checkmobhealth
                                                                            if (!CheckMobHealth()) {
                                                                                ; Mob health not found, stop processing this waypoint's commands
                                                                                return
                                                                            }
                                                                        } else if (commandTypeLower = "reenterbd5") {
                                                                            ; BD5 dungeon re-entry sequence
                                                                            ; Usage: reenterbd5
                                                                            ReEnterBD5()
                                                                        } else if (commandTypeLower = "loopclickuntilpatternmissing") {
                                                                            ; Loop click a node until a FindText pattern is no longer found
                                                                            ; If pattern still found after maxClicks, move back N waypoints and retry
                                                                            ; Usage: loopclickuntilpatternmissing,nodeNum,patternName,maxClicks,backSteps
                                                                            ; Example: loopclickuntilpatternmissing,10,bd5quest,2,1
                                                                            ; OR with inline pattern: loopclickuntilpatternmissing,10,|<>pattern...,2,1
                                                                            if (commandParts.Length() >= 5) {
                                                                                nodeNum := Trim(commandParts[2])
                                                                                patternNameOrText := Trim(commandParts[3])
                                                                                maxClicks := Trim(commandParts[4])
                                                                                backSteps := Trim(commandParts[5])
                                                                                LoopClickUntilPatternMissing(nodeNum, patternNameOrText, maxClicks, backSteps)
                                                                            } else {
                                                                                MsgBox, 0, Error, loopclickuntilpatternmissing requires 4 parameters: nodeNum,patternName,maxClicks,backSteps, 3
                                                                            }
                                                                        } else if (commandTypeLower = "loopclickuntilpatternfound") {
                                                                            ; New command: Loop clicking nodes until pattern appears, then control-click it
                                                                            ; Usage: loopclickuntilpatternfound,nodeNum1,nodeNum2,patternName
                                                                            ; Example: loopclickuntilpatternfound,28,28,entrance5
                                                                            if (commandParts.MaxIndex() >= 5) {
                                                                                nodeNum1 := Trim(commandParts[2])
                                                                                nodeNum2 := Trim(commandParts[3])
                                                                                maxclicks := Trim(commandParts[4])
                                                                                patternName := Trim(commandParts[5])
                                                                                LoopClickUntilPatternFound(nodeNum1, nodeNum2, maxclicks, patternName)
                                                                            } else {
                                                                                MsgBox, 0, Error, loopclickuntilpatternfound requires 4 parameters: nodeNum1,nodeNum2,maxclickcount,patternName, 3
                                                                            }
                                                                        } else if (commandTypeLower = "loopsearchuntilpatternfound") {
                                                                            ; New command: Loop clicking nodes until pattern appears, then control-click it
                                                                            ; Usage: loopsearchuntilpatternfound,nodeNum1,nodeNum2,patternName
                                                                            ; Example: loopsearchuntilpatternfound,28,28,entrance5
                                                                            if (commandParts.MaxIndex() >= 3) {
                                                                                tries := Trim(commandParts[2])
                                                                                patternName := Trim(commandParts[3])
                                                                                LoopSearchUntilPatternFound(tries, patternName)
                                                                            } else {
                                                                                MsgBox, 0, Error, loopsearchuntilpatternfound requires 3 parameters: tries,patternName, 3
                                                                            }
                                                                        } else if (commandTypeLower = "clickpattern") {
                                                                            ; New command: Find and click a pattern directly
                                                                            ; Usage: clickpattern,patternName
                                                                            ; Example: clickpattern,entrance5
                                                                            if (commandParts.MaxIndex() >= 2) {
                                                                                patternName := Trim(commandParts[2])
                                                                                ClickPattern(patternName)
                                                                            } else {
                                                                                MsgBox, 0, Error, clickpattern requires 1 parameter: patternName, 3
                                                                            }
                                                                        } else if (commandTypeLower = "controlclickpattern") {
                                                                            ; New command: Find and control-click a pattern directly
                                                                            ; Usage: controlclickpattern,patternName  
                                                                            ; Example: controlclickpattern,entrance5
                                                                            if (commandParts.MaxIndex() >= 2) {
                                                                                patternName := Trim(commandParts[2])
                                                                                ClickPattern(patternName, true)
                                                                            } else {
                                                                                MsgBox, 0, Error, controlclickpattern requires 1 parameter: patternName, 3
                                                                            }
                                                                        } else if (commandTypeLower = "farmuntilpattern") {
                                                                            ; Loop tab targeting and kill mobs until pattern appears
                                                                            ; Usage: farmuntilpattern,patternName
                                                                            ; Example: farmuntilpattern,entrance5
                                                                            if (commandParts.MaxIndex() >= 2) {
                                                                                stopPattern := Trim(commandParts[2])
                                                                                FarmUntilPattern(stopPattern)
                                                                            } else {
                                                                                MsgBox, 0, Error, farmuntilpattern requires 1 parameter: patternName, 3
                                                                            }
                                                                        } else if (commandTypeLower = "sendhotkey") {
                                                                            ; Send a hotkey to trigger hotkeys in other scripts
                                                                            ; Usage: sendhotkey,key
                                                                            ; Example: sendhotkey,F1
                                                                            if (commandParts.MaxIndex() >= 2) {
                                                                                keyToSend := Trim(commandParts[2])
                                                                                SendLevel, 1
                                                                                Send, {%keyToSend%}
                                                                                SendLevel, 0
                                                                            } else {
                                                                                MsgBox, 0, Error, sendhotkey requires 1 parameter: key, 3
                                                                            }
                                                                        } else if (commandTypeLower = "shiftclick") {
                                                                            ; Click at a node while holding Shift
                                                                            ; Usage: shiftclick,nodeNum
                                                                            ; Example: shiftclick,10
                                                                            if (commandParts.MaxIndex() >= 2) {
                                                                                nodeNum := Trim(commandParts[2])
                                                                                ShiftClickAtNode(nodeNum)
                                                                            } else {
                                                                                MsgBox, 0, Error, shiftclick requires 1 parameter: nodeNum, 3
                                                                            }
                                                                        } else if (commandTypeLower = "ifpatternfoundgoto") {
                                                                            ; Check if pattern is found, if so jump to a specific waypoint
                                                                            ; Usage: ifpatternfoundgoto,patternName,waypointNumber
                                                                            ; Example: ifpatternfoundgoto,entrance5,10
                                                                            if (commandParts.MaxIndex() >= 3) {
                                                                                patternName := Trim(commandParts[2])
                                                                                targetWaypoint := Trim(commandParts[3])

                                                                                ; Check if pattern is found
                                                                                if (CheckPatternExists(patternName)) {
                                                                                    ; Pattern found! Jump to the specified waypoint
                                                                                    CurrentWaypoint := targetWaypoint
                                                                                    ToolTip, Pattern '%patternName%' found! Jumping to waypoint %targetWaypoint%, 0, 0
                                                                                    SetTimer, ClearTooltip, -2000
                                                                                }
                                                                            } else {
                                                                                MsgBox, 0, Error, ifpatternfoundgoto requires 2 parameters: patternName`,waypointNumber, 3
                                                                            }
                                                                        } else if (commandTypeLower = "enablecritical") {
                                                                            ; Enable Critical mode to block all timers
                                                                            ; Usage: enablecritical
                                                                            EnableCriticalMode()
                                                                        } else if (commandTypeLower = "disablecritical") {
                                                                            ; Disable Critical mode to allow timers
                                                                            ; Usage: disablecritical
                                                                            DisableCriticalMode()
                                                                        } else if (commandtypelower = "gotowaypoint") {
                                                                            if (commandParts.Length() >= 2) {
                                                                                targetWaypoint := Trim(commandParts[2])
                                                                                GoToWaypoint(targetWaypoint)
                                                                            }

                                                                        } else if (commandTypeLower = "CheckAndExecuteTimerFlags()"){
                                                                            CheckAndExecuteTimerFlags()

                                                                        } else if (commandTypeLower = "netskill") {
                                                                            ; Send a key press to specific windows via AHKsock network
                                                                            ; Usage: netskill,key,target
                                                                            ; Examples: 
                                                                            ;   netskill,1,win1        - Send key "1" to win1 only
                                                                            ;   netskill,3,win1 win2   - Send key "3" to win1 and win2
                                                                            ;   netskill,F5,all        - Send F5 to all connected clients
                                                                            if (commandParts.MaxIndex() >= 3) {
                                                                                keyToSend := Trim(commandParts[2])
                                                                                targetSpec := Trim(commandParts[3])

                                                                                ; Check if target is "all"
                                                                                if (targetSpec = "all") {
                                                                                    ; Send to all connected clients
                                                                                    SendCommandToAll("PRESS:" . keyToSend)
                                                                                } else {
                                                                                    ; Parse space-separated window list (e.g., "win1 win2 win4")
                                                                                    targets := StrSplit(targetSpec, " ")
                                                                                    for idx, winTarget in targets {
                                                                                        winTarget := Trim(winTarget)
                                                                                        if (winTarget != "") {
                                                                                            ; Send CTRLSEND command to specific window
                                                                                            SendCommandToAll("CTRLSEND:" . winTarget . ":|:" . keyToSend)
                                                                                        }
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                MsgBox, 0, Error, netskill requires 2 parameters: key`,target`n`nExamples:`nnetskill`,1`,win1`nnetskill`,3`,win1 win2`nnetskill`,F5`,all, 3
                                                                            }
                                                                        } else if (commandTypeLower = "netcombat") {
                                                                            ; Send combat command to specific windows via AHKsock network
                                                                            ; Usage: netcombat,duration,target
                                                                            ; Examples: 
                                                                            ;   netcombat,10,win1         - Combat for 10 seconds on win1 only
                                                                            ;   netcombat,15,win1 win2    - Combat for 15 seconds on win1 and win2
                                                                            ;   netcombat,20,all          - Combat for 20 seconds on all connected clients
                                                                            if (commandParts.MaxIndex() >= 3) {
                                                                                durationSecs := Trim(commandParts[2])
                                                                                targetSpec := Trim(commandParts[3])

                                                                                ; Check if target is "all"
                                                                                if (targetSpec = "all") {
                                                                                    ; Send combat command to all connected clients
                                                                                    SendCommandToAll("CALL:PerformCombat(" . durationSecs . ")")
                                                                                } else {
                                                                                    ; Parse space-separated window list (e.g., "win1 win2 win4")
                                                                                    targets := StrSplit(targetSpec, " ")
                                                                                    for idx, winTarget in targets {
                                                                                        winTarget := Trim(winTarget)
                                                                                        if (winTarget != "") {
                                                                                            ; Send combat command to specific window
                                                                                            ; Note: For targeted commands, we use CALL which all clients receive,
                                                                                            ; but you may want to implement window-specific filtering
                                                                                            SendCommandToAll("CALL:PerformCombat(" . durationSecs . ")")
                                                                                        }
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                MsgBox, 0, Error, netcombat requires 2 parameters: duration`,target`n`nExamples:`nnetcombat`,10`,win1`nnetcombat`,15`,win1 win2`nnetcombat`,20`,all, 3
                                                                            }
                                                                        } else if (commandTypeLower = "netnav") {
                                                                            ; Send navigation command to specific windows via AHKsock network
                                                                            ; Usage: netnav,target,destination
                                                                            ; Examples: 
                                                                            ;   netnav,all,WP 13          - All clients go to waypoint 13
                                                                            ;   netnav,win1 win2,NODE 3   - win1 and win2 click at node 3
                                                                            ;   netnav,win1,WP 5          - win1 goes to waypoint 5
                                                                            if (commandParts.MaxIndex() >= 3) {
                                                                                targetSpec := Trim(commandParts[2])
                                                                                destination := Trim(commandParts[3])

                                                                                ; Parse destination type (WP or NODE)
                                                                                navCommand := ""
                                                                                if (RegExMatch(destination, "i)^WP\s+(\d+)$", match)) {
                                                                                    ; Waypoint navigation
                                                                                    waypointNum := match1
                                                                                    navCommand := "CALL:GoToWaypoint(" . waypointNum . ")"
                                                                                } else if (RegExMatch(destination, "i)^NODE\s+(\d+)$", match)) {
                                                                                    ; Node click navigation
                                                                                    nodeNum := match1
                                                                                    navCommand := "CALL:clickatnode(" . nodeNum . ")"
                                                                                } else {
                                                                                    MsgBox, 0, Error, Invalid destination format. Use 'WP #' or 'NODE #'`n`nExamples:`nnetnav`,all`,WP 13`nnetnav`,win1 win2`,NODE 3, 3
                                                                                    return
                                                                                }

                                                                                ; Check if target is "all"
                                                                                if (targetSpec = "all") {
                                                                                    ; Send navigation command to all connected clients
                                                                                    SendCommandToAll(navCommand)
                                                                                } else {
                                                                                    ; Parse space-separated window list (e.g., "win1 win2 win4")
                                                                                    targets := StrSplit(targetSpec, " ")
                                                                                    for idx, winTarget in targets {
                                                                                        winTarget := Trim(winTarget)
                                                                                        if (winTarget != "") {
                                                                                            ; Send navigation command
                                                                                            SendCommandToAll(navCommand)
                                                                                        }
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                MsgBox, 0, Error, netnav requires 2 parameters: target`,destination`n`nExamples:`nnetnav`,all`,WP 13`nnetnav`,win1 win2`,NODE 3`nnetnav`,win1`,WP 5, 3
                                                                            }
                                                                        } else if (commandTypeLower = "nethealing") {
                                                                            ; Control healing on specific windows via AHKsock network
                                                                            ; Usage: nethealing,target,action
                                                                            ; Examples: 
                                                                            ;   nethealing,all,start         - Start healing on all clients
                                                                            ;   nethealing,win1 win2,stop    - Stop healing on win1 and win2
                                                                            ;   nethealing,win1,start        - Start healing on win1 only
                                                                            if (commandParts.MaxIndex() >= 3) {
                                                                                targetSpec := Trim(commandParts[2])
                                                                                action := Trim(commandParts[3])

                                                                                ; Validate action
                                                                                actionLower := ""
                                                                                StringLower, actionLower, action

                                                                                if (actionLower != "start" && actionLower != "stop") {
                                                                                    MsgBox, 0, Error, Invalid action. Use 'start' or 'stop'`n`nExamples:`nnethealing`,all`,start`nnethealing`,win1 win2`,stop, 3
                                                                                    return
                                                                                }

                                                                                ; Create the healing command
                                                                                if (actionLower = "start") {
                                                                                    healCommand := "CALL:StartHealer"
                                                                                } else {
                                                                                    healCommand := "CALL:StopHealer"
                                                                                }

                                                                                ; Check if target is "all"
                                                                                if (targetSpec = "all") {
                                                                                    ; Send healing command to all connected clients
                                                                                    SendCommandToAll(healCommand)
                                                                                } else {
                                                                                    ; Parse space-separated window list (e.g., "win1 win2 win4")
                                                                                    targets := StrSplit(targetSpec, " ")
                                                                                    for idx, winTarget in targets {
                                                                                        winTarget := Trim(winTarget)
                                                                                        if (winTarget != "") {
                                                                                            ; Send healing command
                                                                                            SendCommandToAll(healCommand)
                                                                                        }
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                MsgBox, 0, Error, nethealing requires 2 parameters: target`,action`n`nExamples:`nnethealing`,all`,start`nnethealing`,win1 win2`,stop`nnethealing`,win1`,start, 3
                                                                            }
                                                                        } else if (commandTypeLower = "netbuffs") {
                                                                            ; Activate all buff timers including DT and Gnoll via AHKsock network
                                                                            ; Usage: netbuffs,target
                                                                            ; Examples:
                                                                            ;   netbuffs,all          - Activate all buffs on all clients
                                                                            ;   netbuffs,win1 win2    - Activate all buffs on win1 and win2 only
                                                                            if (commandParts.MaxIndex() >= 2) {
                                                                                targetSpec := Trim(commandParts[2])

                                                                                ; Create the buff activation command (calls StartAllTimers with auto-yes to DT/Gnoll)
                                                                                buffCommand := "CALL:StartAllBuffTimers"

                                                                                ; Check if target is "all"
                                                                                if (targetSpec = "all") {
                                                                                    ; Send buff command to all connected clients
                                                                                    SendCommandToAll(buffCommand)
                                                                                } else {
                                                                                    ; Parse space-separated window list (e.g., "win1 win2 win4")
                                                                                    targets := StrSplit(targetSpec, " ")
                                                                                    for idx, winTarget in targets {
                                                                                        winTarget := Trim(winTarget)
                                                                                        if (winTarget != "") {
                                                                                            ; Send buff command
                                                                                            SendCommandToAll(buffCommand)
                                                                                        }
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                MsgBox, 0, Error, netbuffs requires 1 parameter: target`n`nExamples:`nnetbuffs`,all`nnetbuffs`,win1 win2`nnetbuffs`,win1, 3
                                                                            }
                                                                        } else {
                                                                            ; Unknown command - show debug info
                                                                            MsgBox, 0, Debug, Unknown command: %commandType%`nFull command: %command%, 3
                                                                        }
                                                                    }

                                                                    ; Reset flag when commands are done executing
                                                                    IsExecutingCommand := false
                                                                }

                                                                ExecuteScriptBlock(scriptCode) {
                                                                    ; Get current coordinates for use in scripts
                                                                    GetCurrentCoordinates(currentX, currentY)

                                                                    ; Make variables accessible
                                                                    global win1, win2, Text, TargetGameWindow

                                                                    ; Execute the script code directly
                                                                    ; Note: This is a simple approach - complex scripts may need eval functionality

                                                                    ; For simple command execution, you could parse and execute commands
                                                                    ; For complex scripts, you might need a different approach

                                                                    ; Simple example: Check if it's a call to CheckAndExecuteTimerFlags
                                                                    if InStr(scriptCode, "CheckAndExecuteTimerFlags()") {
                                                                        CheckAndExecuteTimerFlags()
                                                                        return
                                                                    }

                                                                    ; For other scripts, you might need to use #Include or other methods
                                                                    ; depending on what types of scripts you're running
                                                                }

                                                                NavigateToCoordinatesClick(targetX, targetY) {
                                                                    static lastX := ""
                                                                    static lastY := ""
                                                                    static stuckCount := 0

                                                                    GetCurrentCoordinates(coords1X, coords1Y)
                                                                    Sleep, 10
                                                                    GetCurrentCoordinates(coords2X, coords2Y)
                                                                    Sleep, 10
                                                                    GetCurrentCoordinates(coords3X, coords3Y)

                                                                    if (coords1X != coords2X || coords1Y != coords2Y || coords2X != coords3X || coords2Y != coords3Y) {
                                                                        Sleep, 50
                                                                        return
                                                                    }

                                                                    currentX := coords3X
                                                                    currentY := coords3Y

                                                                    ;Optional: Offset in front of target, rotated by camera
                                                                    ; offset := 280
                                                                    ; offsetX := offset * Cos(CameraAngle)
                                                                    ; offsetY := offset * Sin(CameraAngle)
                                                                    ; targetX := targetX + offsetX
                                                                    ; targetY := targetY + offsetY

                                                                    if (Abs(currentX - targetX) <= DistanceToleranceX && Abs(currentY - targetY) <= DistanceToleranceY) {
                                                                        return
                                                                    }
                                                                    if (currentX = lastX && currentY = lastY) { 
                                                                        stuckCount++ 
                                                                    } else { 
                                                                        stuckCount := 0 
                                                                    } 
                                                                    lastX := currentX 
                                                                    lastY := currentY

                                                                    baseClickX := 516 
                                                                    baseClickY := 410

                                                                    deltaX := targetX - currentX 
                                                                    deltaY := targetY - currentY

                                                                    ; Calculate distance to target (in game units)  
                                                                    distance := Sqrt(deltaX*deltaX + deltaY*deltaY)

                                                                    ; Calibrated pixel conversion - UPDATED WITH NAVMESH CALIBRATION
                                                                    ; X-axis: calibrated to 1.21 (was 0.55)
                                                                    ; Y-axis: calibrated base to 0.95 (was 1.05)
                                                                    ; Distance scaling: X=0.94, Y=1.19 for distance-dependent correction

                                                                    ; Base X-axis scaling (calibrated)
                                                                    pixelsPerGameUnitX := 1.21

                                                                    ; Y-axis: piecewise linear based on camera radius (calibrated base)
                                                                    if (CameraRadius <= 900) {
                                                                        pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                                    } else if (CameraRadius <= 1000) {
                                                                        ; Interpolate between R900(0.95) and R1000(1.13)
                                                                        t := (CameraRadius - 900) / 100
                                                                        pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                                    } else if (CameraRadius <= 1500) {
                                                                        ; Interpolate between R1000(1.13) and R1500(0.75)
                                                                        t := (CameraRadius - 1000) / 500
                                                                        pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                                    } else {
                                                                        ; Extrapolate from R1500(0.75) and R2000(0.32)
                                                                        t := (CameraRadius - 1500) / 500
                                                                        pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                                    }

                                                                    ; Scale deltas with base scaling
                                                                    scaledX := -deltaX * pixelsPerGameUnitX 
                                                                    scaledY := -deltaY * pixelsPerGameUnitY

                                                                    ; Apply distance-based correction (calibrated: X=0.94, Y=1.19)
                                                                    scaledX := scaledX * 0.94
                                                                    scaledY := scaledY * 1.19

                                                                    cos_angle := Cos(-CameraAngle) 
                                                                    sin_angle := Sin(-CameraAngle)

                                                                    rotatedX := scaledX * cos_angle - scaledY * sin_angle 
                                                                    rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                                    currentMaxDistance := MaxClickDistance 
                                                                    if (distance < 20) { 
                                                                        currentMaxDistance := MaxClickDistance * 0.3 
                                                                    } else if (distance < 50) { 
                                                                        currentMaxDistance := MaxClickDistance * 0.6 
                                                                    }

                                                                    pixelDistance := Sqrt(rotatedX*rotatedX + rotatedY*rotatedY) 
                                                                    if (pixelDistance > currentMaxDistance) { 
                                                                        scale := currentMaxDistance / pixelDistance 
                                                                        rotatedX *= scale 
                                                                        rotatedY *= scale 
                                                                    }

                                                                    minClickThreshold := 3 
                                                                    if (Abs(rotatedX) < minClickThreshold && Abs(rotatedY) < minClickThreshold && distance > DistanceToleranceX) { 
                                                                        if (Abs(rotatedX) > 0) { 
                                                                            rotatedX := (rotatedX > 0) ? minClickThreshold : -minClickThreshold 
                                                                        } 
                                                                        if (Abs(rotatedY) > 0) { 
                                                                            rotatedY := (rotatedY > 0) ? minClickThreshold : -minClickThreshold 
                                                                        } 
                                                                    }

                                                                    if (stuckCount > 3) { 
                                                                        Random, randX, -20, 20 
                                                                        Random, randY, -20, 20 
                                                                        rotatedX += randX 
                                                                        rotatedY += randY 
                                                                        stuckCount := 0 
                                                                    }

                                                                    clickX := baseClickX + rotatedX 
                                                                    clickY := baseClickY - rotatedY ; If Y increases downward on screen; flip sign if needed

                                                                    sendmessage, 0x201, 1, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONDOWN  
                                                                    Sleep, 20
                                                                    sendmessage, 0x202, 0, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONUP  
                                                                    sleep, 30

                                                                }

                                                                ClickAtWorldCoordinates(targetX, targetY) {
                                                                    ; Click at in-game world coordinates without moving the character
                                                                    ; Uses EXACT same conversion as NavigateToCoordinatesClick for consistency

                                                                    if (!TargetGameWindow) {
                                                                        return
                                                                    }

                                                                    ; Get current position
                                                                    GetCurrentCoordinates(currentX, currentY)
                                                                    if (currentX = "" || currentY = "") {
                                                                        return
                                                                    }

                                                                    ; Calculate delta from current position to target
                                                                    deltaX := targetX - currentX
                                                                    deltaY := targetY - currentY

                                                                    ; Use EXACT same pixel conversion as NavigateToCoordinatesClick
                                                                    pixelsPerGameUnitX := 1.21

                                                                    ; Y-axis: piecewise linear based on camera radius (SAME as NavigateToCoordinatesClick)
                                                                    if (CameraRadius <= 900) {
                                                                        pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                                    } else if (CameraRadius <= 1000) {
                                                                        t := (CameraRadius - 900) / 100
                                                                        pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                                    } else if (CameraRadius <= 1500) {
                                                                        t := (CameraRadius - 1000) / 500
                                                                        pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                                    } else {
                                                                        t := (CameraRadius - 1500) / 500
                                                                        pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                                    }

                                                                    ; Scale the deltas - SAME as NavigateToCoordinatesClick
                                                                    scaledX := -deltaX * pixelsPerGameUnitX
                                                                    scaledY := -deltaY * pixelsPerGameUnitY

                                                                    ; Apply distance correction - SAME as NavigateToCoordinatesClick
                                                                    scaledX := scaledX * 0.94
                                                                    scaledY := scaledY * 1.19

                                                                    ; Apply camera rotation - SAME as NavigateToCoordinatesClick
                                                                    cos_angle := Cos(-CameraAngle)
                                                                    sin_angle := Sin(-CameraAngle)

                                                                    rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                                                    rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                                    ; Use the same base click position as NavigateToCoordinatesClick
                                                                    baseClickX := 516
                                                                    baseClickY := 410

                                                                    ; Calculate final screen coordinates with offset correction
                                                                    clickX := baseClickX + Round(rotatedX) - 7 ; 3 pixels right from -10 = -7
                                                                    clickY := baseClickY - Round(rotatedY) - 29 ; 4 pixels up from -25 = -29
                                                                    sendmessage, 0x200, 0, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_MOUSEMOVE
                                                                    Sleep, 70
                                                                    Sleep, 70 ; Send click messages to the game window without moving the mouse
                                                                    sendmessage, 0x201, 1, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONDOWN
                                                                    Sleep, 20
                                                                    sendmessage, 0x202, 0, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONUP
                                                                    Sleep, 30
                                                                }

                                                                TryUnstuck() {
                                                                    global CurrentWaypoint, Waypoints, StuckMoveAttempts

                                                                    ToolTip, Stuck detected! Attempting to unstuck (attempt %StuckMoveAttempts%/3)..., 0, 0

                                                                    ; Get current position
                                                                    GetCurrentCoordinates(currentX, currentY)
                                                                    if (currentX = "" || currentY = "") {
                                                                        return false
                                                                    }

                                                                    ; Generate random direction (0-360 degrees)
                                                                    Random, randomAngle, 0, 360
                                                                    randomAngleRad := randomAngle * 3.14159265 / 180

                                                                    ; Move 50 game units in random direction
                                                                    offsetX := 50 * Cos(randomAngleRad)
                                                                    offsetY := 50 * Sin(randomAngleRad)

                                                                    unstuckX := currentX + offsetX
                                                                    unstuckY := currentY + offsetY

                                                                    ; Click to move in that direction
                                                                    ToolTip, Attempting random move to unstuck (angle: %randomAngle% degrees)..., 0, 0
                                                                    ClickAtWorldCoordinates(unstuckX, unstuckY)
                                                                    Sleep, 1000

                                                                    ; Check if we moved
                                                                    GetCurrentCoordinates(newX, newY)
                                                                    if (newX = "" || newY = "") {
                                                                        return false
                                                                    }

                                                                    distance := Sqrt((newX - currentX)**2 + (newY - currentY)**2)

                                                                    if (distance > 10) {
                                                                        ; Successfully moved
                                                                        ToolTip, Unstuck successful! Moved %distance% units., 0, 0
                                                                        SetTimer, ClearTooltip, -2000
                                                                        StuckMoveAttempts := 0
                                                                        return true
                                                                    }

                                                                    ; Still stuck
                                                                    StuckMoveAttempts++

                                                                    if (StuckMoveAttempts >= 3) {
                                                                        ; Failed 3 times, try next waypoint
                                                                        ToolTip, Failed to unstuck after 3 attempts. Trying next waypoint..., 0, 0
                                                                        SetTimer, ClearTooltip, -2000
                                                                        StuckMoveAttempts := 0
                                                                        CurrentWaypoint++

                                                                        ; If next waypoint also fails, go to previous
                                                                        ; This will be handled by the caller
                                                                        return false
                                                                    }

                                                                return false
                                                            }

                                                            NavigateToCoordinatesWASD(targetX, targetY) {
                                                                GetCurrentCoordinates(currentX, currentY)

                                                                if (currentX = "" || currentY = "") {
                                                                return
                                                            }

                                                            deltaX := targetX - currentX
                                                            deltaY := targetY - currentY

                                                            ; Determine which keys should be pressed
                                                            newWASDState := {w: false, a: false, s: false, d: false}

                                                            ; Use the EXACT SAME logic as click movement
                                                            cos_angle := Cos(-CameraAngle)
                                                            sin_angle := Sin(-CameraAngle)

                                                            ; IMPORTANT: Negate deltas BEFORE rotation, just like click movement does!
                                                            ; Click movement: scaledX := -deltaX * pixels, scaledY := -deltaY * pixels
                                                            ; For WASD we don't scale, but we still need to negate
                                                            negDeltaX := -deltaX
                                                            negDeltaY := -deltaY

                                                            ; Apply rotation with negated deltas
                                                            rotatedX := negDeltaX * cos_angle - negDeltaY * sin_angle
                                                            rotatedY := negDeltaX * sin_angle + negDeltaY * cos_angle

                                                            threshold := 5

                                                            ; Now the rotated values directly tell us which keys to press
                                                            ; Positive rotatedY means move forward (W), negative means backward (S)
                                                            ; Positive rotatedX means move right (D), negative means left (A)
                                                            if (Abs(rotatedY) > threshold) {
                                                                if (rotatedY > 0) {
                                                                    newWASDState.w := true ; Move forward/up
                                                                } else {
                                                                    newWASDState.s := true ; Move backward/down
                                                                }
                                                            }

                                                            if (Abs(rotatedX) > threshold) {
                                                                if (rotatedX > 0) {
                                                                    newWASDState.d := true ; Move right
                                                                } else {
                                                                    newWASDState.a := true ; Move left
                                                                }
                                                            }

                                                            ; Update key states
                                                            UpdateWASDKeys(newWASDState)
                                                        }

                                                        UpdateWASDKeys(newState) {
                                                            ; Release keys that should no longer be pressed
                                                            for key, currentlyPressed in WASDKeys {
                                                                if (currentlyPressed && !newState[key]) {
                                                                    Send, {%key% up}
                                                                    WASDKeys[key] := false
                                                                }
                                                            }

                                                            ; Press keys that should be pressed
                                                            for key, shouldPress in newState {
                                                                if (shouldPress && !WASDKeys[key]) {
                                                                    Send, {%key% down}
                                                                    WASDKeys[key] := true
                                                                }
                                                            }
                                                        }

                                                        ReleaseAllWASDKeys() {
                                                            for key, isPressed in WASDKeys {
                                                                if (isPressed) {
                                                                    Send, {%key% up}
                                                                    WASDKeys[key] := false
                                                                }
                                                            }
                                                        }

                                                        ReloadScript() {
                                                            ReleaseAllWASDKeys() ; Make sure to release keys before reload
                                                            Reload
                                                        }

                                                        CopyCoords:
                                                            if (TargetGameWindow) {
                                                                GetCurrentCoordinates(coordX, coordY)
                                                                if (coordX != "" && coordY != "") {
                                                                    Clipboard := coordX " " coordY
                                                                    ToolTip, Coordinates copied: %coordX% %coordY%
                                                                    SetTimer, RemoveCoordsToolTip, 2000
                                                                } else {
                                                                    ToolTip, Unable to read coordinates
                                                                    SetTimer, RemoveCoordsToolTip, 2000
                                                                }
                                                            } else {
                                                                MsgBox, Please select a game window first!
                                                            }
                                                        Return

                                                        RemoveCoordsToolTip:
                                                            ToolTip
                                                            SetTimer, RemoveCoordsToolTip, Off
                                                        Return

                                                        CheckPreviousSettings() {
                                                            ; Check for saved window settings
                                                            IniRead, savedPID, pathingsettings.ini, Settings, WindowPID, ERROR
                                                            IniRead, savedNavPID, navpathingsettings.ini, Settings, WindowPID, ERROR
                                                            IniRead, savedWin2PID, pathingsettings.ini, Settings, Win2PID, ERROR

                                                            ; Check for saved camera files
                                                            IniRead, savedNavCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
                                                            IniRead, savedMainCameraFile, pathingsettings.ini, Settings, CameraFile, ERROR

                                                            ; Determine the best saved window (prefer navigation, then main)
                                                            bestPID := ""
                                                            bestWinID := ""
                                                            bestTitle := ""

                                                            if (savedNavPID != "ERROR") {
                                                                WinGet, winID, ID, ahk_pid %savedNavPID%
                                                                if (winID) {
                                                                    bestPID := savedNavPID
                                                                    bestWinID := winID
                                                                    WinGetTitle, bestTitle, ahk_id %winID%
                                                                }
                                                            }

                                                            if (bestWinID = "" && savedPID != "ERROR") {
                                                                WinGet, winID, ID, ahk_pid %savedPID%
                                                                if (winID) {
                                                                    bestPID := savedPID
                                                                    bestWinID := winID
                                                                    WinGetTitle, bestTitle, ahk_id %winID%
                                                                }
                                                            }

                                                            ; Determine the best camera file (prefer navigation, then main)
                                                            bestCameraFile := ""
                                                            cameraSource := ""

                                                            if (savedNavCameraFile != "ERROR" && FileExist(savedNavCameraFile)) {
                                                                bestCameraFile := savedNavCameraFile
                                                                cameraSource := "Navigation"
                                                            }
                                                            else if (savedMainCameraFile != "ERROR" && FileExist(savedMainCameraFile)) {
                                                                bestCameraFile := savedMainCameraFile
                                                                cameraSource := "Main"
                                                            }

                                                            ; If we have either window or camera file, auto-use previous settings (no prompt)
                                                            if (bestWinID != "" || bestCameraFile != "") {
                                                                ; Auto-use all previous settings
                                                                if (bestWinID != "") {
                                                                    TargetGameWindow := bestWinID
                                                                    TargetGamePID := bestPID
                                                                    win1 := bestWinID
                                                                    NavTargetGameWindow := bestWinID
                                                                    NavTargetGamePID := bestPID
                                                                    FindText().BindWindow(bestWinID)
                                                                }

                                                                if (bestCameraFile != "") {
                                                                    LoadSavedCameraFile(bestCameraFile)
                                                                }

                                                                ; Load win2 if it was saved
                                                                if (savedWin2PID != "ERROR") {
                                                                    WinGet, win2ID, ID, ahk_pid %savedWin2PID%
                                                                    if (win2ID) {
                                                                        win2 := win2ID
                                                                        win2PID := savedWin2PID
                                                                    }
                                                                }
                                                            }
                                                            ; If no previous settings found, continue with normal startup
                                                        }

                                                        RemoveWindowPosTooltip:
                                                            ToolTip
                                                        return

                                                        NewPath() {
                                                            InputBox, pathName, New Path, Enter name for new path:,, 300, 130
                                                            if (ErrorLevel || pathName = "") {
                                                                return
                                                            }

                                                            newFileName := pathName . ".ini"
                                                            IniWrite, 0, %newFileName%, Waypoints, Count
                                                            SelectedRouteFile := newFileName
                                                            Waypoints := []
                                                            WaypointCommands := {} ; Clear commands for new path
                                                            GuiControl,, RouteStatus, Route: %newFileName% (0 waypoints)
                                                            ; Enable the Commands button now that a route is selected
                                                            GuiControl, Enable, CommandsButton
                                                            ; Disable waypoint navigation buttons until waypoints are added
                                                            GuiControl, Disable, PrevWaypointBtn
                                                            GuiControl, Disable, NextWaypointBtn
                                                            GuiControl, Disable, GotoBtn
                                                            MsgBox, New path created: %newFileName%
                                                        }

                                                        SaveRadius() {
                                                            if (!navCameraFile) {
                                                                MsgBox, 0, Error, No camera file loaded!
                                                                return
                                                            }

                                                            ; Read the value directly from the control instead of using Gui Submit
                                                            GuiControlGet, newRadius,, RadiusEdit

                                                            ; Debug: Show what was read
                                                            ;MsgBox, Debug: newRadius = "%newRadius%"`nLength = %length%

                                                            if (newRadius = "" || newRadius < 1 || !newRadius) {
                                                                MsgBox, 0, Error, Please enter a valid number for radius!`n`nYou entered: "%newRadius%"
                                                                return
                                                            }

                                                            FileRead, fileContent, %navCameraFile%
                                                            if (ErrorLevel) {
                                                                MsgBox, Error reading camera file
                                                                return
                                                            }

                                                            newContent := RegExReplace(fileContent, "RADIUS\|[0-9.]+\|", "RADIUS|" . newRadius . "|")

                                                            FileDelete, %navCameraFile%
                                                            FileAppend, %newContent%, %navCameraFile%

                                                            CameraRadius := newRadius
                                                            ; Update the GUI display
                                                            GuiControl,, RadiusEdit, %CameraRadius%

                                                            MsgBox, Radius updated to %newRadius%
                                                        }

                                                        BD5Cam() {
                                                            global CameraFile, CameraRadius

                                                            if (!navCameraFile) {
                                                                MsgBox, 0, Error, No camera file loaded!`n`nPlease select a camera file first.
                                                                return
                                                            }

                                                            ; BD5 camera settings
                                                            bd5Content := "RADIUS|900.0000|XANGLE|1.473184|ZANGLE|0.006136|"

                                                            ; Delete and recreate the file with new content
                                                            FileDelete, %navCameraFile%
                                                            if (ErrorLevel) {
                                                                MsgBox, Error deleting camera file!`nFile: %CameraFile%
                                                                return
                                                            }

                                                            Sleep, 50

                                                            FileAppend, %bd5Content%, %navCameraFile%
                                                            if (ErrorLevel) {
                                                                MsgBox, Error writing to camera file!`nFile: %navCameraFile%
                                                                return
                                                            }

                                                            ; Update the camera radius variable and GUI
                                                            CameraRadius := 900.000000
                                                            GuiControl,, RadiusEdit, %CameraRadius%

                                                            MsgBox, BD5 camera settings applied!`nRadius: 900`nXAngle: 1.510000`nZAngle: 3.129320`n`nFile: %CameraFile%
                                                        }

                                                        PerformCharacterSelect() {
                                                            global TargetGameWindow, navCameraFile, CameraRadius

                                                            AddLog("[CharSelect] TargetGameWindow: " TargetGameWindow)

                                                            if (!TargetGameWindow || TargetGameWindow = "") {
                                                                AddLog("[CharSelect] ERROR: No game window selected! Go to Setup tab and select a game window first.")
                                                                return
                                                            }

                                                            ; Send z key
                                                            ControlSend,, z, ahk_id %TargetGameWindow%
                                                            Sleep, 250 ; Define search patterns
                                                            charselect := "|<>FFFFFF-0.90$68.0E000000000II00008000U610000200201UKB+oItGUU+E4E+0c8WU84I102U82080M10E8cW0U2000M40+0U80U0E4102U+288011CECcuQNu0QDM"
                                                            charselect .= "|<>FFFFFF-0.90$71.200000000020I00008004U4080000E00E080KB+oItGUU+GUW1E514I1UWcV02U82080M102154E40E002040+0U80U0E4080I1EF1008+6ECcuQNu0wDHs"

                                                            ; Search for character select button
                                                            if (FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, charselect)) {
                                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                                relativeX := X - winX
                                                                relativeY := Y - winY
                                                                ControlClick, x%relativeX% y%relativeY%, ahk_id %TargetGameWindow%
                                                                Sleep, 250
                                                            } else {
                                                                AddLog("[CharSelect] Character select button not found")
                                                                return
                                                            }

                                                            ; Define confirm patterns
                                                            confirm := "|<>FFFFFF-0.90$40.00010014000008001000U+/7JKM14WFF4E02154FU084IF600UFF4I4G154FCC84IF6"
                                                            confirm .= "|<>FFFFFF-0.90$40.00010014000008001000U+/7JKM14WFF4E02154FU084IF600UFF4E4G154FC+84IF6"

                                                            ; Search for first confirm button
                                                            if (FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, confirm)) {
                                                                AddLog("[CharSelect] First confirm found, clicking until it disappears...")

                                                                ; Click first confirm button repeatedly until it disappears
                                                                confirmDisappeared := false
                                                                Loop, 1200 { ; 2 minutes = 120 seconds = 1200 iterations at 100ms
                                                                    if (FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, confirm)) {
                                                                        WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                                        relativeX := X - winX
                                                                        relativeY := Y - winY
                                                                        ControlClick, x%relativeX% y%relativeY%, ahk_id %TargetGameWindow%
                                                                    } else {
                                                                        confirmDisappeared := true
                                                                        AddLog("[CharSelect] First confirm disappeared, screen transitioned")
                                                                        break
                                                                    }
                                                                    Sleep, 100
                                                                }

                                                                if (!confirmDisappeared) {
                                                                    AddLog("[CharSelect] First confirm did not disappear after 2 minutes")
                                                                return
                                                            }
                                                        } else {
                                                            AddLog("[CharSelect] First confirm button not found")
                                                            return
                                                        }

                                                        ; Define confirm2 patterns
                                                        confirm2 := "|<>FFFFFF-0.90$40.00010014000008001000U+/7JKM14WFF4E02154F0084IF600UFF4E4G154FC+84IF6"
                                                        confirm2 .= "|<>FFFFFF-0.90$40.0001001400E008001000U+/bJKM14WFF4E02154FU084IF600UFF4I4G154FC+84IF6"

                                                        ; Loop search until confirm2 is found (2 minutes max)
                                                        AddLog("[CharSelect] Searching for final confirm button...")
                                                        foundConfirm2 := false
                                                        confirm2X := 0
                                                        confirm2Y := 0
                                                        Loop, 1200 { ; 2 minutes = 120 seconds = 1200 iterations at 100ms
                                                            if (FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, confirm2)) {
                                                                foundConfirm2 := true
                                                                confirm2X := X
                                                                confirm2Y := Y
                                                                AddLog("[CharSelect] Final confirm button found on screen")
                                                                break
                                                            }
                                                            Sleep, 100
                                                        }

                                                        if (!foundConfirm2) {
                                                            AddLog("[CharSelect] Final confirm button not found after 2 minutes")
                                                            return
                                                        }

                                                        ; Perform BD5 camera setup without message box (only after confirm2 is visible)
                                                        if (navCameraFile) {
                                                            bd5Content := "RADIUS|900.0000|XANGLE|1.473184|ZANGLE|0.006136|"
                                                            FileDelete, %navCameraFile%
                                                            Sleep, 50
                                                            FileAppend, %bd5Content%, %navCameraFile%
                                                            CameraRadius := 900.000000
                                                            GuiControl,, RadiusEdit, %CameraRadius%
                                                            AddLog("[CharSelect] BD5 camera settings applied")
                                                        }

                                                        ; Click confirm2 button repeatedly until it disappears
                                                        AddLog("[CharSelect] Clicking confirm2 until it disappears...")
                                                        Loop, 1200 { ; 2 minutes max
                                                            if (FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, confirm2)) {
                                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                                relativeX := X - winX
                                                                relativeY := Y - winY
                                                                ControlClick, x%relativeX% y%relativeY%, ahk_id %TargetGameWindow%
                                                            } else {
                                                                AddLog("[CharSelect] Confirm2 disappeared, character selected")
                                                                break
                                                            }
                                                            Sleep, 100
                                                        }

                                                        AddLog("[CharSelect] Character selection sequence completed")
                                                    } ; CalibrateLive() {
                                                    ;     if (!TargetGameWindow) {
                                                    ;         MsgBox, Please select a game window first!
                                                    ;         return
                                                    ;     }
                                                    ;
                                                    ;     if (CalibrationActive) {
                                                    ;         ; Finish calibration - count only completed clicks
                                                    ;         completedClicks := 0
                                                    ;         for i, click in CalibrationClicks {
                                                    ;             if (!click.needsEnd) {
                                                    ;                 completedClicks++
                                                    ;             }
                                                    ;         }
                                                    ;         
                                                    ;         if (completedClicks < 2) {
                                                    ;             MsgBox, Not enough data! Need at least 2 completed clicks.`n`nCompleted: %completedClicks%`nTotal recorded: %CalibrationClicks.Length()%`n`nCalibration cancelled.
                                                    ;             CalibrationActive := false
                                                    ;             CalibrationClicks := []
                                                    ;             return
                                                    ;         }
                                                    ;
                                                    ;         ; Calculate camera angle and radius from the clicks
                                                    ;         CalculateCameraFromClicks()
                                                    ;         
                                                    ;         CalibrationActive := false
                                                    ;         CalibrationClicks := []
                                                    ;     } else {
                                                    ;         ; Start calibration
                                                    ;         CalibrationActive := true
                                                    ;         CalibrationClicks := []
                                                    ;         
                                                    ;         GetCurrentCoordinates(CalibrationStartX, CalibrationStartY)
                                                    ;         
                                                    ;         if (CalibrationStartX = "" || CalibrationStartY = "") {
                                                    ;             MsgBox, Could not read coordinates! Make sure the game window is active and coordinates are visible.
                                                    ;             CalibrationActive := false
                                                    ;             return
                                                    ;         }
                                                    ;
                                                    ;         MsgBox, 0, Live Calibration Started, 
                                                    ;         (
                                                    ; Live Camera Calibration Active!
                                                    ;
                                                    ; Starting position: %CalibrationStartX% %CalibrationStartY%
                                                    ;
                                                    ; NEW WORKFLOW:
                                                    ; 1. Click somewhere in the game (right-click to move)
                                                    ; 2. Press F9 IMMEDIATELY after clicking
                                                    ; 3. Wait 3 seconds for character to move
                                                    ; 4. Repeat steps 1-3 for 3-4 different spots (spread out in different directions)
                                                    ; 5. Click "Live Calibrate" button again to finish
                                                    ;
                                                    ; The script will automatically:
                                                    ; - Record your click position when you press F9
                                                    ; - Wait 3 seconds and record where you ended up
                                                    ; - Calculate camera settings from all movements
                                                    ;
                                                    ; Press F9 after EACH click, then wait for the movement to complete!
                                                    ;         )
                                                    ;     }
                                                    ; }

                                                    ; CalculateCameraFromClicks() {
                                                    ;     ; This function uses the calibration click data to reverse-engineer camera settings
                                                    ;     ; We have: starting position, click positions, and ending positions
                                                    ;     ; We need to find: ZANGLE and optionally RADIUS
                                                    ;     
                                                    ;     ; Filter out incomplete clicks (where needsEnd is still true)
                                                    ;     validClicks := []
                                                    ;     for i, click in CalibrationClicks {
                                                    ;         if (!click.needsEnd) {
                                                    ;             validClicks.Push(click)
                                                    ;         }
                                                    ;     }
                                                    ;     
                                                    ;     totalClicks := validClicks.Length()
                                                    ;     
                                                    ;     ; Need at least 2 movements to calculate
                                                    ;     if (totalClicks < 2) {
                                                    ;         MsgBox, Calibration failed: Not enough completed movements`n`nTotal recorded: %CalibrationClicks.Length()%`nCompleted: %totalClicks%
                                                    ;         return
                                                    ;     }
                                                    ;
                                                    ;     ; Base click position (center of screen)
                                                    ;     baseClickX := 516
                                                    ;     baseClickY := 410
                                                    ;
                                                    ;     ; Try different angles and see which one gives the most consistent pixel ratio
                                                    ;     bestAngle := 0
                                                    ;     bestScore := 999999
                                                    ;     
                                                    ;     ; Search angles from -π to π
                                                    ;     angles := []
                                                    ;     Loop, 72 {
                                                    ;         angle := -3.14159 + (A_Index - 1) * (6.28318 / 72)
                                                    ;         angles.Push(angle)
                                                    ;     }
                                                    ;
                                                    ;     for index, testAngle in angles {
                                                    ;         cos_a := Cos(-testAngle)
                                                    ;         sin_a := Sin(-testAngle)
                                                    ;         
                                                    ;         xRatios := []
                                                    ;         yRatios := []
                                                    ;         
                                                    ;         ; Calculate ratios for each click with this angle
                                                    ;         for i, click in validClicks {
                                                    ;             screenDeltaX := click.clickX - baseClickX
                                                    ;             screenDeltaY := click.clickY - baseClickY
                                                    ;             
                                                    ;             ; Reverse rotation
                                                    ;             unrotX := screenDeltaX * cos_a - screenDeltaY * sin_a
                                                    ;             unrotY := screenDeltaX * sin_a + screenDeltaY * cos_a
                                                    ;             
                                                    ;             gameDeltaX := click.endX - click.startX
                                                    ;             gameDeltaY := click.endY - click.startY
                                                    ;             
                                                    ;             ; Skip if no movement
                                                    ;             if (Abs(gameDeltaX) < 5 && Abs(gameDeltaY) < 5)
                                                    ;                 continue
                                                    ;             
                                                    ;             ; Calculate ratios (pixels per game unit)
                                                    ;             if (Abs(unrotX) > 10 && Abs(gameDeltaX) > 10) {
                                                    ;                 ratio := Abs(unrotX / gameDeltaX)
                                                    ;                 xRatios.Push(ratio)
                                                    ;             }
                                                    ;             if (Abs(unrotY) > 10 && Abs(gameDeltaY) > 10) {
                                                    ;                 ratio := Abs(unrotY / gameDeltaY)
                                                    ;                 yRatios.Push(ratio)
                                                    ;             }
                                                    ;         }
                                                    ;         
                                                    ;         ; Calculate variance - lower is better (more consistent)
                                                    ;         if (xRatios.Length() > 0 && yRatios.Length() > 0) {
                                                    ;             avgX := 0
                                                    ;             avgY := 0
                                                    ;             for i, val in xRatios
                                                    ;                 avgX += val
                                                    ;             for i, val in yRatios
                                                    ;                 avgY += val
                                                    ;             avgX /= xRatios.Length()
                                                    ;             avgY /= yRatios.Length()
                                                    ;             
                                                    ;             variance := 0
                                                    ;             for i, val in xRatios
                                                    ;                 variance += (val - avgX) ** 2
                                                    ;             for i, val in yRatios
                                                    ;                 variance += (val - avgY) ** 2
                                                    ;             
                                                    ;             if (variance < bestScore) {
                                                    ;                 bestScore := variance
                                                    ;                 bestAngle := testAngle
                                                    ;             }
                                                    ;         }
                                                    ;     }
                                                    ; }

                                                    ; RecordCalibrationClick() {
                                                    ;     if (!CalibrationActive) {
                                                    ;         ToolTip, Calibration is not active! Click "Live Calibrate" first.
                                                    ;         SetTimer, RemoveToolTip, 2000
                                                    ;         return
                                                    ;     }
                                                    ; }

                                                    ; GetCalibrationEndPosition:
                                                    ;     ToolTip
                                                    ;     SetTimer, RemoveToolTip, Off
                                                    ; return

                                                    ; RemoveToolTip:
                                                    ;     ToolTip
                                                    ;     SetTimer, RemoveToolTip, Off
                                                    ; return

                                                    ActivateCoordinates:
                                                        if (!TargetGameWindow) {
                                                            SelectWindow()
                                                            if (!TargetGameWindow) {
                                                                return
                                                            }
                                                        }

                                                        Clipboard := "/info"
                                                        WinActivate, ahk_id %TargetGameWindow%
                                                        Sleep, 100
                                                        Send, {Enter}
                                                        Sleep, 80
                                                        Send, ^v
                                                        Sleep, 80
                                                        Send, {Enter}

                                                    return

                                                    ExitApp:
                                                    GuiClose:
                                                        SetTimer, CheckExecutions, Off
                                                        SetTimer, CheckHealth, Off
                                                        SetTimer, DPSLoop, Off
                                                        ClearBoundingBoxes()
                                                        ReleaseAllWASDKeys() ; Make sure to release keys before exit
                                                    ExitApp

                                                    FuncBlockGuiClose:
                                                        Gui, FuncBlock:Destroy
                                                    return

                                                    SelectWindow() {
                                                        global win1, TargetGameWindow, TargetGamePID, CameraFile
                                                        global NavTargetGameWindow, NavTargetGamePID, NavCameraFile

                                                        MsgBox, Now right click on the game window 
                                                        KeyWait, RButton, D
                                                        MouseGetPos,,, selectedWindow
                                                        WinGetTitle, title, ahk_id %selectedWindow%
                                                        WinGet, pid, PID, ahk_id %selectedWindow%
                                                        MsgBox, You have selected: %title% (PID: %pid%)

                                                        ; Set up for healing system
                                                        FindText().BindWindow(selectedWindow)
                                                        win1 := selectedWindow
                                                        TargetGameWindow := selectedWindow
                                                        TargetGamePID := pid

                                                        ; Set up for navigation system
                                                        NavTargetGameWindow := selectedWindow
                                                        NavTargetGamePID := pid

                                                        ; Handle camera file selection for both systems
                                                        ; Check if there's a saved navigation camera file
                                                        IniRead, savedNavCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
                                                        IniRead, savedMainCameraFile, pathingsettings.ini, Settings, CameraFile, ERROR

                                                        selectedCameraFile := ""

                                                        ; Prioritize navigation camera file, then main camera file
                                                        if (savedNavCameraFile != "ERROR" && FileExist(savedNavCameraFile)) {
                                                            MsgBox, 4,, Use previous navigation camera file?`n%savedNavCameraFile%
                                                            IfMsgBox Yes
                                                            {
                                                                selectedCameraFile := savedNavCameraFile
                                                            }
                                                        }
                                                        else if (savedMainCameraFile != "ERROR" && FileExist(savedMainCameraFile)) {
                                                            MsgBox, 4,, Use previous camera file?`n%savedMainCameraFile%
                                                            IfMsgBox Yes
                                                            {
                                                                selectedCameraFile := savedMainCameraFile
                                                            }
                                                        }

                                                        ; If no saved file or user declined, ask for new file
                                                        if (selectedCameraFile = "") {
                                                            FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
                                                        }

                                                        ; Apply camera file to both systems if selected
                                                        if (selectedCameraFile != "") {
                                                            ; Set up navigation camera
                                                            NavCameraFile := selectedCameraFile
                                                            LoadNavCameraSettings(NavCameraFile)
                                                            GuiControl,, NavCameraFile, Camera: %NavCameraFile%
                                                            GuiControl,, NavRadiusEdit, %NavCameraRadius%

                                                            ; Set up main camera
                                                            CameraFile := selectedCameraFile
                                                            LoadCameraSettings(navCameraFile)

                                                            MsgBox, Camera file loaded for both systems: %selectedCameraFile%
                                                            SaveNavSettings()
                                                            SaveSettings()
                                                            UpdateStatusBar()
                                                        }
                                                    return
                                                }

                                                SelectWin2() {
                                                    global win2, win2PID

                                                    MsgBox, Now right click on the SECOND game window (Win2)
                                                    KeyWait, RButton, D
                                                    MouseGetPos,,, tempWin
                                                    WinGetTitle, title, ahk_id %tempWin%
                                                    WinGet, pid, PID, ahk_id %tempWin%
                                                    win2 := tempWin
                                                    win2PID := pid
                                                    MsgBox, Win2 selected: %title% (PID: %pid%)`n`nYou can now use ControlSend commands with win2 in waypoint commands.
                                                    return
                                                }

                                                UpdateStatusBar() {
                                                    global TargetGameWindow, SelectedRouteFile, TargetNodes
                                                    status := ""
                                                    if (TargetGameWindow) {
                                                        WinGetTitle, t, ahk_id %TargetGameWindow%
                                                        status .= "Window: " . t
                                                    } else {
                                                        status .= "Window: (none)"
                                                    }
                                                    if (SelectedRouteFile && FileExist(SelectedRouteFile)) {
                                                        SplitPath, SelectedRouteFile, fileName
                                                        status .= " | Route: " . fileName
                                                    } else {
                                                        status .= " | Route: (none)"
                                                    }
                                                    count := (IsObject(TargetNodes) ? TargetNodes.Length() : 0)
                                                    status .= " | Nodes: " . count
                                                    SB_SetText(status)
                                                }

                                                LoadCameraSettings(filePath) {
                                                    FileRead, fileContent, %filePath%
                                                    if (ErrorLevel) {
                                                        MsgBox, Error reading camera file
                                                    return
                                                }

                                                RegExMatch(fileContent, "RADIUS\|([0-9.]+)\|", radiusMatch)
                                                RegExMatch(fileContent, "ZANGLE\|([0-9.-]+)\|", zangleMatch)

                                                if (radiusMatch1) {
                                                    CameraRadius := radiusMatch1
                                                    ; Remove the old pixel calculation since it's now done in NavigateToCoordinatesClick
                                                    GuiControl,, RadiusEdit, %CameraRadius%
                                                }

                                                if (zangleMatch1) {
                                                    CameraAngle := zangleMatch1
                                                }
                                            }

                                            GetCurrentCoordinates(ByRef outX, ByRef outY) {
                                                static lastX := "", lastY := "", lastCheckTime := 0
                                                static cacheTimeout := 25 ; Increased cache timeout to reduce CPU load

                                                ; Use cached values if available and recent
                                                currentTime := A_TickCount
                                                if (lastX != "" && lastY != "" && (currentTime - lastCheckTime) < cacheTimeout) {
                                                    outX := lastX
                                                    outY := lastY
                                                    return
                                                }

                                                outX := ""
                                                outY := ""

                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                searchX1 := winX + 835
                                                searchY1 := winY + 30
                                                searchX2 := winX + 1019
                                                searchY2 := winY + 48

                                                if (ok := FindText(x, y, searchX1, searchY1, searchX2, searchY2, 0, 0, NavText)) {
                                                    results := []
                                                    for i, v in ok {
                                                        results.Push({x: v.x, id: v.id})
                                                    }

                                                    resultsLen := results.MaxIndex()
                                                    ; Safety check: limit sorting to prevent infinite loops
                                                    if (resultsLen > 0 && resultsLen <= 50) {
                                                        ; Optimized bubble sort with safety limits
                                                        maxIterations := resultsLen * resultsLen ; Prevent infinite loops
                                                        iterations := 0

                                                        Loop % resultsLen - 1 {
                                                            i := A_Index
                                                            Loop % resultsLen - i {
                                                                j := A_Index + i
                                                                iterations++
                                                                if (iterations > maxIterations) {
                                                                    break 2 ; Exit both loops if too many iterations
                                                                }
                                                                if (results[i].x > results[j].x) {
                                                                    temp := results[i]
                                                                    results[i] := results[j]
                                                                    results[j] := temp
                                                                }
                                                            }
                                                        }
                                                    }

                                                    coordX := ""
                                                    coordY := ""
                                                    spaceFound := false

                                                    for i, v in results {
                                                        if (i > 1) {
                                                            prevX := results[i-1].x
                                                            gap := v.x - prevX
                                                            if (gap > 9 && !spaceFound) {
                                                                spaceFound := true
                                                            }
                                                        }

                                                        if (!spaceFound) {
                                                            coordX .= v.id
                                                        } else {
                                                            coordY .= v.id
                                                        }
                                                    }

                                                    outX := coordX + 0
                                                    outY := coordY + 0

                                                    ; Update cache
                                                    lastX := outX
                                                    lastY := outY
                                                    lastCheckTime := currentTime
                                                }
                                            }

                                            ShowSearchArea() {
                                                if (!TargetGameWindow) {
                                                    MsgBox, 0, Error, Please select a window first!
                                                    return
                                                }

                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                searchX1 := winX + 835
                                                searchY1 := winY + 30
                                                searchX2 := winX + 1019
                                                searchY2 := winY + 48

                                                Gui, New, +ToolWindow -Caption +AlwaysOnTop, Top
                                                Gui, Color, Red
                                                Gui, Show, x%searchX1% y%searchY1% w184 h2, Top

                                                Gui, New, +ToolWindow -Caption +AlwaysOnTop, Bottom
                                                Gui, Color, Red
                                                bottomY := searchY2 - 2
                                                Gui, Show, x%searchX1% y%bottomY% w184 h2, Bottom

                                                Gui, New, +ToolWindow -Caption +AlwaysOnTop, Left
                                                Gui, Color, Red
                                                Gui, Show, x%searchX1% y%searchY1% w2 h18, Left

                                                Gui, New, +ToolWindow -Caption +AlwaysOnTop, Right
                                                Gui, Color, Red
                                                rightX := searchX2 - 2
                                                Gui, Show, x%rightX% y%searchY1% w2 h18, Right

                                                Sleep, 5000
                                                Gui, Top:Destroy
                                                Gui, Bottom:Destroy
                                                Gui, Left:Destroy
                                                Gui, Right:Destroy
                                            }

                                            UpdateCoordinateDisplay()

                                            ; Build message text explicitly
                                            messageText := "Area set to:"
                                            messageText .= "`nX1: " . checkweightX1 . ", Y1: " . checkweightY1
                                            messageText .= "`nX2: " . checkweightX2 . ", Y2: " . checkweightY2
                                            messageText .= "`n`nCoordinates saved!"

                                            MsgBox, 64, Success, %messageText%

                                            Gui, Show
                                            return

                                            CreateVisualTargetNode(node) {
                                                global

                                                ; Check if already exists
                                                if (NodeGUIs[node.id])
                                                    return

                                                ; Set flag to prevent update conflicts
                                                CreatingGUI := true

                                                ; Get current player coordinates
                                                GetCurrentCoordinates(playerX, playerY)
                                                if (playerX = "" || playerY = "") {
                                                    CreatingGUI := false
                                                    return
                                                }

                                                ; Get game window position
                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                                ; Calculate where node should appear based on target world coordinates
                                                deltaX := node.worldX - playerX
                                                deltaY := node.worldY - playerY

                                                ; Use EXACT same calculation as NavigateToCoordinatesClick
                                                ; Calculate Y scaling based on camera radius
                                                if (CameraRadius <= 900) {
                                                    pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                } else if (CameraRadius <= 1000) {
                                                    t := (CameraRadius - 900) / 100
                                                    pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                } else if (CameraRadius <= 1500) {
                                                    t := (CameraRadius - 1000) / 500
                                                    pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                } else {
                                                    t := (CameraRadius - 1500) / 500
                                                    pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                }

                                                ; Apply base scaling
                                                scaledX := -deltaX * 1.21
                                                scaledY := deltaY * pixelsPerGameUnitY ; POSITIVE for display

                                                ; Apply distance correction
                                                scaledX := scaledX * 0.94
                                                scaledY := scaledY * 1.19

                                                ; Apply camera rotation (NO radian conversion)
                                                cos_angle := Cos(-CameraAngle)
                                                sin_angle := Sin(-CameraAngle)
                                                rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                                rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                ; Calculate screen position - Use PLUS for Y when displaying (opposite of clicking)
                                                screenX := winX + 516 + Round(rotatedX) - (NodeSize // 2)
                                                screenY := winY + 410 + Round(rotatedY) - (NodeSize // 2)

                                                ; Create node GUI with unique name
                                                guiName := "TargetNode" . node.id

                                                ; Simple approach: just create the GUI
                                                Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                                Gui, %guiName%:Color, FF0000
                                                Gui, %guiName%:Font, s8 cWhite Bold

                                                nodeIDText := node.id
                                                Gui, %guiName%:Add, Text, x0 y0 w%NodeSize% h%NodeSize% Center BackgroundTrans, %nodeIDText%
                                                Gui, %guiName%:Show, x%screenX% y%screenY% w%NodeSize% h%NodeSize% NA
                                                WinSet, Transparent, 150, %guiName%
                                                ; Make it click-through using DllCall
                                                WinGet, nodeHwnd, ID, %guiName%
                                                ; Get current extended style
                                                exStyle := DllCall("GetWindowLong", "Ptr", nodeHwnd, "Int", -20, "UInt")
                                                ; Add WS_EX_TRANSPARENT (0x20) and WS_EX_LAYERED (0x80000)
                                                exStyle := exStyle | 0x20 | 0x80000
                                                ; Set the new extended style
                                                DllCall("SetWindowLong", "Ptr", nodeHwnd, "Int", -20, "UInt", exStyle)

                                                ; Store GUI name
                                                NodeGUIs[node.id] := guiName

                                                ; Clear flag
                                                CreatingGUI := false

                                                ; Start update timer if not already running (500ms for better performance)
                                                SetTimer, UpdateAllTargetNodes, 500
                                            }

                                            UpdateNodeWorldCoordinatesInMoveMode(nodeID) {
                                                global

                                                ; Find the node in the array
                                                nodeIndex := 0
                                                for index, node in TargetNodes {
                                                    if (node.id = nodeID) {
                                                        nodeIndex := index
                                                        break
                                                    }
                                                }

                                                if (nodeIndex = 0)
                                                    return

                                                ; Get the current GUI position
                                                guiName := NodeGUIs[nodeID]
                                                if (!guiName)
                                                    return

                                                ; Get GUI screen position
                                                WinGetPos, guiX, guiY,,, %guiName%
                                                if (ErrorLevel)
                                                    return

                                                ; Calculate center of the GUI
                                                screenX := guiX + (NodeSize // 2)
                                                screenY := guiY + (NodeSize // 2)

                                                ; Get current player coordinates
                                                GetCurrentCoordinates(playerX, playerY)
                                                if (playerX = "" || playerY = "")
                                                    return

                                                ; Get game window position
                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                if (ErrorLevel)
                                                    return

                                                ; Calculate pixel offset from character center
                                                baseScreenX := winX + 516
                                                baseScreenY := winY + 410
                                                pixelDeltaX := screenX - baseScreenX
                                                pixelDeltaY := screenY - baseScreenY

                                                ; Reverse the coordinate conversion to get world coordinates
                                                ; Undo rotation
                                                rotatedDeltaX := pixelDeltaX * Cos(CameraAngle) - pixelDeltaY * Sin(CameraAngle)
                                                rotatedDeltaY := pixelDeltaX * Sin(CameraAngle) + pixelDeltaY * Cos(CameraAngle)

                                                ; Undo distance scaling
                                                rotatedDeltaX /= 0.94
                                                rotatedDeltaY /= 1.19

                                                ; Undo base scaling (note: negative for X)
                                                worldDeltaX := -rotatedDeltaX / 1.21
                                                worldDeltaY := rotatedDeltaY / 0.95

                                                ; Calculate new world coordinates
                                                newWorldX := Round(playerX + worldDeltaX, 2)
                                                newWorldY := Round(playerY + worldDeltaY, 2)

                                                ; Update the node in the array (but don't save yet)
                                                TargetNodes[nodeIndex].worldX := newWorldX
                                                TargetNodes[nodeIndex].worldY := newWorldY

                                                ; Mark this node as moved
                                                NodesMovedDuringSession[nodeID] := true

                                                ; Force immediate position update based on new coordinates
                                                deltaX := newWorldX - playerX
                                                deltaY := newWorldY - playerY

                                                ; Apply scaling factors
                                                scaledX := -deltaX * 1.21
                                                scaledY := deltaY * 0.95

                                                ; Apply distance correction
                                                scaledX *= 0.94
                                                scaledY *= 1.19

                                                ; Apply camera rotation
                                                rotatedX := scaledX * Cos(CameraAngle) - scaledY * Sin(CameraAngle)
                                                rotatedY := scaledX * Sin(CameraAngle) + scaledY * Cos(CameraAngle)

                                                ; Calculate screen position
                                                screenX := winX + 516 + Round(rotatedX)
                                                screenY := winY + 410 + Round(rotatedY)

                                                ; Update node position immediately
                                                nodeX := screenX - (NodeSize // 2)
                                                nodeY := screenY - (NodeSize // 2)

                                                Gui, %guiName%:Show, x%nodeX% y%nodeY% NA
                                            }

                                            UpdateNodeWorldCoordinates(nodeID) {
                                                global

                                                ; Find the node in the array
                                                nodeIndex := 0
                                                for index, node in TargetNodes {
                                                    if (node.id = nodeID) {
                                                        nodeIndex := index
                                                        break
                                                    }
                                                }

                                                if (nodeIndex = 0) {
                                                    ToolTip, Error: Node #%nodeID% not found!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Get the current GUI position
                                                guiName := NodeGUIs[nodeID]
                                                if (!guiName) {
                                                    ToolTip, Error: GUI for node #%nodeID% not found!, 0, 0
                                                        SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Get GUI screen position
                                                WinGetPos, guiX, guiY,,, %guiName%
                                                if (ErrorLevel) {
                                                    ToolTip, Error: Could not get GUI position for node #%nodeID%!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Calculate center of the GUI
                                                screenX := guiX + (NodeSize // 2)
                                                screenY := guiY + (NodeSize // 2)

                                                ; Get current player coordinates
                                                GetCurrentCoordinates(playerX, playerY)
                                                if (playerX = "" || playerY = "") {
                                                    ToolTip, Error: Could not get current coordinates!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Get game window position
                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                if (ErrorLevel) {
                                                    ToolTip, Error: Could not get window position!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Calculate pixel offset from character center
                                                baseScreenX := winX + 516
                                                baseScreenY := winY + 410
                                                pixelDeltaX := screenX - baseScreenX
                                                pixelDeltaY := screenY - baseScreenY

                                                ; Reverse the coordinate conversion to get world coordinates
                                                ; Undo rotation
                                                rotatedDeltaX := pixelDeltaX * Cos(CameraAngle) - pixelDeltaY * Sin(CameraAngle)
                                                rotatedDeltaY := pixelDeltaX * Sin(CameraAngle) + pixelDeltaY * Cos(CameraAngle)

                                                ; Undo distance scaling
                                                rotatedDeltaX /= 0.94
                                                rotatedDeltaY /= 1.19

                                                ; Undo base scaling (note: negative for X)
                                                worldDeltaX := -rotatedDeltaX / 1.21
                                                worldDeltaY := rotatedDeltaY / 0.95

                                                ; Calculate new world coordinates
                                                newWorldX := Round(playerX + worldDeltaX, 2)
                                                newWorldY := Round(playerY + worldDeltaY, 2)

                                                ; Update the node in the array
                                                TargetNodes[nodeIndex].worldX := newWorldX
                                                TargetNodes[nodeIndex].worldY := newWorldY

                                                ; Save updated nodes to file
                                                SaveNodes()

                                                ; Force immediate position update based on new coordinates
                                                ; This ensures the GUI stays at the new position
                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                if (!ErrorLevel) {
                                                    deltaX := newWorldX - playerX
                                                    deltaY := newWorldY - playerY

                                                    ; Apply scaling factors
                                                    scaledX := -deltaX * 1.21
                                                    scaledY := deltaY * 0.95

                                                    ; Apply distance correction
                                                    scaledX *= 0.94
                                                    scaledY *= 1.19

                                                    ; Apply camera rotation
                                                    rotatedX := scaledX * Cos(CameraAngle) - scaledY * Sin(CameraAngle)
                                                    rotatedY := scaledX * Sin(CameraAngle) + scaledY * Cos(CameraAngle)

                                                    ; Calculate screen position
                                                    screenX := winX + 516 + Round(rotatedX)
                                                    screenY := winY + 410 + Round(rotatedY)

                                                    ; Update node position immediately
                                                    nodeX := screenX - (NodeSize // 2)
                                                    nodeY := screenY - (NodeSize // 2)

                                                    Gui, %guiName%:Show, x%nodeX% y%nodeY% NA
                                                }

                                                ; Show confirmation tooltip
                                                ToolTip, Node #%nodeID% moved to X:%newWorldX% Y:%newWorldY%, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                            }

                                            UpdateWaypointWorldCoordinates(waypointIndex) {
                                                global

                                                ; Check if waypoint exists
                                                if (waypointIndex < 1 || waypointIndex > Waypoints.Length()) {
                                                    ToolTip, Error: Waypoint #%waypointIndex% not found!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Get the current GUI position
                                                guiName := WaypointGUIs[waypointIndex]
                                                if (!guiName) {
                                                    ToolTip, Error: GUI for waypoint #%waypointIndex% not found!, 0, 0
                                                        SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Get GUI screen position
                                                WinGetPos, guiX, guiY,,, %guiName%
                                                if (ErrorLevel) {
                                                    ToolTip, Error: Could not get GUI position for waypoint #%waypointIndex%!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Calculate center of the GUI
                                                screenX := guiX + (WaypointSize // 2)
                                                screenY := guiY + (WaypointSize // 2)

                                                ; Get current player coordinates
                                                GetCurrentCoordinates(playerX, playerY)
                                                if (playerX = "" || playerY = "") {
                                                    ToolTip, Error: Could not get current coordinates!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Get game window position
                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                if (ErrorLevel) {
                                                    ToolTip, Error: Could not get window position!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                }

                                                ; Calculate pixel offset from character center
                                                baseScreenX := winX + 516
                                                baseScreenY := winY + 410
                                                pixelDeltaX := screenX - baseScreenX
                                                pixelDeltaY := screenY - baseScreenY

                                                ; Reverse the coordinate conversion to get world coordinates
                                                ; Undo rotation
                                                rotatedDeltaX := pixelDeltaX * Cos(CameraAngle) - pixelDeltaY * Sin(CameraAngle)
                                                rotatedDeltaY := pixelDeltaX * Sin(CameraAngle) + pixelDeltaY * Cos(CameraAngle)

                                                ; Undo distance scaling
                                                rotatedDeltaX /= 0.94
                                                rotatedDeltaY /= 1.19

                                                ; Undo base scaling (note: negative for X)
                                                worldDeltaX := -rotatedDeltaX / 1.21
                                                worldDeltaY := rotatedDeltaY / 0.95

                                                ; Calculate new world coordinates
                                                newWorldX := Round(playerX + worldDeltaX, 2)
                                                newWorldY := Round(playerY + worldDeltaY, 2)

                                                ; Update the waypoint in the array
                                                Waypoints[waypointIndex].x := newWorldX
                                                Waypoints[waypointIndex].y := newWorldY

                                                ; Save updated waypoint to route file
                                                if (SelectedRouteFile) {
                                                    IniWrite, %newWorldX%, %SelectedRouteFile%, Waypoints, X%waypointIndex%
                                                    IniWrite, %newWorldY%, %SelectedRouteFile%, Waypoints, Y%waypointIndex%
                                                }

                                                ; Force immediate position update based on new coordinates
                                                ; This ensures the GUI stays at the new position
                                                deltaX := newWorldX - playerX
                                                deltaY := newWorldY - playerY

                                                ; Apply scaling factors
                                                scaledX := -deltaX * 1.21
                                                scaledY := deltaY * 0.95 ; POSITIVE for display

                                                ; Apply distance correction
                                                scaledX *= 0.94
                                                scaledY *= 1.19

                                                ; Apply camera rotation
                                                rotatedX := scaledX * Cos(CameraAngle) - scaledY * Sin(CameraAngle)
                                                rotatedY := scaledX * Sin(CameraAngle) + scaledY * Cos(CameraAngle)

                                                ; Calculate screen position - Use PLUS for Y when displaying
                                                screenX := winX + 516 + Round(rotatedX)
                                                screenY := winY + 410 + Round(rotatedY)

                                                ; Update waypoint position immediately
                                                waypointX := screenX - (WaypointSize // 2)
                                                waypointY := screenY - (WaypointSize // 2)

                                                Gui, %guiName%:Show, x%waypointX% y%waypointY% NA

                                                ; Show confirmation tooltip
                                                ToolTip, Waypoint #%waypointIndex% moved to X:%newWorldX% Y:%newWorldY%, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                            }

                                            CreateVisualWaypoint(waypointIndex, worldX, worldY) {
                                                global

                                                ; Check if already exists
                                                if (WaypointGUIs[waypointIndex])
                                                    return

                                                ; Set flag to prevent update conflicts
                                                CreatingGUI := true

                                                ; Get current player coordinates
                                                GetCurrentCoordinates(playerX, playerY)
                                                if (playerX = "" || playerY = "") {
                                                    CreatingGUI := false
                                                    return
                                                }

                                                ; Get game window position
                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                                ; Calculate where waypoint should appear based on world coordinates
                                                deltaX := worldX - playerX
                                                deltaY := worldY - playerY

                                                ; Use EXACT same calculation as nodes
                                                ; Calculate Y scaling based on camera radius
                                                if (CameraRadius <= 900) {
                                                    pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                } else if (CameraRadius <= 1000) {
                                                    t := (CameraRadius - 900) / 100
                                                    pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                } else if (CameraRadius <= 1500) {
                                                    t := (CameraRadius - 1000) / 500
                                                    pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                } else {
                                                    t := (CameraRadius - 1500) / 500
                                                    pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                }

                                                ; Apply base scaling
                                                scaledX := -deltaX * 1.21
                                                scaledY := deltaY * pixelsPerGameUnitY ; POSITIVE for display

                                                ; Apply distance correction
                                                scaledX := scaledX * 0.94
                                                scaledY := scaledY * 1.19

                                                ; Apply camera rotation (NO radian conversion)
                                                cos_angle := Cos(-CameraAngle)
                                                sin_angle := Sin(-CameraAngle)
                                                rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                                rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                ; Calculate screen position - Use PLUS for Y when displaying (opposite of clicking)
                                                screenX := winX + 516 + Round(rotatedX) - (WaypointSize // 2)
                                                screenY := winY + 410 + Round(rotatedY) - (WaypointSize // 2)

                                                ; Create waypoint GUI with unique name (GREEN color)
                                                guiName := "Waypoint" . waypointIndex

                                                ; Simple approach: just create the GUI
                                                Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                                Gui, %guiName%:Color, 00FF00
                                                Gui, %guiName%:Font, s8 cWhite Bold

                                                waypointText := waypointIndex
                                                Gui, %guiName%:Add, Text, x0 y0 w%WaypointSize% h%WaypointSize% Center BackgroundTrans, %waypointText%
                                                Gui, %guiName%:Show, x%screenX% y%screenY% w%WaypointSize% h%WaypointSize% NA
                                                WinSet, Transparent, 150, %guiName%
                                                ; Make it click-through using DllCall
                                                WinGet, waypointHwnd, ID, %guiName%
                                                ; Get current extended style
                                                exStyle := DllCall("GetWindowLong", "Ptr", waypointHwnd, "Int", -20, "UInt")
                                                ; Add WS_EX_TRANSPARENT (0x20) and WS_EX_LAYERED (0x80000)
                                                exStyle := exStyle | 0x20 | 0x80000
                                                ; Set the new extended style
                                                DllCall("SetWindowLong", "Ptr", waypointHwnd, "Int", -20, "UInt", exStyle)

                                                ; Store GUI name
                                                WaypointGUIs[waypointIndex] := guiName

                                                ; Clear flag
                                                CreatingGUI := false

                                                ; Start update timer if not already running
                                                SetTimer, UpdateAllWaypoints, 250
                                            }

                                            UpdateAllTargetNodes:
                                                ; Skip if currently creating a GUI to prevent conflicts
                                                if (CreatingGUI)
                                                    return

                                                if (TargetNodes.Length() = 0) {
                                                    SetTimer, UpdateAllTargetNodes, Off
                                                    return
                                                }

                                                ; Get current player coordinates
                                                GetCurrentCoordinates(playerX, playerY)
                                                if (playerX = "" || playerY = "") {
                                                    return
                                                }

                                                ; Only update if player moved significantly (reduces flicker)
                                                deltaMove := Sqrt((playerX - LastPlayerX)**2 + (playerY - LastPlayerY)**2)
                                                if (deltaMove < 1) {
                                                    return
                                                }
                                                LastPlayerX := playerX
                                                LastPlayerY := playerY

                                                ; Get game window position
                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                if (ErrorLevel) {
                                                    return
                                                }

                                                ; First pass: calculate distances and sort nodes by proximity
                                                nodeDistances := []
                                                for index, node in TargetNodes {
                                                    deltaX := node.worldX - playerX
                                                    deltaY := node.worldY - playerY
                                                    distance := Sqrt(deltaX**2 + deltaY**2)
                                                    nodeDistances.Push({index: index, node: node, distance: distance})
                                                }

                                                ; Sort by distance (bubble sort for simplicity)
                                                Loop % nodeDistances.Length() - 1 {
                                                    i := A_Index
                                                    Loop % nodeDistances.Length() - i {
                                                        j := A_Index
                                                        if (nodeDistances[j].distance > nodeDistances[j+1].distance) {
                                                            temp := nodeDistances[j]
                                                            nodeDistances[j] := nodeDistances[j+1]
                                                            nodeDistances[j+1] := temp
                                                        }
                                                    }
                                                }

                                                ; Second pass: show only closest nodes within range
                                                maxVisibleNodes := 12
                                                maxDistance := 500
                                                visibleCount := 0

                                                for index, nodeData in nodeDistances {
                                                    node := nodeData.node
                                                    distance := nodeData.distance
                                                    guiName := NodeGUIs[node.id]

                                                    ; Check if this node should be visible
                                                    shouldShow := (ShowTargetNodes && distance <= maxDistance && visibleCount < maxVisibleNodes)

                                                    if (shouldShow) {
                                                        visibleCount++

                                                        ; Create GUI if it doesn't exist yet
                                                        if (!guiName) {
                                                            CreateVisualTargetNode(node)
                                                            guiName := NodeGUIs[node.id]
                                                        }

                                                        if (!guiName)
                                                            continue

                                                        ; Calculate delta in world coordinates
                                                        deltaX := node.worldX - playerX
                                                        deltaY := node.worldY - playerY

                                                        ; Use EXACT same calculation as NavigateToCoordinatesClick
                                                        ; Calculate Y scaling based on camera radius
                                                        if (CameraRadius <= 900) {
                                                            pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                        } else if (CameraRadius <= 1000) {
                                                            t := (CameraRadius - 900) / 100
                                                            pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                        } else if (CameraRadius <= 1500) {
                                                            t := (CameraRadius - 1000) / 500
                                                            pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                        } else {
                                                            t := (CameraRadius - 1500) / 500
                                                            pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                        }

                                                        ; Apply base scaling
                                                        scaledX := -deltaX * 1.21
                                                        scaledY := deltaY * pixelsPerGameUnitY ; POSITIVE - display is opposite of click conversion

                                                        ; Apply distance correction
                                                        scaledX := scaledX * 0.94
                                                        scaledY := scaledY * 1.19

                                                        ; Apply camera rotation (NO radian conversion - CameraAngle is already in the right units)
                                                        cos_angle := Cos(-CameraAngle)
                                                        sin_angle := Sin(-CameraAngle)
                                                        rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                                        rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                        ; Convert to screen coordinates
                                                        screenX := winX + 516 + Round(rotatedX)
                                                        screenY := winY + 410 + Round(rotatedY)

                                                        ; Update node position
                                                        nodeX := screenX - (NodeSize // 2)
                                                        nodeY := screenY - (NodeSize // 2)

                                                        Gui, %guiName%:Show, x%nodeX% y%nodeY% NA
                                                        ; Reapply click-through after show
                                                        WinGet, nodeHwnd, ID, %guiName%
                                                        if (nodeHwnd) {
                                                            MakeWindowClickThroughByHandle(nodeHwnd)
                                                        }
                                                    } else if (guiName) {
                                                        ; Hide nodes that are too far or beyond the limit (only if GUI exists)
                                                        Gui, %guiName%:Hide
                                                    }
                                                }
                                            return

                                            UpdateAllWaypoints:
                                                ; Skip if currently creating a GUI to prevent conflicts
                                                if (CreatingGUI)
                                                    return

                                                if (Waypoints.Length() = 0) {
                                                    SetTimer, UpdateAllWaypoints, Off
                                                    return
                                                }

                                                ; Get current player coordinates
                                                GetCurrentCoordinates(playerX, playerY)
                                                if (playerX = "" || playerY = "") {
                                                    return
                                                }

                                                ; Get game window position
                                                WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                if (ErrorLevel) {
                                                    return
                                                }

                                                ; First pass: calculate distances and sort waypoints by proximity
                                                waypointDistances := []
                                                for waypointIndex, waypoint in Waypoints {
                                                    deltaX := waypoint.x - playerX
                                                    deltaY := waypoint.y - playerY
                                                    distance := Sqrt(deltaX**2 + deltaY**2)
                                                    waypointDistances.Push({index: waypointIndex, waypoint: waypoint, distance: distance})
                                                }

                                                ; Sort by distance (bubble sort for simplicity)
                                                Loop % waypointDistances.Length() - 1 {
                                                    i := A_Index
                                                    Loop % waypointDistances.Length() - i {
                                                        j := A_Index
                                                        if (waypointDistances[j].distance > waypointDistances[j+1].distance) {
                                                            temp := waypointDistances[j]
                                                            waypointDistances[j] := waypointDistances[j+1]
                                                            waypointDistances[j+1] := temp
                                                        }
                                                    }
                                                }

                                                ; Second pass: show only closest waypoints within range
                                                maxVisibleWaypoints := 12
                                                maxDistance := 500
                                                visibleCount := 0

                                                for index, waypointData in waypointDistances {
                                                    waypointIndex := waypointData.index
                                                    waypoint := waypointData.waypoint
                                                    distance := waypointData.distance
                                                    guiName := WaypointGUIs[waypointIndex]

                                                    ; Check if this waypoint should be visible
                                                    shouldShow := (ShowWaypoints && distance <= maxDistance && visibleCount < maxVisibleWaypoints)

                                                    if (shouldShow) {
                                                        visibleCount++

                                                        ; Create GUI if it doesn't exist yet
                                                        if (!guiName) {
                                                            CreateVisualWaypoint(waypointIndex, waypoint.x, waypoint.y)
                                                            guiName := WaypointGUIs[waypointIndex]
                                                        }

                                                        if (!guiName)
                                                            continue

                                                        ; Calculate delta in world coordinates
                                                        deltaX := waypoint.x - playerX
                                                        deltaY := waypoint.y - playerY

                                                        ; Use EXACT same calculation as nodes
                                                        ; Calculate Y scaling based on camera radius
                                                        if (CameraRadius <= 900) {
                                                            pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                        } else if (CameraRadius <= 1000) {
                                                            t := (CameraRadius - 900) / 100
                                                            pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                        } else if (CameraRadius <= 1500) {
                                                            t := (CameraRadius - 1000) / 500
                                                            pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                        } else {
                                                            t := (CameraRadius - 1500) / 500
                                                            pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                        }

                                                        ; Apply base scaling
                                                        scaledX := -deltaX * 1.21
                                                        scaledY := deltaY * pixelsPerGameUnitY ; POSITIVE - display is opposite of click conversion

                                                        ; Apply distance correction
                                                        scaledX := scaledX * 0.94
                                                        scaledY := scaledY * 1.19

                                                        ; Apply camera rotation (NO radian conversion)
                                                        cos_angle := Cos(-CameraAngle)
                                                        sin_angle := Sin(-CameraAngle)
                                                        rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                                        rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                        ; Convert to screen coordinates
                                                        screenX := winX + 516 + Round(rotatedX)
                                                        screenY := winY + 410 + Round(rotatedY)

                                                        ; Update waypoint position
                                                        waypointX := screenX - (WaypointSize // 2)
                                                        waypointY := screenY - (WaypointSize // 2)

                                                        Gui, %guiName%:Show, x%waypointX% y%waypointY% NA
                                                        ; Reapply click-through after show
                                                        WinGet, waypointHwnd, ID, %guiName%
                                                        if (waypointHwnd) {
                                                            MakeWindowClickThroughByHandle(waypointHwnd)
                                                        }
                                                    } else if (guiName) {
                                                        ; Hide waypoints that are too far or beyond the limit (only if GUI exists)
                                                        Gui, %guiName%:Hide
                                                    }
                                                }
                                            return

                                            ; ========= HEAL/DPS PATTERN FUNCTIONS =========

                                            LoadPatternsFromINI() {
                                                global CapturedTextINI, patterns, patternKeys, patternNames
                                                global dpsPatterns, dpsPatternKeys, dpsPatternNames
                                                global healPriorities, dpsPriorities
                                                global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2

                                                ; Load skill bar coordinates
                                                IniRead, loadedX1, %CapturedTextINI%, SkillbarArea, X1, %SkillBarX1%
                                                IniRead, loadedY1, %CapturedTextINI%, SkillbarArea, Y1, %SkillBarY1%
                                                IniRead, loadedX2, %CapturedTextINI%, SkillbarArea, X2, %SkillBarX2%
                                                IniRead, loadedY2, %CapturedTextINI%, SkillbarArea, Y2, %SkillBarY2%

                                                if (loadedX1 != "ERROR") SkillBarX1 := loadedX1
                                                    if (loadedY1 != "ERROR") SkillBarY1 := loadedY1
                                                    if (loadedX2 != "ERROR") SkillBarX2 := loadedX2
                                                    if (loadedY2 != "ERROR") SkillBarY2 := loadedY2

                                                ; Load all patterns from [Patterns] section (heal patterns)
                                                IniRead, sectionList, %CapturedTextINI%, Patterns
                                                if (sectionList = "ERROR" || sectionList = "") {
                                                    ;MsgBox, Error: Could not read Patterns section from INI!`n`nFile: %CapturedTextINI%
                                                    return
                                                }

                                                Loop, Parse, sectionList, `n, `r
                                                {
                                                    ; Each line is "key=value", extract both key name and value
                                                    line := A_LoopField
                                                    if (line = "")
                                                        continue

                                                    ; Find the = sign and split into key and value
                                                    equalPos := InStr(line, "=")
                                                    if (equalPos = 0)
                                                        continue

                                                    patternName := SubStr(line, 1, equalPos - 1)
                                                    patternText := SubStr(line, equalPos + 1)

                                                    if (patternName = "" || patternText = "")
                                                        continue

                                                    ; Store the pattern text directly from the line
                                                    patterns[patternName] := patternText

                                                    ; Still need to read assigned key and custom name from other sections
                                                    IniRead, assignedKey, %CapturedTextINI%, PatternKeys, %patternName%, ERROR
                                                    IniRead, customName, %CapturedTextINI%, PatternNames, %patternName%, ERROR

                                                    patternKeys[patternName] := (assignedKey != "ERROR") ? assignedKey : ""
                                                        patternNames[patternName] := (customName != "ERROR") ? customName : patternName
                                                    }

                                                    ; Load all patterns from [DPSPatterns] section (DPS patterns)
                                                    IniRead, dpsSectionList, %CapturedTextINI%, DPSPatterns
                                                    if (dpsSectionList != "ERROR" && dpsSectionList != "") {
                                                        Loop, Parse, dpsSectionList, `n, `r
                                                        {
                                                            ; Each line is "key=value", extract both key name and value
                                                            line := A_LoopField
                                                            if (line = "")
                                                                continue

                                                            ; Find the = sign and split into key and value
                                                            equalPos := InStr(line, "=")
                                                            if (equalPos = 0)
                                                                continue

                                                            patternName := SubStr(line, 1, equalPos - 1)
                                                            patternText := SubStr(line, equalPos + 1)

                                                            if (patternName = "" || patternText = "")
                                                                continue

                                                            ; Store the pattern text directly from the line
                                                            patterns[patternName] := patternText
                                                            dpsPatterns[patternName] := patternText ; Also store in DPS-specific container

                                                            ; Read assigned key and custom name from DPS sections
                                                            IniRead, assignedKey, %CapturedTextINI%, DPSPatternKeys, %patternName%, ERROR
                                                            IniRead, customName, %CapturedTextINI%, DPSPatternNames, %patternName%, ERROR

                                                            patternKeys[patternName] := (assignedKey != "ERROR") ? assignedKey : ""
                                                                patternNames[patternName] := (customName != "ERROR") ? customName : patternName
                                                            dpsPatternKeys[patternName] := (assignedKey != "ERROR") ? assignedKey : ""
                                                                dpsPatternNames[patternName] := (customName != "ERROR") ? customName : patternName
                                                            }
                                                        }

                                                        ; Load heal priorities
                                                        IniRead, healPriorityList, %CapturedTextINI%, HealPriorities, Order, ERROR
                                                        if (healPriorityList != "ERROR" && healPriorityList != "") {
                                                            healPriorities := []
                                                            Loop, Parse, healPriorityList, `,
                                                            {
                                                                if (A_LoopField != "")
                                                                    healPriorities.Push(A_LoopField)
                                                            }
                                                        }

                                                        ; Load DPS priorities
                                                        IniRead, dpsPriorityList, %CapturedTextINI%, DPSPriorities, Order, ERROR
                                                        if (dpsPriorityList != "ERROR" && dpsPriorityList != "") {
                                                            dpsPriorities := []
                                                            Loop, Parse, dpsPriorityList, `,
                                                            {
                                                                if (A_LoopField != "")
                                                                    dpsPriorities.Push(A_LoopField)
                                                            }
                                                        }

                                                        ; Display loading summary
                                                        patternCount := 0
                                                        for key, value in patterns {
                                                            patternCount++
                                                        }

                                                        healCount := healPriorities.Length()
                                                        dpsCount := dpsPriorities.Length()

                                                        ; Load resource patterns from resources.ini
                                                        LoadResourcePatterns()

                                                        ; Recount patterns after loading resources
                                                        patternCount := 0
                                                        for key, value in patterns {
                                                            patternCount++
                                                        }

                                                        if (patternCount > 0) {
                                                            ToolTip, Loaded %patternCount% total patterns`nHeals: %healCount% | DPS: %dpsCount%
                                                            SetTimer, ClearLoadTooltip, -2000
                                                        }
                                                    }

                                                    LoadResourcePatterns() {
                                                        global patterns, patternKeys, patternNames, ResourcesINI

                                                        ; Load patterns from resources.ini [Patterns] section
                                                        IniRead, resourceList, %ResourcesINI%, Patterns
                                                        if (resourceList = "ERROR" || resourceList = "") {
                                                            ; No resource patterns found, that's okay
                                                            return
                                                        }

                                                        resourceCount := 0
                                                        Loop, Parse, resourceList, `n, `r
                                                        {
                                                            line := A_LoopField
                                                            if (line = "")
                                                                continue

                                                            equalPos := InStr(line, "=")
                                                            if (equalPos = 0)
                                                                continue

                                                            patternName := SubStr(line, 1, equalPos - 1)
                                                            patternText := SubStr(line, equalPos + 1)

                                                            if (patternName = "" || patternText = "")
                                                                continue

                                                            ; Store the pattern text
                                                            patterns[patternName] := patternText
                                                            resourceCount++

                                                            ; Set defaults for keys and names if not already set
                                                            if (!patternKeys.HasKey(patternName))
                                                                patternKeys[patternName] := ""
                                                            if (!patternNames.HasKey(patternName))
                                                                patternNames[patternName] := patternName
                                                        }
                                                    }

                                                    EnsureDefaultPatterns() {
                                                        global ResourcesINI

                                                        ; Define resource patterns that should be in resources.ini
                                                        resourcePatterns := {}
                                                        resourcePatterns["bdnpc"] := "|<>*146$20.zzzzzzzzzzzzzzzzzzzU"
                                                        resourcePatterns["entrance5"] := "|<>BCB0A0-0.90$27.00S00M00k01k03U07007s0Ds1zs3zU7y0Tw1zk3y07s0D00S"
                                                        resourcePatterns["bd5quest"] := "|<>1D8AE7-0.90$65.Ud89000002H22EG000004a8YVpVlNUC9AV91AYHAUWGO2G2F8YF04Yu4Y4WT8W1t9W9894UF44GH2GEG94W89YW2YUoFl4EB9A"

                                                        ; Ensure resources.ini exists and contains the patterns
                                                        for patternName, patternText in resourcePatterns {
                                                            IniRead, existingPattern, %ResourcesINI%, Patterns, %patternName%, ERROR

                                                            if (existingPattern = "ERROR") {
                                                                ; Pattern doesn't exist, add it
                                                                IniWrite, %patternText%, %ResourcesINI%, Patterns, %patternName%
                                                            }
                                                        }
                                                    }

                                                    CapturePattern:
                                                        ; Instructions similar to adddpsskill
                                                        MsgBox, 64, Capture Pattern, INSTRUCTIONS:`n`n1. Click OK to start capture mode`n2. Wait 2 seconds for you to get ready`n3. Press '1' when the pattern you want to capture is visible on screen`n4. The pattern will be captured automatically`n5. You'll be prompted to name and save the pattern

                                                        ; Wait for user to be ready (like adddpsskill)
                                                        Sleep, 2000

                                                        ; Tell user to press 1 when ready
                                                        ToolTip, Press '1' when the pattern to capture is visible on screen
                                                        KeyWait, 1, D
                                                        ToolTip

                                                        ; Capture from screen using FindText (exactly like adddpsskill)
                                                        capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)
                                                        Clipboard := capturedText

                                                        ; Validate we got something
                                                        if (capturedText = "") {
                                                            MsgBox, 48, No Pattern Captured, No pattern was captured!`n`nTry again and make sure the pattern is visible when you press '1'.
                                                            return
                                                        }

                                                        ; Validate pattern format (should contain |<>)
                                                        if (!InStr(capturedText, "|<>")) {
                                                            MsgBox, 48, Invalid Pattern, The captured text doesn't appear to be a valid FindText pattern!`n`nCaptured text: %capturedText%
                                                            return
                                                        }

                                                        ; Ask user for pattern name
                                                        InputBox, patternName, Save Pattern, Enter a name for this pattern (e.g., "door" or "npc"):, , 400, 150
                                                        if (ErrorLevel) {
                                                            MsgBox, 48, Cancelled, Pattern capture cancelled.
                                                            return
                                                        }

                                                        ; Validate pattern name
                                                        if (patternName = "") {
                                                            MsgBox, 16, Error, Pattern name cannot be empty!
                                                            return
                                                        }

                                                        ; Remove spaces and special characters from pattern name
                                                        StringReplace, patternName, patternName, %A_Space%,, All
                                                        Loop {
                                                            if RegExMatch(patternName, "[^a-zA-Z0-9_]") {
                                                                StringReplace, patternName, patternName, %A_LoopField%,, All
                                                            } else {
                                                                break
                                                            }
                                                        }

                                                        if (patternName = "") {
                                                            MsgBox, 16, Error, Invalid pattern name! Use only letters, numbers, and underscores.
                                                            return
                                                        }

                                                        ; Save to resources.ini
                                                        global ResourcesINI
                                                        FileEncoding, UTF-8
                                                        IniWrite, %capturedText%, %ResourcesINI%, Patterns, %patternName%
                                                        FileEncoding

                                                        ; Reload patterns into memory
                                                        LoadResourcePatterns()

                                                        MsgBox, 64, Success!, Pattern saved to resources.ini as: %patternName%`n`nPattern: %capturedText%`n`nYou can now use this in commands like:`nloopclickuntilpatternfound,31,31,maxclickcount,%patternName%, 
                                                    return

                                                    ClearLoadTooltip:
                                                        ToolTip
                                                    return

                                                    LoopCastUntilMobDead() {
                                                        global TargetGameWindow, win1

                                                        ; Mob health pattern
                                                        mobHealth := "|<>##0.90$0/0/9D7B3E,1/0/111111,2/0/010101,3/0/760E33,4/0/C6053F,5/0/D75079,5/1/C6053F,5/2/AE0538,5/3/FF1268,5/4/010101"

                                                        if (!TargetGameWindow) {
                                                            return
                                                        }

                                                        ; Get window position for searching
                                                        WinGetPos, winX, winY,,, ahk_id %win1%
                                                        if (winX = "" || winY = "") {
                                                            return
                                                        }

                                                        ; Record start time for timeout
                                                        loopStartTime := A_TickCount
                                                        maxLoopTimeMs := 45000 ; 45 seconds max loop time
                                                        timeoutMs := 4000 ; 4 seconds for mob death confirmation
                                                        notFoundStartTime := "" ; Initialize the timer variable

                                                        ; Loop until mob health bar is NOT found for 4 seconds OR 45 seconds elapsed
                                                        Loop {
                                                            ; Check if we've been looping too long (45 seconds)
                                                            elapsedLoopTime := A_TickCount - loopStartTime
                                                            if (elapsedLoopTime >= maxLoopTimeMs) {
                                                                ; 45 seconds elapsed, exit loop even if mob still alive
                                                                ToolTip, Mob still alive after 45 seconds - exiting combat loop, 0, 0
                                                                    SetTimer, ClearTooltip, -3000
                                                                break
                                                            }

                                                            ; Check if mob health bar still exists
                                                            mobHealthFound := FindText(X, Y, winX, winY, winX + 1920, winY + 1080, 0, 0, mobHealth)

                                                            if (!mobHealthFound) {
                                                                ; Mob health not found - check if it's been gone for 4 seconds
                                                                if (notFoundStartTime = "") {
                                                                    notFoundStartTime := A_TickCount
                                                                }

                                                                elapsedNotFound := A_TickCount - notFoundStartTime
                                                                if (elapsedNotFound >= timeoutMs) {
                                                                    ; Mob has been dead for 4 seconds, exit loop
                                                                    break
                                                                }
                                                            } else {
                                                                ; Mob health found - reset the "not found" timer
                                                                notFoundStartTime := ""
                                                            }

                                                            ; Try to cast heal first (to keep player alive)
                                                            TryCastHealingSkill()
                                                            Sleep, 100

                                                            ; Try to cast DPS
                                                            TryCastDPSSkills()
                                                            Sleep, 100
                                                            TryCastCC()

                                                            ; Small delay before next iteration
                                                            Sleep, 200
                                                        }
                                                    }

                                                    CheckMobHealth() {
                                                        global win1

                                                        ; Mob health pattern (same as LoopCastUntilMobDead)
                                                        mobHealth := "|<>##0.90$0/0/9D7B3E,1/0/111111,2/0/010101,3/0/760E33,4/0/C6053F,5/0/D75079,5/1/C6053F,5/2/AE0538,5/3/FF1268,5/4/010101"

                                                        ; Get window position for searching
                                                        WinGetPos, winX, winY,,, ahk_id %win1%
                                                        if (winX = "" || winY = "") {
                                                            return false
                                                        }

                                                        ; Check if mob health bar exists
                                                        mobHealthFound := FindText(X, Y, winX, winY, winX + 1920, winY + 1080, 0, 0, mobHealth)

                                                    return mobHealthFound ? true : false
                                                }

                                                FarmUntilPattern(stopPattern) {
                                                    global win1, patterns

                                                    ; Check if pattern exists
                                                    if (patterns[stopPattern] = "") {
                                                        MsgBox, 0, Error, Pattern '%stopPattern%' not found in resources.ini!, 3
                                                    return
                                                }

                                                ToolTip, Starting farm mode. Press ESC to stop., 0, 0
                                                SetTimer, ClearTooltip, -2000

                                                ; Main farming loop
                                                Loop {
                                                    ; Check if stop pattern is found
                                                    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                                    if (winX != "" and winY != "") {
                                                        searchX2 := winX + winW
                                                        searchY2 := winY + winH
                                                        patternFound := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, patterns[stopPattern])

                                                        if (patternFound) {
                                                            ToolTip, Pattern '%stopPattern%' found! Stopping farm., 0, 0
                                                            SetTimer, ClearTooltip, -3000
                                                            return
                                                        }
                                                    }

                                                    ; Check if ESC was pressed
                                                    GetKeyState, escState, Escape, P
                                                    if (escState = "D") {
                                                        ToolTip, ESC pressed - stopping farm., 0, 0
                                                        SetTimer, ClearTooltip, -3000
                                                    return
                                                }

                                                ; Press Tab to target
                                                ToolTip, Tab targeting..., 0, 0
                                                ;WinActivate, ahk_id %win1%
                                                Sleep, 100
                                                ControlSend,, {Tab}, ahk_id %win1%
                                                Sleep, 500

                                                ; Check if mob health is found
                                                if (CheckMobHealth()) {
                                                    ToolTip, Mob found - attacking..., 0, 0

                                                    ; Call LoopCastUntilMobDead to kill the mob
                                                    LoopCastUntilMobDead()

                                                    ToolTip, Mob defeated. Looking for next target..., 0, 0
                                                        Sleep, 500
                                                } else {
                                                    ; No mob found
                                                    ToolTip, No mob targeted. Retrying..., 0, 0
                                                    Sleep, 1000
                                                }

                                                ; Small delay before next iteration
                                                Sleep, 200
                                            }
                                        }

                                        ReEnterBD5() {
                                            global win1

                                            ; BD NPC pattern
                                            bdnpc := "|<>FF8400-0.90$71.w000U00E02004001000004004002000008000wD4S7GL0FsE24V92FYl0Y97Y92G4V921821Dm4Y92G42A22E498G4Y84604U8GEY98E820F2EYV8mEUG4j1sS8wCYV0XkU00000100000000001200000000001s00002"

                                            ; Entrance pattern
                                            entrance5 := "|<>BCB0A0-0.90$27.0007s000UUkk42NN0k+247lEFU3+2009EE01+200FDD0w000000000000000000000000000000000000000000000000040000U"

                                            ; Get window position for searching
                                            WinGetPos, winX, winY,,, ahk_id %win1%
                                            if (winX = "" || winY = "") {
                                                MsgBox, 0, Error, Could not get window position for BD5 re-entry!, 2
                                                    return
                                            }

                                            ; Main loop: keep trying NPC -> Entrance sequence
                                            maxMainAttempts := 10 ; Try the whole sequence up to 10 times

                                            Loop, %maxMainAttempts% {
                                                mainAttempt := A_Index

                                                ; Step 1: Loop search for BD NPC
                                                npcFound := false
                                                Loop, 100 {
                                                    npcResult := FindText(npcX, npcY, winX, winY, winX + 1920, winY + 1080, 0, 0, bdnpc)

                                                    if (npcResult) {
                                                        npcFound := true
                                                        ; Double-click 5 pixels below the found location
                                                        clickX := npcX - winX
                                                        clickY := npcY - winY + 13

                                                        ; Use SendMessage for double click
                                                        lParam := (clickY << 16) | (clickX & 0xFFFF)

                                                        ; First click
                                                        SendMessage, 0x0200, 0, %lParam%, , ahk_id %win1% ; WM_MOUSEMOVE
                                                        Sleep, 20
                                                        SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                                        Sleep, 20
                                                        SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                                        Sleep, 50

                                                        ; Second click
                                                        SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                                        Sleep, 20
                                                        SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                                        Sleep, 500
                                                        break
                                                    }

                                                    Sleep, 100
                                                }

                                                if (!npcFound) {
                                                    MsgBox, 0, Error, BD NPC not found after 100 attempts!, 2
                                                    return
                                                }

                                                ; Step 2: Loop search for entrance
                                                entranceFound := false
                                                Loop, 100 {
                                                    entranceResult := FindText(entranceX, entranceY, winX, winY, winX + 1920, winY + 1080, 0, 0, entrance5)

                                                    if (entranceResult) {
                                                        entranceFound := true
                                                        ; Click at the entrance location
                                                        relEntranceX := entranceX - winX
                                                        relEntranceY := entranceY - winY
                                                        lParam := (relEntranceY << 16) | (relEntranceX & 0xFFFF)

                                                        SendMessage, 0x0200, 0, %lParam%, , ahk_id %win1% ; WM_MOUSEMOVE
                                                        Sleep, 20
                                                        SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                                        Sleep, 20
                                                        SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                                        Sleep, 100
                                                        ; Success! Exit the main loop
                                                    return
                                                }

                                                Sleep, 100
                                            }

                                            ; If entrance not found, loop back to search for NPC again
                                            if (!entranceFound) {
                                                tooltipMsg := "Entrance not found (attempt " . mainAttempt . "/" . maxMainAttempts . "), retrying from NPC..."
                                                ToolTip, %tooltipMsg%, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                Sleep, 1000
                                                ; Continue to next iteration of main loop
                                            }
                                        }

                                        ; If we get here, all attempts failed
                                        failMsg := "BD5 entrance not found after " . maxMainAttempts . " complete attempts!"
                                        MsgBox, 0, Error, %failMsg%, 2
                                    }

                                    LoopClickUntilPatternMissing(nodeNum, patternNameOrText, maxClicks, backSteps) {
                                        global win1, patterns, Waypoints, CurrentWaypoint

                                        ; Check if patternNameOrText is an inline pattern (starts with |<) or a pattern name
                                        if (InStr(patternNameOrText, "|<") = 1) {
                                            ; It's an inline pattern text
                                            pattern := patternNameOrText
                                            patternDisplayName := "inline pattern"
                                        } else {
                                            ; It's a pattern name, load from patterns array
                                            pattern := patterns[patternNameOrText]
                                            patternDisplayName := patternNameOrText

                                            if (pattern = "") {
                                                MsgBox, 0, Error, Pattern '%patternNameOrText%' not found in patterns (check CapturedText.ini or resources.ini)!, 3
                                                return
                                            }
                                        }

                                        ; Get window position for searching
                                        WinGetPos, winX, winY,,, ahk_id %win1%
                                        if (winX = "" || winY = "") {
                                            MsgBox, 0, Error, Could not get window position!, 2
                                            return
                                        }

                                        ; Save the original waypoint to return to
                                        originalWaypoint := CurrentWaypoint

                                        ; First, verify the pattern actually exists before we start
                                        patternResult := FindText(px, py, winX, winY, winX + 1920, winY + 1080, 0, 0, pattern)
                                        if (!patternResult) {
                                            MsgBox, 0, Error, Pattern '%patternDisplayName%' not found at start! Cannot proceed., 3
                                            return
                                        }

                                        ToolTip, Pattern found! Starting click loop..., 0, 0
                                            Sleep, 1000

                                        ; Main retry loop (in case we need to move back and retry)
                                        maxRetries := 5 ; Maximum number of back-and-retry attempts

                                        Loop, %maxRetries% {
                                            retryAttempt := A_Index

                                            tooltipMsg := "Retry attempt " . retryAttempt . "/" . maxRetries
                                            ToolTip, %tooltipMsg%, 0, 0
                                            SetTimer, ClearTooltip, -2000

                                            ; Click the node up to maxClicks times
                                            clickCount := 0
                                            Loop, %maxClicks% {
                                                clickCount++

                                                tooltipMsg := "Clicking node " . nodeNum . " (click " . clickCount . "/" . maxClicks . ")"
                                                ToolTip, %tooltipMsg%, 0, 0

                                                ; Click the node (using worldclick logic)
                                                ClickAtNode(nodeNum)
                                                Sleep, 500

                                                ; Small delay to let the UI update before checking pattern
                                                Sleep, 200

                                                ; Check if pattern still exists AFTER the click
                                                patternResult := FindText(px, py, winX, winY, winX + 1920, winY + 1080, 0, 0, pattern)

                                                if (!patternResult) {
                                                    ; Pattern is gone! Success
                                                    successMsg := "Pattern '" . patternDisplayName . "' cleared after " . clickCount . " click(s)!"
                                                    ToolTip, %successMsg%, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                } else {
                                                    tooltipMsg := "Pattern still found after click " . clickCount
                                                    ToolTip, %tooltipMsg%, 0, 0
                                                    Sleep, 500
                                                }
                                            }

                                            ; Pattern still found after maxClicks
                                            ; Check one more time after a short delay in case UI is updating
                                            Sleep, 1000
                                            patternResult := FindText(px, py, winX, winY, winX + 1920, winY + 1080, 0, 0, pattern)

                                            if (!patternResult) {
                                                ; Pattern is gone now! Success
                                                successMsg := "Pattern '" . patternDisplayName . "' cleared after delay!"
                                                ToolTip, %successMsg%, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Pattern still found after maxClicks and delay
                                            ; Move back by backSteps waypoints and try again
                                            if (retryAttempt < maxRetries) {
                                                tooltipMsg := "Pattern still found after " . maxClicks . " clicks (retry " . retryAttempt . "/" . maxRetries . "), moving back " . backSteps . " waypoint(s)..."
                                                ToolTip, %tooltipMsg%, 0, 0
                                                SetTimer, ClearTooltip, -3000

                                                ; Calculate target waypoint to move back to
                                                backWaypoint := originalWaypoint - backSteps
                                                if (backWaypoint < 1) {
                                                    backWaypoint := 1
                                                }

                                                ; Get the coordinates of the back waypoint
                                                if (backWaypoint <= Waypoints.Length()) {
                                                    backWaypointObj := Waypoints[backWaypoint]
                                                    backX := backWaypointObj.x
                                                    backY := backWaypointObj.y

                                                    ; Stop any current travel
                                                    IsTraveling := false
                                                    SetTimer, TravelLoop, Off
                                                    Sleep, 200

                                                    ; Navigate back using GoToWaypoint
                                                    tooltipMsg := "Moving to waypoint " . backWaypoint . "..."
                                                    ToolTip, %tooltipMsg%, 0, 0
                                                    GoToWaypoint(backWaypoint)

                                                    ; Wait for arrival by checking coordinates
                                                    Loop, 50 { ; 5 second timeout (50 * 100ms)
                                                        GetCurrentCoordinates(currentX, currentY)
                                                        if (Abs(currentX - backX) <= DistanceToleranceX && Abs(currentY - backY) <= DistanceToleranceY) {
                                                            tooltipMsg := "Arrived at waypoint " . backWaypoint
                                                            ToolTip, %tooltipMsg%, 0, 0
                                                            break
                                                        }
                                                        Sleep, 100
                                                    }

                                                    Sleep, 1000
                                                }

                                                ; Get the coordinates of the original waypoint
                                                if (originalWaypoint <= Waypoints.Length()) {
                                                    originalWaypointObj := Waypoints[originalWaypoint]
                                                    origX := originalWaypointObj.x
                                                    origY := originalWaypointObj.y

                                                    ; Stop travel again to be safe
                                                    IsTraveling := false
                                                    SetTimer, TravelLoop, Off
                                                    Sleep, 200

                                                    ; Now move forward to the original waypoint
                                                    tooltipMsg := "Returning to waypoint " . originalWaypoint . "..."
                                                    ToolTip, %tooltipMsg%, 0, 0
                                                    GoToWaypoint(originalWaypoint)

                                                    ; Wait for arrival by checking coordinates
                                                    Loop, 50 { ; 5 second timeout
                                                        GetCurrentCoordinates(currentX, currentY)
                                                        if (Abs(currentX - origX) <= DistanceToleranceX && Abs(currentY - origY) <= DistanceToleranceY) {
                                                            tooltipMsg := "Arrived back at waypoint " . originalWaypoint
                                                            ToolTip, %tooltipMsg%, 0, 0
                                                            break
                                                        }
                                                        Sleep, 100
                                                    }

                                                    Sleep, 1000
                                                }
                                                ; Continue to next retry iteration
                                            }
                                        }

                                        ; If we get here, all retries failed
                                        failMsg := "Pattern '" . patternDisplayName . "' still found after " . maxRetries . " retry attempts!"
                                        MsgBox, 0, Error, %failMsg%, 3
                                    }

                                    ; Function to find and click a pattern directly (without nodes)
                                    ClickPattern(patternNameOrText, useControlClick := false) {
                                        global win1, patterns

                                        ; Check if patternNameOrText is an inline pattern (starts with |<) or a pattern name
                                        if (InStr(patternNameOrText, "|<") = 1) {
                                            ; It's an inline pattern text
                                            patternsToSearch := []
                                            patternsToSearch.Push(patternNameOrText)
                                            patternCount := 1
                                            patternDisplayName := "inline pattern"
                                        } else {
                                            ; It's a pattern name, collect all variations
                                            patternsToSearch := []
                                            patternCount := 0
                                            patternDisplayName := patternNameOrText

                                            ; First, check for exact match
                                            if (patterns[patternNameOrText] != "") {
                                                patternsToSearch.Push(patterns[patternNameOrText])
                                                patternCount++
                                            }

                                            ; Then check for numbered variations (pattern_1, pattern_2, etc.)
                                            variationNum := 1
                                            Loop {
                                                variationName := patternNameOrText . "_" . variationNum
                                                if (patterns[variationName] != "") {
                                                    patternsToSearch.Push(patterns[variationName])
                                                    patternCount++
                                                    variationNum++
                                                } else {
                                                    break
                                                }
                                            }

                                            ; If no patterns found at all, show error
                                            if (patternCount = 0) {
                                                ; Show what patterns ARE available
                                                availList := ""
                                                count := 0
                                                for pName in patterns {
                                                    availList .= pName . ", "
                                                    count++
                                                    if (count >= 10)
                                                        break
                                                }
                                                MsgBox, 0, Error, Pattern '%patternNameOrText%' not found!`n`nAvailable patterns: %availList%`n`nCheck CapturedText.ini or resources.ini under [Patterns] section., 5
                                                return false
                                            }
                                        }

                                        ; Get window position for searching
                                        WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                        if (winX = "" || winY = "") {
                                            MsgBox, 0, Error, Could not get window position!, 2
                                            return false
                                        }

                                        ; Calculate search area
                                        searchX2 := winX + winW
                                        searchY2 := winY + winH

                                        ; Search for pattern
                                        ToolTip, Searching for pattern '%patternDisplayName%'..., 0, 0
                                            patternFound := false

                                        for index, pattern in patternsToSearch {
                                            patternResult := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)

                                            if (patternResult) {
                                                patternFound := true
                                                break
                                            }
                                        }

                                        if (patternFound) {
                                            ; Pattern found! Click at the location
                                            if (useControlClick) {
                                                ToolTip, Pattern '%patternDisplayName%' found at screen (%px%`,%py%)! Control-clicking..., 0, 0
                                            } else {
                                                ToolTip, Pattern '%patternDisplayName%' found at screen (%px%`,%py%)! Clicking..., 0, 0
                                            }

                                            ; Activate the window first
                                            ;WinActivate, ahk_id %win1%
                                            Sleep, 50

                                            ; FindText returns SCREEN coordinates (px, py) - the CENTER of the found pattern
                                            ; Convert to window-relative coordinates and offset by -24 pixels on Y axis
                                            relativeX := px - winX
                                            relativeY := (py - winY) - 24

                                            ; Use SendMessage to move mouse and click
                                            lParam := (relativeY << 16) | (relativeX & 0xFFFF)

                                            ; Send mouse move
                                            SendMessage, 0x0200, 0, %lParam%, , ahk_id %win1% ; WM_MOUSEMOVE
                                            Sleep, 20

                                            ; Click at that location
                                            if (useControlClick) {
                                                ; Control+Click: include MK_CONTROL (0x0008) flag
                                                wParam := 0x0001 | 0x0008 ; MK_LBUTTON | MK_CONTROL
                                                SendMessage, 0x0201, %wParam%, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN with Control
                                                Sleep, 20
                                                SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                            } else {
                                                ; Regular click
                                                SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                                Sleep, 20
                                                SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                            }
                                            Sleep, 100

                                            ToolTip, Pattern found and clicked!, 0, 0
                                            SetTimer, ClearTooltip, -2000
                                            return true
                                        } else {
                                            ToolTip, Pattern '%patternDisplayName%' not found on screen!, 0, 0
                                            SetTimer, ClearTooltip, -2000
                                            return false
                                        }
                                    }

                                    CheckPatternExists(patternNameOrText) {
                                        global win1, patterns

                                        ; Check if patternNameOrText is an inline pattern (starts with |<) or a pattern name
                                        if (InStr(patternNameOrText, "|<") = 1) {
                                            ; It's an inline pattern text
                                            patternsToSearch := []
                                            patternsToSearch.Push(patternNameOrText)
                                            patternCount := 1
                                        } else {
                                            ; It's a pattern name, collect all variations
                                            patternsToSearch := []
                                            patternCount := 0

                                            ; First, check for exact match
                                            if (patterns[patternNameOrText] != "") {
                                                patternsToSearch.Push(patterns[patternNameOrText])
                                                patternCount++
                                            }

                                            ; Then check for numbered variations (pattern_1, pattern_2, etc.)
                                            variationNum := 1
                                            Loop {
                                                variationName := patternNameOrText . "_" . variationNum
                                                if (patterns[variationName] != "") {
                                                    patternsToSearch.Push(patterns[variationName])
                                                    patternCount++
                                                    variationNum++
                                                } else {
                                                    break
                                                }
                                            }

                                            ; If no patterns found at all, return false
                                            if (patternCount = 0) {
                                                return false
                                            }
                                        }

                                        ; Get window position for searching
                                        WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                        if (winX = "" || winY = "") {
                                            return false
                                        }

                                        ; Calculate search area
                                        searchX2 := winX + winW
                                        searchY2 := winY + winH

                                        ; Search for pattern
                                        for index, pattern in patternsToSearch {
                                            patternResult := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)

                                            if (patternResult) {
                                                return true
                                            }
                                        }

                                        return false
                                    }

                                    LoopClickUntilPatternFound(nodeNum1, nodeNum2, maxclicks, patternNameOrText) {
                                        global win1, patterns

                                        ; Check if patternNameOrText is an inline pattern (starts with |<) or a pattern name
                                        if (InStr(patternNameOrText, "|<") = 1) {
                                            ; It's an inline pattern text
                                            patternsToSearch := []
                                            patternsToSearch.Push(patternNameOrText)
                                            patternCount := 1
                                            patternDisplayName := "inline pattern"
                                        } else {
                                            ; It's a pattern name, collect all variations
                                            patternsToSearch := []
                                            patternCount := 0
                                            patternDisplayName := patternNameOrText

                                            ; First, check for exact match
                                            if (patterns[patternNameOrText] != "") {
                                                patternsToSearch.Push(patterns[patternNameOrText])
                                                patternCount++
                                            }

                                            ; Then check for numbered variations (pattern_1, pattern_2, etc.)
                                            variationNum := 1
                                            Loop {
                                                variationName := patternNameOrText . "_" . variationNum
                                                if (patterns[variationName] != "") {
                                                    patternsToSearch.Push(patterns[variationName])
                                                    patternCount++
                                                    variationNum++
                                                } else {
                                                    break
                                                }
                                            }

                                            ; If no patterns found at all, show error
                                            if (patternCount = 0) {
                                                ; Show what patterns ARE available
                                                availList := ""
                                                count := 0
                                                for pName in patterns {
                                                    availList .= pName . ", "
                                                    count++
                                                    if (count >= 10)
                                                        break
                                                }
                                                MsgBox, 0, Error, Pattern '%patternNameOrText%' not found!`n`nAvailable patterns: %availList%`n`nCheck CapturedText.ini or resources.ini under [Patterns] section.`n`nOr use inline pattern starting with |<, 5
                                                return
                                            }
                                        }
                                        ; Get window position for searching
                                        WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                        if (winX = "" || winY = "") {
                                            MsgBox, 0, Error, Could not get window position!, 2
                                            return
                                        }

                                        ; Calculate search area
                                        searchX2 := winX + winW
                                        searchY2 := winY + winH

                                        clickCount := 0
                                        Loop {
                                            clickCount++
                                            if (clickCount > maxclicks) {
                                                ToolTip, Max click count (%maxclicks%) reached. Pattern not found., 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Click node 1
                                            ToolTip, Clicking node %nodeNum1%..., 0, 0
                                            ClickAtNode(nodeNum1)
                                            Sleep, 500

                                            ; Check if any pattern variation appeared
                                            ToolTip, Searching for pattern '%patternDisplayName%'..., 0, 0
                                                patternFound := false

                                            for index, pattern in patternsToSearch {
                                                patternResult := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)
                                                if (patternResult) {
                                                    patternFound := true
                                                    break
                                                }
                                                else {
                                                    ToolTip, failed to find pattern variation %index%..., 0, 0
                                                }
                                            }

                                            if (patternFound) {
                                                ToolTip, Pattern '%patternDisplayName%' found!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Pattern not found yet, click node 2 (if different from node 1)
                                            if (nodeNum2 != nodeNum1) {
                                                ToolTip, Clicking node %nodeNum2%..., 0, 0
                                                ClickAtNode(nodeNum2)
                                                Sleep, 500

                                                ; Check if any pattern variation appeared after node 2 click
                                                patternFound := false
                                                for index, pattern in patternsToSearch {
                                                    patternResult := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)
                                                    if (patternResult) {
                                                        patternFound := true
                                                        break
                                                    }
                                                }
                                                if (patternFound) {
                                                    ToolTip, Pattern '%patternDisplayName%' found!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return
                                                }
                                            }

                                            Sleep, 300
                                        }
                                    }

                                    LoopSearchUntilPatternFound(tries, patternNameOrText) {
                                        global win1, patterns

                                        ; Check if inline pattern or pattern name
                                        if (InStr(patternNameOrText, "|<") = 1) {
                                            patternsToSearch := [patternNameOrText]
                                            patternDisplayName := "inline pattern"
                                        } else {
                                            patternsToSearch := []
                                            patternDisplayName := patternNameOrText

                                            if (patterns[patternNameOrText] != "")
                                                patternsToSearch.Push(patterns[patternNameOrText])

                                            variationNum := 1
                                            Loop {
                                                variationName := patternNameOrText . "_" . variationNum
                                                if (patterns[variationName] != "") {
                                                    patternsToSearch.Push(patterns[variationName])
                                                    variationNum++
                                                } else {
                                                    break
                                                }
                                            }

                                            if (patternsToSearch.Length() = 0) {
                                                ToolTip, Pattern '%patternNameOrText%' not found!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return false
                                            }
                                        }

                                        WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                        if (winX = "" || winY = "")
                                            return false

                                        searchX2 := winX + winW
                                        searchY2 := winY + winH

                                        Loop, %tries% {
                                            ToolTip, Searching for '%patternDisplayName%' (try %A_Index% of %tries%), 0, 0

                                            for index, pattern in patternsToSearch {
                                                if (FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)) {
                                                    ToolTip, Pattern '%patternDisplayName%' found!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                    return true
                                                }
                                            }
                                            Sleep, 100
                                        }

                                        ToolTip, Pattern '%patternDisplayName%' not found after %tries% tries, 0, 0
                                        SetTimer, ClearTooltip, -2000
                                        return false
                                    }

                                    ClickAtNode(nodeNum) {
                                        global TargetNodes

                                        ; Find the node with the matching ID
                                        targetNode := ""
                                        for index, node in TargetNodes {
                                            if (node.id = nodeNum) {
                                                targetNode := node
                                                break
                                            }
                                        }

                                        if (targetNode = "") {
                                            MsgBox, 0, Error, Node #%nodeNum% not found!, 2
                                            return
                                        }

                                        ; Use ClickAtWorldCoordinates for precise clicking with offset correction
                                        ClickAtWorldCoordinates(targetNode.worldX, targetNode.worldY)
                                    }

                                    holyground(delay, key, nodeNum1, nodeNum2="", nodeNum3="") {
                                        global TargetNodes
                                        sleep, %delay%
                                        ControlSend,, {%key%}, ahk_id %win1%

                                        ; Determine which node to use
                                        if (nodeNum2 = "" && nodeNum3 = "") {
                                            ; Only one node provided, use it directly
                                            nodeNum := nodeNum1
                                        } else {
                                            ; Multiple nodes provided, randomly select one
                                            Random, randomChoice, 1, 3
                                            if (randomChoice = 1)
                                                nodeNum := nodeNum1
                                            else if (randomChoice = 2)
                                                nodeNum := nodeNum2
                                            else
                                                nodeNum := nodeNum3
                                        }

                                        ; Find the node with the matching ID
                                        targetNode := ""
                                        for index, node in TargetNodes {
                                            if (node.id = nodeNum) {
                                                targetNode := node
                                                break
                                            }
                                        }

                                        if (targetNode = "") {
                                            MsgBox, 0, Error, Node #%nodeNum% not found!, 2
                                            return
                                        }

                                        ; Use ClickAtWorldCoordinates for precise clicking with offset correction
                                        ClickAtWorldCoordinates(targetNode.worldX, targetNode.worldY)
                                    }
                                    ShiftClickAtNode(nodeNum) {
                                        global TargetNodes, TargetGameWindow, CameraAngle, CameraRadius

                                        ; Find the node with the matching ID
                                        targetNode := ""
                                        for index, node in TargetNodes {
                                            if (node.id = nodeNum) {
                                                targetNode := node
                                                break
                                            }
                                        }

                                        if (targetNode = "") {
                                            MsgBox, 0, Error, Node #%nodeNum% not found!, 2
                                            return
                                        }

                                        if (!TargetGameWindow) {
                                            return
                                        }

                                        ; Get current position
                                        GetCurrentCoordinates(currentX, currentY)
                                        if (currentX = "" || currentY = "") {
                                            return
                                        }

                                        ; Calculate delta from current position to target
                                        deltaX := targetNode.worldX - currentX
                                        deltaY := targetNode.worldY - currentY

                                        ; Use EXACT same pixel conversion as ClickAtWorldCoordinates
                                        pixelsPerGameUnitX := 1.21

                                        ; Y-axis: piecewise linear based on camera radius
                                        if (CameraRadius <= 900) {
                                            pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                        } else if (CameraRadius <= 1000) {
                                            t := (CameraRadius - 900) / 100
                                            pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                        } else if (CameraRadius <= 1500) {
                                            t := (CameraRadius - 1000) / 500
                                            pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                        } else {
                                            t := (CameraRadius - 1500) / 500
                                            pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                        }

                                        ; Scale the deltas
                                        scaledX := -deltaX * pixelsPerGameUnitX
                                        scaledY := -deltaY * pixelsPerGameUnitY

                                        ; Apply distance correction
                                        scaledX := scaledX * 0.94
                                        scaledY := scaledY * 1.19

                                        ; Apply camera rotation
                                        cos_angle := Cos(-CameraAngle)
                                        sin_angle := Sin(-CameraAngle)

                                        rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                        rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                        ; Use the same base click position
                                        baseClickX := 516
                                        baseClickY := 410

                                        ; Calculate final screen coordinates with offset correction
                                        clickX := baseClickX + Round(rotatedX) - 7
                                        clickY := baseClickY - Round(rotatedY) - 29

                                        ; Activate window
                                        ;WinActivate, ahk_id %TargetGameWindow%
                                        Sleep, 50

                                        ; Send click messages with MK_SHIFT flag (0x0004) in wParam
                                        ; wParam includes both the button state (MK_LBUTTON = 0x0001) and modifier (MK_SHIFT = 0x0004)
                                        wParam := 0x0001 | 0x0004 ; MK_LBUTTON | MK_SHIFT
                                        lParam := (clickY << 16) | (clickX & 0xFFFF)

                                        SendMessage, 0x0201, %wParam%, %lParam%, , ahk_id %TargetGameWindow% ; WM_LBUTTONDOWN with Shift
                                        Sleep, 20
                                        SendMessage, 0x0202, 0, %lParam%, , ahk_id %TargetGameWindow% ; WM_LBUTTONUP
                                        Sleep, 30
                                    }

                                    MakeWindowClickThrough(guiName) {
                                        ; Make a GUI window click-through by setting WS_EX_TRANSPARENT
                                        WinGet, hwnd, ID, ahk_class AutoHotkeyGUI ahk_exe %A_ScriptName%
                                        WinGetTitle, winTitle, ahk_id %hwnd%

                                        ; Try to get the handle by the GUI name directly
                                        Gui, %guiName%:+HwndguiHwnd

                                        if (guiHwnd) {
                                            ; Get current extended style
                                            exStyle := DllCall("GetWindowLong", "Ptr", guiHwnd, "Int", -20, "UInt")
                                            ; Add WS_EX_TRANSPARENT (0x20) and WS_EX_LAYERED (0x80000)
                                            exStyle := exStyle | 0x20 | 0x80000
                                            ; Set the new extended style
                                            DllCall("SetWindowLong", "Ptr", guiHwnd, "Int", -20, "UInt", exStyle)
                                        } else {
                                            ; Fallback: try by window title
                                            WinGet, hwnd, ID, %guiName%
                                            if (hwnd) {
                                                exStyle := DllCall("GetWindowLong", "Ptr", hwnd, "Int", -20, "UInt")
                                                exStyle := exStyle | 0x20 | 0x80000
                                                DllCall("SetWindowLong", "Ptr", hwnd, "Int", -20, "UInt", exStyle)
                                            }
                                        }
                                    }

                                    MakeWindowClickThroughByHandle(hwnd) {
                                        ; Make a window click-through using its handle
                                        static callCount := 0

                                        if (hwnd) {
                                            callCount++

                                            ; Try using WinSet ExStyle instead of DllCall
                                            WinSet, ExStyle, +0x20, ahk_id %hwnd% ; WS_EX_TRANSPARENT
                                            WinSet, ExStyle, +0x80000, ahk_id %hwnd% ; WS_EX_LAYERED

                                            ; Force window update
                                            WinSet, Redraw,, ahk_id %hwnd%

                                            if (callCount = 1) {
                                                ToolTip, Click-through applied using WinSet, 0, 0
                                                SetTimer, ClearTooltip, -3000
                                            }
                                        }
                                    }

                                    ; Call this label from your GUI button
                                    ; Make sure TargetGameWindow is set first from your SelectWindow routine
                                    ShowThumbnailView:
                                        global hSource, hThumbnail, thumbnailWidth, thumbnailHeight, hGui, hThumb, windowVisible, thumbnailIsOpen

                                        ; Toggle: if thumbnail is already open, close it
                                        if (thumbnailIsOpen) {
                                            Gosub, ThumbnailGuiClose
                                            return
                                        }

                                        ; Check if window is selected
                                        if (!TargetGameWindow) {
                                            MsgBox, Please select a window first!
                                            return
                                        }

                                        ; Set source window
                                        hSource := TargetGameWindow

                                        ; Configuration
                                        thumbnailWidth := 400
                                        thumbnailHeight := 300

                                        ; Verify window exists
                                        if (!WinExist("ahk_id " hSource)) {
                                            MsgBox, Window not found!
                                            return
                                        }

                                        ; Keep the original window visible
                                        windowVisible := true
                                        thumbnailIsOpen := true

                                        ; Create GUI for thumbnail
                                        ; Create GUI for thumbnail
                                        ; Create GUI for thumbnail
                                        ; Create GUI for thumbnail
                                        Gui, Thumbnail:New, +AlwaysOnTop +Caption +Resize -MaximizeBox
                                        Gui, Thumbnail:Add, Text, vThumbControl w%thumbnailWidth% h%thumbnailHeight% 0x4E Background000000 gThumbnailClick
                                        Gui, Thumbnail:Show, w%thumbnailWidth% h%thumbnailHeight%, Game Thumbnail

                                        ; Get the GUI window handle and control handle
                                        Gui, Thumbnail:+LastFound
                                        hGui := WinExist()
                                        GuiControlGet, hThumb, Hwnd, ThumbControl
                                        ; Enable diagonal-only resize

                                        ; Update thumbnailWidth/Height to actual client area size
                                        VarSetCapacity(RECT, 16, 0)
                                        DllCall("GetClientRect", "Ptr", hGui, "Ptr", &RECT)
                                        thumbnailWidth := NumGet(RECT, 8, "Int")
                                        thumbnailHeight := NumGet(RECT, 12, "Int")

                                        ; Small delay to ensure GUI is ready
                                        Sleep, 100

                                        ; Register thumbnail
                                        result := DllCall("dwmapi\DwmRegisterThumbnail", "Ptr", hGui, "Ptr", hSource, "Ptr*", hThumbnail)

                                        if (result != 0 || !hThumbnail) {
                                            MsgBox, Failed to register thumbnail! Error: %result%
                                            WinShow, ahk_id %hSource% ; Restore window on error
                                            Gui, Thumbnail:Destroy
                                            return
                                        }

                                        ; Update thumbnail properties
                                        Gosub, UpdateThumbnailNow

                                        ; Set timer to keep updating
                                        SetTimer, UpdateThumbnailNow, 1000
                                    return

                                    UpdateThumbnailNow:
                                        global hThumbnail, thumbnailWidth, thumbnailHeight, hSource

                                        if (!hThumbnail)
                                            return

                                        ; Get source window full size
                                        VarSetCapacity(RECT, 16, 0)
                                        DllCall("GetWindowRect", "Ptr", hSource, "Ptr", &RECT)
                                        srcWidth := NumGet(RECT, 8, "Int") - NumGet(RECT, 0, "Int")
                                        srcHeight := NumGet(RECT, 12, "Int") - NumGet(RECT, 4, "Int")

                                        ; Fill entire thumbnail area
                                        newWidth := thumbnailWidth
                                        newHeight := thumbnailHeight

                                        ; Set thumbnail properties
                                        VarSetCapacity(DWM_THUMBNAIL_PROPERTIES, 40, 0)
                                        NumPut(0x1F, DWM_THUMBNAIL_PROPERTIES, 0, "UInt") ; dwFlags
                                        NumPut(0, DWM_THUMBNAIL_PROPERTIES, 4, "Int") ; rcDestination.left
                                        NumPut(0, DWM_THUMBNAIL_PROPERTIES, 8, "Int") ; rcDestination.top
                                        NumPut(newWidth, DWM_THUMBNAIL_PROPERTIES, 12, "Int") ; rcDestination.right
                                        NumPut(newHeight, DWM_THUMBNAIL_PROPERTIES, 16, "Int") ; rcDestination.bottom
                                        NumPut(0, DWM_THUMBNAIL_PROPERTIES, 20, "Int") ; rcSource.left
                                        NumPut(0, DWM_THUMBNAIL_PROPERTIES, 24, "Int") ; rcSource.top
                                        NumPut(srcWidth, DWM_THUMBNAIL_PROPERTIES, 28, "Int") ; rcSource.right
                                        NumPut(srcHeight, DWM_THUMBNAIL_PROPERTIES, 32, "Int") ; rcSource.bottom
                                        NumPut(255, DWM_THUMBNAIL_PROPERTIES, 36, "UChar") ; opacity
                                        NumPut(1, DWM_THUMBNAIL_PROPERTIES, 37, "UChar") ; fVisible
                                        NumPut(0, DWM_THUMBNAIL_PROPERTIES, 38, "UChar") ; fSourceClientAreaOnly

                                        DllCall("dwmapi\DwmUpdateThumbnailProperties", "Ptr", hThumbnail, "Ptr", &DWM_THUMBNAIL_PROPERTIES)
                                    return

                                    UpdateThumbnailView:
                                        ; Redirect to the actual update function
                                        Gosub, UpdateThumbnailNow
                                    return

                                    ThumbnailGuiSize:
                                        ; Get actual client area size (excluding title bar and borders)
                                        Gui, Thumbnail:+LastFound
                                        VarSetCapacity(RECT, 16, 0)
                                        DllCall("GetClientRect", "Ptr", WinExist(), "Ptr", &RECT)
                                        thumbnailWidth := NumGet(RECT, 8, "Int")
                                        thumbnailHeight := NumGet(RECT, 12, "Int")

                                        GuiControl, Move, ThumbControl, w%thumbnailWidth% h%thumbnailHeight%
                                        Gosub, UpdateThumbnailNow
                                    return

                                    ThumbnailGuiClose:
                                        SetTimer, UpdateThumbnailNow, Off
                                        if (hThumbnail) {
                                            DllCall("dwmapi\DwmUnregisterThumbnail", "Ptr", hThumbnail)
                                            hThumbnail := 0
                                        }
                                        thumbnailIsOpen := false
                                        Gui, Thumbnail:Destroy
                                    return
                                    ThumbnailClick:
                                        global hSource, hGui

                                        ; Get current GUI client area size
                                        VarSetCapacity(RECT, 16, 0)
                                        DllCall("GetClientRect", "Ptr", hGui, "Ptr", &RECT)
                                        currentWidth := NumGet(RECT, 8, "Int")
                                        currentHeight := NumGet(RECT, 12, "Int")

                                        ; Get click position relative to GUI client area
                                        MouseGetPos, mouseX, mouseY
                                        DllCall("GetClientRect", "Ptr", hGui, "Ptr", &RECT)
                                        DllCall("ClientToScreen", "Ptr", hGui, "Ptr", &RECT)
                                        clientX := NumGet(RECT, 0, "Int")
                                        clientY := NumGet(RECT, 4, "Int")

                                        clickX := mouseX - clientX
                                        clickY := mouseY - clientY

                                        ; Get source window dimensions and title bar height
                                        VarSetCapacity(RECT, 16, 0)
                                        DllCall("GetWindowRect", "Ptr", hSource, "Ptr", &RECT)
                                        winWidth := NumGet(RECT, 8, "Int") - NumGet(RECT, 0, "Int")
                                        winHeight := NumGet(RECT, 12, "Int") - NumGet(RECT, 4, "Int")

                                        DllCall("GetClientRect", "Ptr", hSource, "Ptr", &RECT)
                                        clientWidth := NumGet(RECT, 8, "Int")
                                        clientHeight := NumGet(RECT, 12, "Int")

                                        ; Calculate title bar and border offsets
                                        titleBarHeight := winHeight - clientHeight
                                        borderWidth := (winWidth - clientWidth) / 2

                                        ; Scale using current GUI size
                                        scaleX := clientWidth / currentWidth
                                        scaleY := clientHeight / currentHeight

                                        targetX := Round(clickX * scaleX)
                                        targetY := Round(clickY * scaleY)

                                        ; Activate and click (coordinates are relative to client area)
                                        WinActivate, ahk_id %hSource%
                                        lParam := (targetY << 16) | (targetX & 0xFFFF)
                                        SendMessage, 0x201, 1, %lParam%,, ahk_id %hSource%
                                        Sleep, 50
                                        SendMessage, 0x202, 0, %lParam%,, ahk_id %hSource%
                                    return
                                    ; Image Clicker Settings GUI
                                    ImageClickerSettings:
                                        patternCount := imageClickerPatterns.Length()

                                        Gui, ImageClicker:New, +AlwaysOnTop
                                        Gui, ImageClicker:Add, GroupBox, x10 y10 w300 h180, Image Clicker
                                        Gui, ImageClicker:Add, Text, x20 y35 w280 h20, Capture images to click repeatedly. Patterns: %patternCount%
                                        Gui, ImageClicker:Add, Button, x20 y60 w120 h30 gCaptureClickImage, Capture Image
                                        Gui, ImageClicker:Add, Button, x150 y60 w120 h30 gTestClickImage, Test Images
                                        Gui, ImageClicker:Add, Button, x20 y100 w120 h30 gStartImageClicker, Start Clicker
                                        Gui, ImageClicker:Add, Button, x150 y100 w120 h30 gStopImageClicker, Stop Clicker
                                        Gui, ImageClicker:Add, Button, x20 y140 w120 h25 gClearClickImages, Clear All
                                        Gui, ImageClicker:Add, Button, x150 y140 w120 h25 gImageClickerClose, Close

                                    statusText := imageClickerRunning ? "Status: RUNNING" : "Status: STOPPED"
                                        Gui, ImageClicker:Add, Text, x20 y200 w280 h20 vImageClickerStatus, %statusText%

                                        Gui, ImageClicker:Show, w320 h230, Image Clicker
                                    return

                                    CaptureClickImage:
                                        GuiControl, ImageClicker:, ImageClickerStatus, Press 1 to capture image...
                                        KeyWait, 1, D
                                        capturedPattern := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

                                        if (capturedPattern != "") {
                                            imageClickerPatterns.Push(capturedPattern)
                                            SaveImageClickerPatterns()
                                            patternCount := imageClickerPatterns.Length()
                                            GuiControl, ImageClicker:, ImageClickerStatus, Image %patternCount% captured successfully!
                                        } else {
                                            GuiControl, ImageClicker:, ImageClickerStatus, Failed to capture image. Try again.
                                        }
                                    return

                                    TestClickImage:
                                        if (imageClickerPatterns.Length() = 0) {
                                            GuiControl, ImageClicker:, ImageClickerStatus, No images captured yet!
                                            return
                                        }

                                        GuiControl, ImageClicker:, ImageClickerStatus, Testing images on screen...

                                        foundCount := 0
                                        for index, pattern in imageClickerPatterns {
                                            if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, pattern)) {
                                                foundCount++
                                                GuiControl, ImageClicker:, ImageClickerStatus, Found image %index% at (%X%, %Y%)!
                                                FindText().MouseTip(X, Y)
                                                Sleep, 1000
                                            }
                                        }

                                        if (foundCount = 0) {
                                            GuiControl, ImageClicker:, ImageClickerStatus, No images found on screen.
                                        }
                                    return

                                    StartImageClicker:
                                        if (win1 = "" || !WinExist("ahk_id " . win1)) {
                                            GuiControl, ImageClicker:, ImageClickerStatus, Please select a game window first!
                                            return
                                        }

                                        if (imageClickerPatterns.Length() = 0) {
                                            GuiControl, ImageClicker:, ImageClickerStatus, Please capture images first!
                                            return
                                        }

                                        imageClickerRunning := true
                                        SetTimer, ImageClickerLoop, 100
                                        GuiControl, ImageClicker:, ImageClickerStatus, Status: RUNNING
                                    return

                                    StopImageClicker:
                                        imageClickerRunning := false
                                        SetTimer, ImageClickerLoop, Off
                                        GuiControl, ImageClicker:, ImageClickerStatus, Status: STOPPED
                                    return

                                    ImageClickerLoop:
                                        if (!imageClickerRunning) {
                                            SetTimer, ImageClickerLoop, Off
                                            return
                                        }

                                        ; Search for any of the captured images
                                        imageFound := false
                                        for index, pattern in imageClickerPatterns {
                                            if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, pattern)) {
                                                SendMessageClick(X, Y, win1)
                                                imageFound := true
                                                Sleep, 100
                                                break
                                            }
                                        }

                                        if (!imageFound) {
                                            ; No images found, sleep for 30 seconds
                                            Sleep, 22000
                                        }
                                    return

                                    ClearClickImages:
                                        MsgBox, 4, Clear Images, Clear all captured images?
                                        IfMsgBox Yes
                                        {
                                            imageClickerPatterns := []
                                            IniDelete, %SettingsFile%, ImageClickerPatterns
                                            GuiControl, ImageClicker:, ImageClickerStatus, All images cleared.
                                        }
                                    return

                                    ImageClickerClose:
                                        Gui, ImageClicker:Destroy
                                    return

                                    ; Save image clicker patterns to INI
                                    SaveImageClickerPatterns() {
                                        global SettingsFile, imageClickerPatterns

                                        FileEncoding, UTF-8
                                        IniDelete, %SettingsFile%, ImageClickerPatterns

                                        for index, pattern in imageClickerPatterns {
                                            keyName := "Pattern" . index
                                            IniWrite, %pattern%, %SettingsFile%, ImageClickerPatterns, %keyName%
                                        }
                                        FileEncoding
                                    }

                                    ; Load image clicker patterns from INI
                                    LoadImageClickerSettings() {
                                        global SettingsFile, imageClickerPatterns

                                        imageClickerPatterns := []

                                        IniRead, patternSection, %SettingsFile%, ImageClickerPatterns
                                        if (patternSection != "ERROR" && patternSection != "") {
                                            Loop, Parse, patternSection, `n
                                            {
                                                if (A_LoopField != "") {
                                                    equalsPos := InStr(A_LoopField, "=")
                                                    if (equalsPos > 0) {
                                                        patternText := SubStr(A_LoopField, equalsPos + 1)
                                                        imageClickerPatterns.Push(patternText)
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    FindText(ByRef x:="FindTextClass", ByRef y:="", args*)
                                    {
                                        static init, obj
                                        if !VarSetCapacity(init) && (init:="1")
                                            obj:=new FindTextClass()
                                    return (x=="FindTextClass" && !args.Length()) ? obj : obj.FindText(x, y, args*)
                                }

                                Class FindTextClass
                                { ;// Class Begin

                                    Floor(i)
                                    {
                                        if i is number
                                            return i+0
                                    else return 0
                                }

                                __New()
                                {
                                    this.bits:={ Scan0: 0, hBM: 0, oldzw: 0, oldzh: 0 }
                                    this.bind:={ id: 0, mode: 0, oldStyle: 0 }
                                    this.Lib:=[]
                                    this.Cursor:=0
                                }

                                __Delete()
                                {
                                    if (this.bits.hBM)
                                        Try DllCall("DeleteObject", "Ptr",this.bits.hBM)
                                }

                                New()
                                {
                                    return new FindTextClass()
                                }

                                help()
                                {
                                    return "
                                    (
                                    ;--------------------------------
                                    ;  FindText - Capture screen image into text and then find it
                                    ;  Version : 10.0  (2024-10-06)
                                    ;--------------------------------
                                    ;  returnArray:=FindText(
                                    ;      OutputX --> The name of the variable used to store the returned X coordinate
                                    ;    , OutputY --> The name of the variable used to store the returned Y coordinate
                                    ;    , X1 --> the search scope's upper left corner X coordinates
                                    ;    , Y1 --> the search scope's upper left corner Y coordinates
                                    ;    , X2 --> the search scope's lower right corner X coordinates
                                    ;    , Y2 --> the search scope's lower right corner Y coordinates
                                    ;    , err1 --> Fault tolerance percentage of text       (0.1=10%)
                                    ;    , err0 --> Fault tolerance percentage of background (0.1=10%)
                                    ;      Setting err1<0 or err0<0 can enable the left and right dilation algorithm
                                    ;      to ignore slight misalignment of text lines, the fault tolerance must be very small
                                    ;      In FindPic mode, err0 can set the number of rows and columns to be skipped
                                    ;    , Text --> can be a lot of text parsed into images, separated by '|'
                                    ;    , ScreenShot --> if the value is 0, the last screenshot will be used
                                    ;    , FindAll --> if the value is 0, Just find one result and return
                                    ;    , JoinText --> if you want to combine find, it can be 1, or an array of words to find
                                    ;    , offsetX --> Set the max text offset (X) for combination lookup
                                    ;    , offsetY --> Set the max text offset (Y) for combination lookup
                                    ;    , dir --> Nine directions for searching: up, down, left, right and center
                                    ;      Default dir=0, the returned result will be sorted by the smallest error,
                                    ;      Even if set a large fault tolerance, the first result still has the smallest error
                                    ;    , zoomW --> Zoom percentage of image width  (1.0=100%)
                                    ;    , zoomH --> Zoom percentage of image height (1.0=100%)
                                    ;  )
                                    ;
                                    ;  The function returns an Array containing all lookup results,
                                    ;  any result is a object with the following values:
                                    ;  {1:X, 2:Y, 3:W, 4:H, x:X+W//2, y:Y+H//2, id:Comment}
                                    ;  If no image is found, the function returns 0.
                                    ;  All coordinates are relative to Screen, colors are in RGB format
                                    ;  All 'RRGGBB' can use 'Black', 'White', 'Red', 'Green', 'Blue', 'Yellow'
                                    ;  All 'DRDGDB' can use similarity '1.0'(100%), it's floating-point number
                                    ;
                                    ;  If the return variable is set to 'ok', ok[1] is the first result found.
                                    ;  ok[1].1, ok[1].2 is the X, Y coordinate of the upper left corner of the found image,
                                    ;  ok[1].3, ok[1].4 is the width, height of the found image,
                                    ;  ok[1].x <==> ok[1].1+ok[1].3//2 ( is the Center X coordinate of the found image ),
                                    ;  ok[1].y <==> ok[1].2+ok[1].4//2 ( is the Center Y coordinate of the found image ),
                                    ;  ok[1].id is the comment text, which is included in the <> of its parameter.
                                    ;
                                    ;  If OutputX is equal to 'wait' or 'wait1'(appear), or 'wait0'(disappear)
                                    ;  it means using a loop to wait for the image to appear or disappear.
                                    ;  the OutputY is the wait time in seconds, time less than 0 means infinite waiting
                                    ;  Timeout means failure, return 0, and return other values means success
                                    ;  If you want to appear and the image is found, return the found array object
                                    ;  If you want to disappear and the image cannot be found, return 1
                                    ;  Example 1: FindText(X:='wait', Y:=3, 0,0,0,0,0,0,Text)   ; Wait 3 seconds for appear
                                    ;  Example 2: FindText(X:='wait0', Y:=-1, 0,0,0,0,0,0,Text) ; Wait indefinitely for disappear
                                    ;
                                    ;  <FindMultiColor> or <FindColor> : FindColor is FindMultiColor with only one point
                                    ;  Text:='|<>##DRDGDB $ 0/0/RRGGBB1-DRDGDB1/RRGGBB2, xn/yn/-RRGGBB3/RRGGBB4, ...'
                                    ;  Color behind '##' (0xDRDGDB) is the default allowed variation for all colors
                                    ;  Initial point (0,0) match 0xRRGGBB1(+/-0xDRDGDB1) or 0xRRGGBB2(+/-0xDRDGDB),
                                    ;  point (xn,yn) match not 0xRRGGBB3(+/-0xDRDGDB) and not 0xRRGGBB4(+/-0xDRDGDB)
                                    ;  Starting with '-' after a point coordinate means excluding all subsequent colors
                                    ;  Each point can take up to 10 sets of colors (xn/yn/RRGGBB1/.../RRGGBB10)
                                    ;
                                    ;  <FindShape> : Similar to FindMultiColor, just replacing the color with
                                    ;  whether the point is similar in color to the first point
                                    ;  Text:='|<>##DRDGDB $ 0/0/1, x1/y1/0, x2/y2/1, xn/yn/0, ...'
                                    ;
                                    ;  <FindPic> : Text parameter require manual input
                                    ;  Text:='|<>##DRDGDB/RRGGBB1-DRDGDB1/RRGGBB2... $ d:\a.bmp'
                                    ;  Color behind '##' (0xDRDGDB) is the default allowed variation for all colors
                                    ;  the 0xRRGGBB1(+/-0xDRDGDB1) and 0xRRGGBB2(+/-0xDRDGDB) both transparent colors
                                    ;
                                    ;--------------------------------
                                    )"
                                }

                                FindText(ByRef OutputX:="", ByRef OutputY:=""
                                , x1:=0, y1:=0, x2:=0, y2:=0, err1:=0, err0:=0, text:=""
                                , ScreenShot:=1, FindAll:=1, JoinText:=0, offsetX:=20, offsetY:=10
                                , dir:=0, zoomW:=1, zoomH:=1)
                                {
                                    local
                                    if (OutputX ~= "i)^\s*wait[10]?\s*$")
                                    {
                                        found:=!InStr(OutputX,"0"), time:=this.Floor(OutputY)
                                        , timeout:=A_TickCount+Round(time*1000), OutputX:=""
                                        Loop
                                        {
                                            ok:=this.FindText(,, x1, y1, x2, y2, err1, err0, text, ScreenShot
                                            , FindAll, JoinText, offsetX, offsetY, dir, zoomW, zoomH)
                                            if (found && ok)
                                            {
                                                OutputX:=ok[1].x, OutputY:=ok[1].y
                                                return ok
                                            }
                                            if (!found && !ok)
                                                return 1
                                            if (time>=0 && A_TickCount>=timeout)
                                                Break
                                            Sleep 50
                                        }
                                    return 0
                                }
                                SetBatchLines % (bch:=A_BatchLines)?"-1":"-1"
                                    x1:=this.Floor(x1), y1:=this.Floor(y1), x2:=this.Floor(x2), y2:=this.Floor(y2)
                                    if (x1=0 && y1=0 && x2=0 && y2=0)
                                        n:=150000, x:=y:=-n, w:=h:=2*n
                                    else
                                        x:=Min(x1,x2), y:=Min(y1,y2), w:=Abs(x2-x1)+1, h:=Abs(y2-y1)+1
                                    bits:=this.GetBitsFromScreen(x,y,w,h,ScreenShot,zx,zy), x-=zx, y-=zy
                                    , this.ok:=0, info:=[]
                                    Loop Parse, text, |
                                        if IsObject(j:=this.PicInfo(A_LoopField))
                                        info.Push(j)
                                    if (w<1 || h<1 || !(num:=info.Length()) || !bits.Scan0)
                                    {
                                        SetBatchLines % bch
                                        return 0
                                    }
                                    arr:=[], info2:=[], k:=0, s:=""
                                    , mode:=(IsObject(JoinText) ? 2 : JoinText ? 1 : 0)
                                    For i,j in info
                                    {
                                        k:=Max(k, (j[7]=5 && j[8]!=2 ? j[9] : j[2]*j[3]))
                                        if (mode)
                                            v:=(mode=1 ? i : j[10]) . "", s.="|" v
                                        , (v!="") && ((!info2.HasKey(v) && info2[v]:=[]), info2[v].Push(j))
                                    }
                                    sx:=x, sy:=y, sw:=w, sh:=h, (mode=1 && JoinText:=[s])
                                    , allpos_max:=(FindAll || JoinText ? 10000:1)
                                    , VarSetCapacity(s1,k*4), VarSetCapacity(s0,k*4)
                                    , VarSetCapacity(ss,sw*(sh+3)), VarSetCapacity(allpos,allpos_max*8)
                                    , ini:={ sx:sx, sy:sy, sw:sw, sh:sh, zx:zx, zy:zy
                                        , mode:mode, bits:bits, ss:&ss, s1:&s1, s0:&s0
                                        , allpos:&allpos, allpos_max:allpos_max
                                    , err1:err1, err0:err0, zoomW:zoomW, zoomH:zoomH }
                                    Loop 2
                                    {
                                        if (err1=0 && err0=0) && (num>1 || A_Index>1)
                                            ini.err1:=err1:=0.05, ini.err0:=err0:=0.05
                                        if (!JoinText)
                                        {
                                            For i,j in info
                                                Loop % this.PicFind(ini, j, dir, sx, sy, sw, sh)
                                            {
                                                v:=NumGet(allpos,4*A_Index-4,"uint"), x:=(v&0xFFFF)+zx, y:=(v>>16)+zy
                                                , w:=Floor(j[2]*zoomW), h:=Floor(j[3]*zoomH)
                                                , arr.Push({1:x, 2:y, 3:w, 4:h, x:x+w//2, y:y+h//2, id:j[10]})
                                                if (!FindAll)
                                                    Break 3
                                            }
                                        }
                                        else
                                            For k,v in JoinText
                                        {
                                            v:=StrSplit(Trim(RegExReplace(v, "\s*\|[|\s]*", "|"), "|")
                                            , (InStr(v,"|")?"|":""), " `t")
                                            , this.JoinText(arr, ini, info2, v, 1, offsetX, offsetY
                                            , FindAll, dir, 0, 0, 0, sx, sy, sw, sh)
                                            if (!FindAll && arr.Length())
                                                Break 2
                                        }
                                        if (err1!=0 || err0!=0 || arr.Length() || info[1][4] || info[1][7]=5)
                                            Break
                                    }
                                    SetBatchLines % bch
                                    if (arr.Length())
                                    {
                                        OutputX:=arr[1].x, OutputY:=arr[1].y, this.ok:=arr
                                        return arr
                                    }
                                return 0
                            }

                            ; the join text object use [ "abc", "xyz", "a1|a2|a3" ]

                            JoinText(arr, ini, info2, text, index, offsetX, offsetY
                            , FindAll, dir, minX, minY, maxY, sx, sy, sw, sh)
                            {
                                local
                                if !(Len:=text.Length()) || !info2.HasKey(key:=text[index])
                                return 0
                            zoomW:=ini.zoomW, zoomH:=ini.zoomH, mode:=ini.mode
                            For i,j in info2[key]
                                if (mode!=2 || key==j[10])
                                Loop % ok:=this.PicFind(ini, j, dir, sx, sy, (index=1 ? sw
                                : Min(sx+offsetX+Floor(j[2]*zoomW),ini.sx+ini.sw)-sx), sh)
                            {
                                if (A_Index=1)
                                {
                                    pos:=[], p:=ini.allpos-4
                                    Loop % ok
                                        pos.Push(NumGet(0|p+=4,"uint"))
                                }
                                v:=pos[A_Index], x:=v&0xFFFF, y:=v>>16
                                , w:=Floor(j[2]*zoomW), h:=Floor(j[3]*zoomH)
                                , (index=1 && (minX:=x, minY:=y, maxY:=y+h))
                                , minY1:=Min(y, minY), maxY1:=Max(y+h, maxY), sx1:=x+w
                                if (index<Len)
                                {
                                    sy1:=Max(minY1-offsetY, ini.sy)
                                    , sh1:=Min(maxY1+offsetY, ini.sy+ini.sh)-sy1
                                    if this.JoinText(arr, ini, info2, text, index+1, offsetX, offsetY
                                        , FindAll, 5, minX, minY1, maxY1, sx1, sy1, 0, sh1)
                                    && (index>1 || !FindAll)
                                return 1
                            }
                            else
                            {
                                comment:=""
                                For k,v in text
                                    comment.=(mode=2 ? v : info2[v][1][10])
                                x:=minX+ini.zx, y:=minY1+ini.zy, w:=sx1-minX, h:=maxY1-minY1
                                , arr.Push({1:x, 2:y, 3:w, 4:h, x:x+w//2, y:y+h//2, id:comment})
                                if (index>1 || !FindAll)
                                return 1
                        }
                    }
                    return 0
                }

                PicFind(ini, j, dir, sx, sy, sw, sh)
                {
                    local
                    static init, MyFunc
                    if !VarSetCapacity(init) && (init:="1")
                    {
                        x32:="VVdWU4HsmAAAAIuEJNQAAAADhCTMAAAAi5wk@AAAAIO8JKwAAAAFiUQkIIuEJPgA"
                        . "AACNBJiJRCQ0D4RKBgAAi4Qk6AAAAIXAD45ADwAAiXwkEIu8JOQAAAAx7ccEJAAA"
                        . "AADHRCQIAAAAAMdEJBQAAAAAx0QkDAAAAACNtgAAAACLhCTgAAAAi0wkDDH2MdsB"
                        . "yIX@iUQkBH896ZAAAABmkA+vhCTMAAAAicGJ8Jn3@wHBi0QkBIA8GDF0TIuEJNwA"
                        . "AACDwwEDtCQAAQAAiQyog8UBOd90VIsEJJn3vCToAAAAg7wkrAAAAAR1tQ+vhCTA"
                        . "AAAAicGJ8Jn3@40MgYtEJASAPBgxdbSLRCQUi5Qk2AAAAIPDAQO0JAABAACJDIKD"
                        . "wAE534lEJBR1rAF8JAyDRCQIAYu0JAQBAACLRCQIATQkOYQk6AAAAA+FMv@@@4tE"
                        . "JBSLfCQQD6+EJOwAAACJbCQwwfgKiUQkKIuEJPAAAAAPr8XB+AqJRCRAg7wkrAAA"
                        . "AAQPhCIGAACLhCTAAAAAi5wkxAAAAA+vhCTIAAAAjSyYi4QkzAAAAIucJMAAAAD3"
                        . "2IO8JKwAAAABjQSDiUQkLA+ELwYAAIO8JKwAAAACD4Q4CAAAg7wkrAAAAAMPhLkL"
                        . "AACLjCTQAAAAhckPjicBAACLhCTMAAAAi6wkzAAAAMdEJAwAAAAAx0QkEAAAAACJ"
                        . "fCQYg+gBiUQkCI22AAAAAIt8JBCLtCTUAAAAMcCLXCQgAfsB94Xtif6J738X6bwA"
                        . "AADGBAYEg8ABg8MBOccPhKQAAACDvCSsAAAAA3@khcAPtgsPhLoPAAAPtlP@iVQk"
                        . "BDlEJAgPhMIPAAAPtlMBiRQki5Qk9AAAAIXSD4SfAQAAD7bpugYAAACD7QGD@QF2"
                        . "G4N8JAQBD5TCgzwkAYnVD5TCCeoPttIB0oPKBIHh@QAAAL0BAAAAdByLTCQEiywk"
                        . "hckPlEQkBIXtD5TBic0PtkwkBAnNCeqDwwGIFAaDwAE5xw+FXP@@@wF8JBCJ@YNE"
                        . "JAwBi0QkDDmEJNAAAAAPjwz@@@+LfCQYg7wkrAAAAAN@FouEJPQAAACFwA+VwDwB"
                        . "g5wkxAAAAP+LXCQUi3QkKDHAOfOLdCRAD07YiVwkFItcJDA58w9Pw4lEJDCLhCTM"
                        . "AAAAK4QkAAEAAIlEJASLhCTQAAAAK4QkBAEAAIO8JLgAAAAJiUQkCA+ExgAAAIuE"
                        . "JLgAAACD6AGD+AcPh7wCAACD+AOJRCQkD463AgAAi0QkBMdEJEQAAAAAx0QkDAAA"
                        . "AACJBCSLRCQIiUQkHItcJEQ5HCTHRCRMAAAAAA+MCwEAAItcJEw5XCQcD4zCDQAA"
                        . "i3QkRItcJCSLBCQp8PbDAg9Exot0JEyJwotEJBwp8PbDAQ9ExoP7A4nWD0@wD0@C"
                        . "iXQkGIlEJBDp3gsAAI12AA+20YPqAYP6AhnSg+ICg8IEgeH9AAAAD5TBCcqIFAbp"
                        . "8v3@@4tcJASLdCQIx0QkZAAAAADHRCRgAQAAAMdEJFQAAAAAx0QkWAAAAACJ2I1W"
                        . "AYk0JMHoH4lcJBzHRCQMAAAAAAHY0fiJRCQQifDB6B8B8NH4iUQkGInYg8ABicEP"
                        . "r8o50A9MwoPACIlMJHyJwQ+vyImMJIAAAACLXCR8OVwkZH0Zi5wkgAAAADlcJFjH"
                        . "RCRcAAAAAA+M9QQAAIuMJLgAAACFyQ+FnQIAAIuUJPgAAACF0g+EjgIAAIuEJAQB"
                        . "AAAPr4QkAAEAAIP4AQ+EdgIAAIN8JAwBD46lCgAAi0QkNIucJPgAAAAx7cdEJAQA"
                        . "AAAAiSwkjXgEi0QkDIPoAYlEJBCLRCQEiwwkizeLRAMEhcmJRCQIich4NotP@DnO"
                        . "D4N1BQAAifqNa@zrDY12AIPqBItK@DnOcxeJCotMhQSJTIMEg+gBg@j@deS4@@@@"
                        . "@4tMJDSDwAGDBCQBg8cEg0QkBASJNIGLdCQIiTSDiwQkO0QkEHWNi4QkBAEAAIus"
                        . "JAABAAAPr8APr+2JRCQEi7Qk+AAAAMdEJAgAAAAAMduLRCQIiwSGiUQkEA+3+MHo"
                        . "EIXbiQQkdC0xyY22AAAAAIsUjg+3win4D6@AOeh9D8HqECsUJA+v0jtUJAR8EYPB"
                        . "ATnZdduLRCQQiQSeg8MBg0QkCAGLRCQIOUQkDHWiidiBxJgAAABbXl9dwlwAx0Qk"
                        . "JAAAAACLRCQIx0QkRAAAAADHRCQMAAAAAIkEJItEJASJRCQc6UT9@@8xwIO8JLAA"
                        . "AAACD5TAiYQkhAAAAA+EUAQAADHAg7wksAAAAAGLrCS0AAAAD5TAhe2JRCR4D4SG"
                        . "CwAAi7Qk2AAAAIuUJLQAAAAx7YucJOAAAACLjCTcAAAAiXwkCI0ElolEJASNdCYA"
                        . "izuDxgSDw1iDwQSJ+MHoEA+vhCQEAQAAmfe8JOgAAAAPr4QkwAAAAIkEJA+3xw+v"
                        . "hCQAAQAAmfe8JOQAAACLFCSNBIKJRvyLQ6yNREUAg8UWiUH8O3QkBHWmi4QktAAA"
                        . "AIm8JLAAAACLfCQIiUQkFIuEJOwAAAAPr4QktAAAAMH4ColEJCiLhCTgAAAAx0Qk"
                        . "QAAAAADHRCQwAAAAAIPACIlEJFDpSfr@@4tEJAyBxJgAAABbXl9dwlwAi4QksAAA"
                        . "AMHoEA+vhCQEAQAAmfe8JOgAAAAPr4QkwAAAAInBD7eEJLAAAAAPr4QkAAEAAJn3"
                        . "vCTkAAAAjQSBiYQksAAAAOnt+f@@i4Qk6AAAAIu0JNAAAAAPr4Qk5AAAANGkJLQA"
                        . "AAADhCTgAAAAhfaJRCRQD47z+v@@i4QkzAAAAInqi2wkUMdEJCQAAAAAx0QkOAAA"
                        . "AADB4AKJRCRIMcCLnCTMAAAAhdsPjisBAACLnCS8AAAAAdMDVCRIiVwkEItcJCAD"
                        . "XCQ4iVQkPAOUJLwAAACJXCQYiVQkHI12AI28JwAAAACLdCQQMds5nCS0AAAAD7ZO"
                        . "AolMJAQPtk4BD7Y2iUwkCIl0JAx2W412AI28JwAAAACLRJ0Ag8MCi3yd@InCD7bM"
                        . "D7bAK0QkDMHqECtMJAgPttIrVCQEgf@@@@8AiQQkdyUPr9IPr8mNFFIPr8CNFIqN"
                        . "BEI5x3NGMcA5nCS0AAAAd6+JwutBif7B7hCJ8A+28A+v0g+v9jnyd92J+A+21A+v"
                        . "yQ+v0jnRd86LNCSJ+A+20A+v0onwD6@GOdB3uroBAAAAuAEAAACLXCQYg0QkEASL"
                        . "TCQQiBODwwE7TCQciVwkGA+FGv@@@4u0JMwAAAABdCQ4i1QkPINEJCQBA1QkLItc"
                        . "JCQ5nCTQAAAAD4Ws@v@@6U34@@+LRCQQhcB4G4tcJBw52H8Ti0QkGIXAeAuLHCQ5"
                        . "2A+ONwYAAItsJFSF7Q+F4AUAAINsJBgBg0QkXAGDRCRYAYt0JGA5dCRcfLiLXCRU"
                        . "idiD4AEBxonYg8ABiXQkYIPgA4lEJFTpvvr@@4uEJLAAAACLjCTQAAAAxwQkAAAA"
                        . "AMdEJAQAAAAAg8ABweAHiYQksAAAAIuEJMwAAADB4AKFyYlEJAwPjsz4@@+J6Ius"
                        . "JLAAAACJfCQQi5QkzAAAAIXSfmaLjCS8AAAAi1wkIIu8JLwAAAADXCQEAcEDRCQM"
                        . "iUQkCAHHjXYAjbwnAAAAAA+2UQIPtkEBD7Yxa8BLa9ImAcKJ8MHgBCnwAdA5xQ+X"
                        . "A4PBBIPDATn5ddWLnCTMAAAAAVwkBItEJAiDBCQBA0QkLIs8JDm8JNAAAAAPhXf@"
                        . "@@+LfCQQ6Qb3@@+LBCTprvr@@4uEJOgAAACLvCTgAAAAD6+EJOQAAADRpCS0AAAA"
                        . "jQSHiUQkUIuEJPAAAADB+AqDwAGJRCQki4Qk6AAAAIXAD45ECgAAi3wkJIuEJAQB"
                        . "AACLdCRQx0QkMAAAAADHRCQUAAAAAA+vx4lEJECLhCTkAAAAD6@HweACiUQkSIuE"
                        . "JOAAAACDwAKJRCQ4ifiNPL0AAAAAiXwkLInHD6+EJAABAACJfCQ8iUQkKIuEJOQA"
                        . "AACFwA+OaQEAAItEJDjHRCQcAAAAAIlEJBCLRCQkiUQkGItEJBC7AgAAAA+2OIk8"
                        . "JA+2eP8PtkD+iXwkBIlEJAg5nCS0AAAAD4bCAAAAiwSeg8MCi3ye@InCD7bMD7bA"
                        . "K0QkCMHqECtMJAQPttIrFCSB@@@@@wCJRCQMd0YPr9IPr8mNFFIPr8CNFIqNBEI5"
                        . "x3Kui3wkGItEJCSLTCQsAUwkEItMJCgBTCQcAfg5vCTkAAAAD465AAAAiUQkGOlf"
                        . "@@@@if3B7RCJ6A+26A+v0g+v7TnqD4dm@@@@ifgPttQPr8kPr9I50Q+HU@@@@4tM"
                        . "JAyJ+A+2+A+v@4nID6@BOfh2kDmcJLQAAAAPhz7@@@+LRCQwi3wkFJmNHL0AAAAA"
                        . "97wk6AAAAA+vhCTAAAAAicGLRCQcmfe8JOQAAACLFCTB4hCNBIGLjCTYAAAAiQS5"
                        . "i0QkBIPHAYl8JBSLvCTcAAAAweAICdALRCQIiQQf6SD@@@+LfCQ8i0QkJItMJEAB"
                        . "TCQwi0wkSAFMJDgB+Dm8JOgAAAB+CYlEJDzpXP7@@4tEJBQPr4Qk7AAAAMH4ColE"
                        . "JCiLRCRQx0QkQAAAAADHRCQwAAAAAIt4BIn4ifvB6BAPtteJ+w+2wA+2y4nDD6@Y"
                        . "idAPr8KJXCRwiUQkdInID6@BiUQkbOlH9P@@i4Qk0AAAAIXAD45u9f@@i5wkzAAA"
                        . "AItEJCDHBCQAAAAAx0QkBAAAAACJfCQMjQRYiUQkGInYweACiUQkCIu0JMwAAACF"
                        . "9n5Xi4wkvAAAAItcJBiLvCS8AAAAA1wkBAHpA2wkCAHvD7ZRAoPBBIPDAWvyJg+2"
                        . "Uf1rwkuNFAYPtnH8ifDB4AQp8AHQwfgHiEP@Ofl10ou8JMwAAAABfCQEgwQkAQNs"
                        . "JCyLBCQ5hCTQAAAAdYqLhCTMAAAAi3wkDDHti5QktAAAADH2g+gBiXwkJIlEJAyL"
                        . "hCTQAAAAg+gBiUQkEIucJMwAAACF2w+O4gAAAIu8JMwAAACLRCQYAfeNDDCJ+4l8"
                        . "JByJxwHfifMrnCTMAAAAiXwkBIt8JCABwwH3McCJfCQIiRwkhcAPhGQDAAA5RCQM"
                        . "D4RaAwAAhe0PhFIDAAA5bCQQD4RIAwAAD7YRD7Z5@74BAAAAA5QksAAAADn6ckYP"
                        . "tnkBOfpyPos8JA+2Pzn6cjSLXCQED7Y7OfpyKYs8JA+2f@85+nIeizwkD7Z@ATn6"
                        . "chMPtnv@OfpyCw+2cwE58g+Sw4nei3wkCInziBwHg8ABg8EBg0QkBAGDBCQBOYQk"
                        . "zAAAAA+FWv@@@4t0JByDxQE5rCTQAAAAD4X@@v@@i3wkJImUJLQAAADpY@L@@8dE"
                        . "JEAAAAAAx0QkKAAAAADHRCQwAAAAAMdEJBQAAAAA6cfx@@+DfCRUAQ+E6gEAAIN8"
                        . "JFQCD4SVAgAAg2wkEAHpBfr@@4uEJAQBAACLrCQAAQAAD6@AD6@tiUQkBItEJAyF"
                        . "wA+P6PX@@zHA6VL2@@+DRCRkAcdEJCQJAAAAi0QkGIucJNQAAAAPr4QkzAAAAANE"
                        . "JBCAPAMDD4ZnAQAAi3QkFItcJDA53g9N3oO8JKwAAAADiVwkIA+OdQEAAItEJBgD"
                        . "hCTIAAAAD6+EJMAAAACLVCQQA5QkxAAAAIO8JKwAAAAFD4RsAgAAjTSQi4QksAAA"
                        . "AIucJLwAAAAB8A+2XAMCiVwkOIucJLwAAAAPtlwDAYlcJDyLnCS8AAAAD7YEA4lE"
                        . "JEiLRCQghcAPhKoBAACLRCRAiXwkLDHbi2wkKIu8JLwAAACJRCRo62KNtCYAAAAA"
                        . "OVwkMH5Ii4Qk3AAAAIsUmAHyD7ZEFwIPtkwXAStEJDgrTCQ8D7YUFytUJEgPr8AP"
                        . "r8mNBEAPr9KNBIiNBFA5hCS0AAAAcgeDbCRoAXhhg8MBOVwkIA+EogEAADlcJBR+"
                        . "n4uEJNgAAACLFJgB8g+2RBcCD7ZMFwErRCQ4K0wkPA+2FBcrVCRID6@AD6@JjQRA"
                        . "D6@SjQSIjQRQOYQktAAAAA+DWv@@@4PtAQ+JUf@@@4t8JCyDfCQkCQ+EKfj@@4NE"
                        . "JEwB6Try@@+DRCQQAekm+P@@g0QkRAHpEfL@@410JgCF2w+EoAAAAAOEJNQAAACL"
                        . "XCRAMdKLbCQoicHrJTlUJDB+Fou0JNwAAACLBJYByPYAAXUFg+sBeJqDwgE5VCQg"
                        . "dGo5VCQUftWLtCTYAAAAiwSWAcj2AAJ1xIPtAXm@6XD@@@@HRCQEAwAAAOlB8P@@"
                        . "i3wkCMYEBwLpEf3@@8cEJAMAAADpOfD@@8dEJCgAAAAAx0QkFAAAAADpGPX@@4NE"
                        . "JBgB6XD3@@+LbCQoi4Qk+AAAAINEJAwBhcAPhMoDAACLVCQYA5QkyAAAAItcJAyL"
                        . "RCQQA4QkxAAAAIu0JPgAAADB4hCNi@@@@z8J0IkEjou0JLgAAACF9g+F0gIAAItE"
                        . "JCiLdCQ0Keg5nCT8AAAAiQSOD44z8v@@6bb+@@+LfCQs64mLtCSEAAAAjQSQiUQk"
                        . "PIX2D4WuAQAAi1wkIItEJFAx9otsJCiF24lEJGgPhFn@@@+LhCTYAAAAi1wkaItU"
                        . "JDwDFLCJXCRIa8YWgTv@@@8AiUQkOA+XwA+2wIlEJCyLhCTcAAAAiwSwiYQktAAA"
                        . "AIuEJLwAAAAPtkQQAomEJIwAAADB4BCJwYuEJLwAAAAPtkQQAYmEJJAAAADB4AgJ"
                        . "yIuMJLwAAAAPtgwRCciJjCSUAAAAiYQkiAAAAOsfD6@SD6@JjRRSD6@AjRSKjQRC"
                        . "OccPg70AAACDRCRICItEJDg7hCS0AAAAD4PPAAAAi1QkeIt8JEiDRCQ4AoXSiweL"
                        . "fwR0JoX2i5wkiAAAAA9FnCSwAAAAhcAPlMAPtsCJRCQsiZwksAAAAInYicIPtswP"
                        . "tsDB6hArjCSQAAAAK4QklAAAAA+20iuUJIwAAACB@@@@@wAPhmX@@@+J+8HrEA+2"
                        . "2w+v0g+v2znaD4dp@@@@ifsPttcPr8kPr9I50Q+HVv@@@4n7D7bTD6@AD6@SOdAP"
                        . "h0P@@@+LRCQshcB0CYPtAQ+IDf3@@4PGAYNEJGhYOXQkIA+Fe@7@@+nP@f@@i0Qk"
                        . "LIXAdeHr1otMJCCLbCQohckPhLX9@@8x9usuOUQkcHwSD6@JOUwkdHwJD6@SOVQk"
                        . "bH0Jg+0BD4i3@P@@g8YBOXQkIA+Eg@3@@4uEJNgAAACLVCQ8i5wkvAAAAAMUsIuE"
                        . "JNwAAACLBLCJhCSwAAAAi4QkvAAAAIuMJLAAAAAPtkQQAsHpEA+2ySnID7ZMEwGL"
                        . "nCSwAAAAD6@AD7bfKdmLnCS8AAAAD7YUEw+2nCSwAAAAKdqB@@@@@wAPh1z@@@8P"
                        . "r8mNBEAPr9KNBIiNBFA5xw+CXf@@@+lh@@@@x0QkKAAAAADHRCQUAAAAAOnC9@@@"
                        . "i1wkDDmcJPwAAACJ2A+OrfD@@4tcJBgxyYnOidgrhCQEAQAAg8ABD0jBicKJ2Iuc"
                        . "JAQBAACNRBj@i1wkCDnDD07Di1wkEInFidgrhCQAAQAAg8ABD0nwidiLnCQAAQAA"
                        . "jUQY@4tcJAQ5ww9OwznVicMPjIz7@@+LhCTMAAAAg8UBD6@CA4Qk1AAAAInBjUMB"
                        . "iUQkIDnefw+J8IAkAQODwAE7RCQgdfODwgEDjCTMAAAAOep13+lJ+@@@i6wkuAAA"
                        . "AIXtD4VK@@@@6TX7@@+QkA=="
                        x64:="QVdBVkFVQVRVV1ZTSIHsyAAAAEhjhCRQAQAASIu8JKgBAACJjCQQAQAAiVQkMESJ"
                        . "jCQoAQAAi7QkgAEAAIusJIgBAABJicRIiUQkWEgDhCRgAQAAg@kFSIlEJChIY4Qk"
                        . "sAEAAEiNBIdIiUQkYA+E3AUAAIXtD44BDAAARTH2iVwkEIu8JLgBAABEiXQkCIuc"
                        . "JBABAABFMe1Mi7QkcAEAAEUx20Ux@0SJbCQYRImEJCABAABMY1QkCEUxyUUxwEwD"
                        . "lCR4AQAAhfZ@Mut3Dx9AAEEPr8SJwUSJyJn3@gHBQ4A8AjF0PEmDwAFJY8dBAflB"
                        . "g8cBRDnGQYkMhn5DRInYmff9g@sEdckPr4QkOAEAAInBRInImff+Q4A8AjGNDIF1"
                        . "xEiLlCRoAQAASYPAAUljxUEB+UGDxQFEOcaJDIJ@vQF0JAiDRCQYAUQDnCTAAQAA"
                        . "i0QkGDnFD4VX@@@@RInoi1wkEESLhCQgAQAAD6+EJJABAABEiWwkGMH4ColEJByL"
                        . "hCSYAQAAQQ+vx8H4ColEJECDvCQQAQAABA+EtwUAAIuEJDgBAACLvCRAAQAAD6+E"
                        . "JEgBAACNBLiLvCQ4AQAAiUQkCESJ4PfYg7wkEAEAAAGNBIeJRCQgD4SxBQAAg7wk"
                        . "EAEAAAIPhIQHAACDvCQQAQAAAw+EowoAAIuEJFgBAACFwA+OHwEAAESJfCQQRIuc"
                        . "JBABAABBjWwk@0yLfCQoi7wkoAEAAEUx9kUx7YlcJAhEiYQkIAEAAA8fhAAAAAAA"
                        . "RYXkD467AAAASWPFMclJicFNjUQHAUwDjCRgAQAA6xhBxgEEg8EBSYPBAUmDwAFB"
                        . "OcwPhIkAAABBg@sDf+KFyUEPtlD@D4S1DgAAQQ+2WP45zQ+Euw4AAEUPthCF@w+E"
                        . "fAEAAA+28rgGAAAAg+4Bg@4BdhiD+wFAD5TGQYP6AQ+UwAnwD7bAAcCDyASB4v0A"
                        . "AAC+AQAAAHQOhdtAD5TGRYXSD5TCCdYJ8IPBAUmDwQFBiEH@SYPAAUE5zA+Fd@@@"
                        . "@0UB5UGDxgFEObQkWAEAAA+PKv@@@4tcJAhEi3wkEESLhCQgAQAAg7wkEAEAAAN@"
                        . "FouEJKABAACFwA+VwDwBg5wkQAEAAP+LfCQYi3QkHDHARInlRIucJFgBAAA59w9O"
                        . "+EQ7fCRAiXwkGEQPTvgrrCS4AQAARCucJMABAACDvCQoAQAACQ+EuQAAAIuEJCgB"
                        . "AACD6AGD+AcPh5ACAACD+AOJRCRID46LAgAAiWwkCESJXCQQRTH2x0QkTAAAAACL"
                        . "fCRMOXwkCMdEJGgAAAAAD4wNAQAAi3wkaDl8JBAPjNIMAACLfCRIi3QkTItEJAgp"
                        . "8ED2xwIPRMaLdCRoicKLRCQQKfBA9scBD0TGg@8DidcPT@gPT8JBicXptgoAAGaQ"
                        . "D7bCg+gBg@gCGcCD4AKDwASB4v0AAAAPlMIJ0EGIAekg@v@@iehBjVMBRIlcJAjB"
                        . "6B+JbCQQx4QkiAAAAAAAAAAB6MeEJIQAAAABAAAAx0QkbAAAAADR+MdEJHwAAAAA"
                        . "QYnFRInYwegfRAHY0fiJx41FAYnGD6@yOdAPTMJFMfaDwAiJtCSkAAAAicYPr@CJ"
                        . "tCSoAAAAi7QkpAAAADm0JIgAAAB9HIu0JKgAAAA5dCR8x4QkgAAAAAAAAAAPjEYE"
                        . "AACLhCQoAQAAhcAPhV0CAABIg7wkqAEAAAAPhE4CAACLhCTAAQAAD6+EJLgBAACD"
                        . "+AEPhDYCAABBg@4BD45dCQAAQY1G@kyLRCRgTIucJKgBAABFMclFMdJIjRyFBAAA"
                        . "AEOLdAgEQ4sUCESJ0UOLfAsETInQOdZyE+kJBAAAZpBIg+gBQYsUgDnWcx1BiVSA"
                        . "BEGLFIOD6QGD+f9BiVSDBHXeSMfA@@@@@0mDwQRIg8ABSYPCAUk52UGJNIBBiTyD"
                        . "dZ9Ei5QkuAEAAIucJMABAABFD6@SD6@bTIuMJKgBAAAx9jHAQYsssYnvRA+33cHv"
                        . "EIXAdDJFMcAPH4QAAAAAAEOLDIEPt9FEKdoPr9JEOdJ9DMHpECn5D6@JOdl8E0mD"
                        . "wAFEOcB@2Uhj0IPAAUGJLJFIg8YBQTn2f6pIgcTIAAAAW15fXUFcQV1BXkFfw8dE"
                        . "JEgAAAAARIlcJAiJbCQQRTH2x0QkTAAAAADpcP3@@4tEJDAx@4P4AkAPlMeJvCSs"
                        . "AAAAD4SpAwAAMcCDfCQwAQ+UwEWFwImEJKAAAAAPhNsKAABEiaQkUAEAAEyLlCR4"
                        . "AQAARTHJi7wkOAEAAEyLpCRoAQAARTHbTIusJHABAABEi7QkuAEAAESLvCTAAQAA"
                        . "iVwkGEGLGkmDwliJ2MHoEEEPr8eZ9@0Pr8eJwQ+3w0EPr8aZ9@6NBIFDiQSMQYtC"
                        . "rEGNBENBg8MWQ4lEjQBJg8EBRTnId72LhCSQAQAARIukJFABAACJXCQwi1wkGESJ"
                        . "RCQYQQ+vwMH4ColEJBxIi4QkeAEAAMdEJEAAAAAARTH@SIPACEiJBCTpq@r@@0SJ"
                        . "8OnE@v@@i3wkMIn4wegQD6+EJMABAACZ9@0Pr4QkOAEAAInBD7fHD6+EJLgBAACZ"
                        . "9@6NBIGJRCQw6Wv6@@+J6ESLjCRYAQAARQHAD6@GSJhIA4QkeAEAAEWFyUiJBCQP"
                        . "jnL7@@9CjTylAAAAAMdEJBAAAAAAMcDHRCRIAAAAAESJfCR4iXwkUEWF5A+O6QAA"
                        . "AEhjVCQISIu8JDABAABFMe1MY3QkSEwDdCQoSI1sFwJMiwwkRTHSD7Z9AA+2df9E"
                        . "D7Zd@usmZi4PH4QAAAAAAA+vyQ+v0o0MSQ+vwI0UkY0EQjnDc2hJg8EIMcBFOcIP"
                        . "gxsBAABBiwFBi1kEQYPCAonBD7bUD7bAwekQKfJEKdgPtskp+YH7@@@@AHazQYnf"
                        . "QcHvEEUPtv8Pr8lFD6@@RDn5d7IPts8Pr9IPr8k5ynelD7bTD6@AD6@SOdB3mLoB"
                        . "AAAAuAEAAABDiBQuSYPFAUiDxQRFOewPj0P@@@+LdCRQRAFkJEgBdCQIg0QkEAGL"
                        . "VCQgi3wkEAFUJAg5vCRYAQAAD4Xw@v@@RIt8JHjpFvn@@0WF7XgVRDtsJBB@DoX@"
                        . "eAo7fCQID464BQAAi0QkbIXAD4WNBQAAg+8Bg4QkgAAAAAGDRCR8AYuUJIQAAAA5"
                        . "lCSAAAAAfLqLdCRsifCD4AEBwonwg8ABiZQkhAAAAIPgA4lEJGzpW@v@@w8fRAAA"
                        . "icLpQf@@@0yJ0Oka@P@@i0QkMIuMJFgBAAAx9jH@Qo0spQAAAACDwAHB4AeFyYlE"
                        . "JDAPjo@5@@9Ei3QkCESLbCQwRYXkflVIi5QkMAEAAExj30wDXCQoSWPGRTHJSI1M"
                        . "AgIPthEPtkH@RA+2Uf5rwEtr0iYBwkSJ0MHgBEQp0AHQQTnFQw+XBAtJg8EBSIPB"
                        . "BEU5zH@MQQHuRAHng8YBRAN0JCA5tCRYAQAAdZXp9vf@@4noRQHAD6@GweACSJhI"
                        . "A4QkeAEAAEiJBCSLhCSYAQAAwfgKg8ABhe2JRCQID46VCgAAi3wkCIuEJMABAADH"
                        . "RCRIAAAAAMdEJBgAAAAARImkJFABAACJrCSIAQAAD6@HiXwkUIlEJHiJ+A+vxsHg"
                        . "AkiYSIlEJHBIi4QkeAEAAEiJRCRAifjB4AJImEiJRCQQi4QkuAEAAA+vx4lEJBxI"
                        . "iwQkSIPACEiJRCQghfYPjiYBAABIi3wkQESLZCQIMe0Ptl8CTItMJCBBvgIAAABE"
                        . "D7ZXAUQPth9Bid3rHQ8fAA+v2w+v0o0cWw+vwI0Uk40EQjnBc2pJg8EIRTnwD4Z9"
                        . "AAAAQYsBQYtJBEGDxgKJww+21A+2wMHrEEQp0kQp2A+220Qp64H5@@@@AHazQYnP"
                        . "QcHvEEUPtv8Pr9tFD6@@RDn7d7IPtt0Pr9IPr9s52nelD7bJD6@AD6@JOch3mGaQ"
                        . "i0QkCEgDfCQQA2wkHEQB4EQ55n5lQYnE6UP@@@8PHwCLRCRIRIt0JBhEievB4xBB"
                        . "weIIQQnamU1jzkUJ2ve8JIgBAAAPr4QkOAEAAInBieiZ9@5Ii5QkaAEAAI0EgUKJ"
                        . "BIpEifCDwAGJRCQYSIuEJHABAABGiRSI64aLfCRQi0QkCItUJHgBVCRISItUJHBI"
                        . "AVQkQAH4ObwkiAEAAH4JiUQkUOmk@v@@i0QkGESLpCRQAQAAD6+EJJABAADB+AqJ"
                        . "RCQcSIsEJMdEJEAAAAAARTH@i1gEidgPts8PttPB6BAPtsCJxw+v+InID6@Bibwk"
                        . "mAAAAImEJJwAAACJ0A+vwomEJJQAAADpffX@@8dEJEAAAAAAx0QkHAAAAABFMf@H"
                        . "RCQYAAAAAOn19P@@i5QkWAEAAIXSD4589v@@Q40EZESLdCQIQo0spQAAAAAx9jH@"
                        . "SJhIA4QkYAEAAEmJxUWF5H5aSIuUJDABAABJY8ZMY99FMclNAetIjUwCAg8fRAAA"
                        . "D7YRSIPBBERr0iYPtlH7a8JLQY0UAkQPtlH6RInQweAERCnQAdDB+AdDiAQLSYPB"
                        . "AUU5zH@KQQHuRAHng8YBRAN0JCA5tCRYAQAAdZBIi3wkWDHSQY1sJP9EiXwkSEUx"
                        . "0olcJCBBiddIifhIg8ABSIlEJAi4AQAAAEiJxouEJFgBAABIKf6LfCQwSIl0JBBE"
                        . "jXD@RYXkD47TAAAASItEJAhNY99Ii3QkKEuNVB0BTo0MGEiLRCQQTAHeTQHpSo0M"
                        . "GDHATAHpZi4PH4QAAAAAAEiFwA+EgQMAADnFD4R5AwAARYXSD4RwAwAARTnWD4Rn"
                        . "AwAARA+2Qv9ED7Za@rsBAAAAQQH4RTnYckZED7YaRTnYcj1ED7ZZ@0U52HIzRQ+2"
                        . "Wf9FOdhyKUQPtln+RTnYch9ED7YZRTnYchZFD7ZZ@kU52HIMRQ+2GUU52A+Sw2aQ"
                        . "iBwGSIPAAUiDwgFJg8EBSIPBAUE5xA+PZP@@@0UB50GDwgFEOZQkWAEAAA+FEv@@"
                        . "@4tcJCBEi3wkSOmJ8@@@RIuUJLgBAACLnCTAAQAAMcBFD6@SD6@bRYX2D4569@@@"
                        . "6RP3@@+DfCRsAQ+E@AEAAIN8JGwCD4S4AgAAQYPtAelX+v@@g4QkiAAAAAHHRCRI"
                        . "CQAAAIn4SIu0JGABAABBD6@ERo0MKEljwYA8BgMPhqQBAACLRCQYRDn4QQ9Mx4O8"
                        . "JBABAAADiUQkIA+OsAEAAIuEJEgBAACLlCRAAQAAAfhEAeoPr4QkOAEAAIO8JBAB"
                        . "AAAFD4TAAgAARI0MkItEJDBIi7QkMAEAAESLVCQgRAHIjVACRYXSSGPSD7Y0Fo1Q"
                        . "AUiYSGPSiXQkUEiLtCQwAQAAD7Y0Fol0JHhIi7QkMAEAAA+2BAaJRCRwD4TrAQAA"
                        . "i0QkQESJXCQoRTHSi3QkHEyLnCQwAQAAiYQkjAAAAOtyRDu8JJAAAAB+WUiLhCRw"
                        . "AQAAQosUkEQByo1CAo1KAUhj0kEPthQTSJhIY8krVCRwQQ+2BANBD7YMCytEJFAr"
                        . "TCR4D6@SD6@AD6@JjQRAjQSIjQRQQTnAcgqDrCSMAAAAAXh+SYPCAUQ5VCQgD47P"
                        . "AQAARDlUJBhEiZQkkAAAAA+Oe@@@@0iLhCRoAQAAQosUkEQByo1CAo1KAUhj0kEP"
                        . "thQTSJhIY8krVCRwQQ+2BANBD7YMCytEJFArTCR4D6@SD6@AD6@JjQRAjQSIjQRQ"
                        . "QTnAD4Mo@@@@g+4BD4kf@@@@RItcJCiDfCRICQ+Eavj@@4NEJGgB6Snz@@9Bg8UB"
                        . "6Wb4@@+DRCRMAekA8@@@kIXAD4SzAAAARItUJECLdCQcMcnrM0Q7fCQofiJIi5Qk"
                        . "cAEAAESJyAMEikiLlCRgAQAA9gQCAXUGQYPqAXiZSIPBATlMJCB+dzlMJBiJTCQo"
                        . "fsNIi4QkaAEAAESJygMUiEiLhCRgAQAA9gQQAnWng+4BeaLpX@@@@w8fhAAAAAAA"
                        . "uwMAAADpRvH@@8YEBgLp8Pz@@0G6AwAAAOk+8f@@x0QkHAAAAADHRCQYAAAAAOm7"
                        . "9f@@g8cB6aD3@@+LdCQcQYPGAUiDvCSoAQAAAA+EHQQAAEljxouUJEgBAABIjQyF"
                        . "AAAAAIuEJEABAAAB+sHiEEQB6AnQSIuUJKgBAACJRAr8i5QkKAEAAIXSD4UeAwAA"
                        . "i0QkHCnwRDm0JLABAABIi3QkYIlEDvwPjhPz@@@ppf7@@0SLXCQo64aNBJCJRCQo"
                        . "i4QkrAAAAIXAD4XjAQAAi0QkIIXAD4Rg@@@@SIsEJIt0JBxFMcnHRCR4AAAAAESJ"
                        . "dCRwRIm8JIwAAABEiZwkkAAAAEiJRCRQSIuEJGgBAACLTCQoTIu8JDABAABMi1Qk"
                        . "UEyLhCRwAQAARItcJHhCAwyIQYE6@@@@AEeLBIiNUQKNQQFIY8lBD5fGSGPSSJhF"
                        . "D7b2QQ+2FBdBD7YEB4mUJLQAAACJhCS4AAAAweIQweAICdBBD7YUDwnQiZQkvAAA"
                        . "AImEJLAAAADrHg+v0g+vyY0UUg+vwI0Uio0EQjnDD4OvAAAASYPCCEU5ww+D4AAA"
                        . "AESLvCSgAAAAQYPDAkGLAkGLWgRFhf90Hk2FyYtUJDAPRJQksAAAAEUx9oXAQQ+U"
                        . "xolUJDCJ0InCD7bMD7bAweoQK4wkuAAAACuEJLwAAAAPttIrlCS0AAAAgfv@@@8A"
                        . "D4Z0@@@@QYnfQcHvEEUPtv8Pr9JFD6@@RDn6D4dz@@@@D7bXD6@JD6@SOdEPh2L@"
                        . "@@8PttMPr8APr9I50A+HUf@@@0WF9nQFg+4BeDtJg8EBSINEJFBYg0QkeBZEOUwk"
                        . "IA+Pkf7@@0SLdCRwRIu8JIwAAABEi5wkkAAAAOmu@f@@RYX2dcfrwESLdCRwRIu8"
                        . "JIwAAABEi5wkkAAAAOml@P@@i0QkIIt0JByFwA+Eff3@@0Ux0us5OYQkmAAAAHwY"
                        . "D6@JOYwknAAAAHwMD6@SOZQklAAAAH0Jg+4BD4hm@P@@SYPCAUQ5VCQgD44@@f@@"
                        . "SIuEJGgBAACLVCQoTIuMJDABAABCAxSQSIuEJHABAABCiwSQicGNQgKJTCQwwekQ"
                        . "SJgPtslBD7YEASnIjUoBSGPSD6@ASGPJRQ+2DAlIi0wkMA+2zUEpyUSJyUyLjCQw"
                        . "AQAAQQ+2FBFED7ZMJDBEKcqB+@@@@wAPh0r@@@8Pr8mNBEAPr9KNBIiNBFA5ww+C"
                        . "VP@@@+lY@@@@x0QkHAAAAADHRCQYAAAAAOlF9@@@RDm0JLABAABEifAPjhvx@@+J"
                        . "+CuEJMABAABFMdKDwAFBD0jCicGLhCTAAQAAjUQH@0E5w0EPTsOJxkSJ6CuEJLgB"
                        . "AACDwAFED0nQi4QkuAEAAEGNRAX@OcUPTsU5zolEJCAPjEH7@@9EieJJY8IPr9FI"
                        . "Y9JIAdBIA4QkYAEAAEmJwY1GAYlEJCiLRCQgRCnQSI1wAUQ7VCQgfxNKjRQOTInI"
                        . "gCADSIPAAUg50HX0g8EBTANMJFg7TCQoddjp6Pr@@4uMJCgBAACFyQ+FQf@@@+nU"
                        . "+v@@kJCQkJCQkJCQkJCQkA=="
                        MyFunc:=this.MCode(StrReplace((A_PtrSize=8?x64:x32),"@","/"))
                    }
                    text:=j[1], w:=j[2], h:=j[3]
                    , err1:=this.Floor(j[4] ? j[5] : ini.err1)
                    , err0:=this.Floor(j[4] ? j[6] : ini.err0)
                    , mode:=j[7], color:=j[8], n:=j[9]
                    ok:=(!ini.bits.Scan0 || mode<1 || mode>5) ? 0
                    : DllCall(MyFunc.Ptr, "int",mode, "uint",color, "uint",n, "int",dir
                    , "Ptr",ini.bits.Scan0, "int",ini.bits.Stride
                    , "int",sx, "int",sy, "int",sw, "int",sh
                    , "Ptr",ini.ss, "Ptr",ini.s1, "Ptr",ini.s0
                    , "Ptr",text, "int",w, "int",h
                    , "int",Floor(Abs(err1)*1024), "int",Floor(Abs(err0)*1024)
                    , "int",(err1<0||err0<0), "Ptr",ini.allpos, "int",ini.allpos_max
                    , "int",Floor(w*ini.zoomW), "int",Floor(h*ini.zoomH))
                    return ok
                }

                code()
                {
                    return "
                    (

//***** C source code of machine code *****
// gcc.exe -m32/-m64 -O2

int __attribute__((__stdcall__)) PicFind(
  int mode, unsigned int c, unsigned int n, int dir
  , unsigned char * Bmp, int Stride
  , int sx, int sy, int sw, int sh
  , unsigned char * ss, unsigned int * s1, unsigned int * s0
  , unsigned char * text, int w, int h
  , int err1, int err0, int more_err
  , unsigned int * allpos, int allpos_max
  , int new_w, int new_h )
{
  int ok, o, i, j, k, v, e1, e0, len1, len0, max, pic, shape, sort;
  int x, y, x1, y1, x2, y2, x3, y3, r, g, b, rr, gg, bb, dR, dG, dB;
  int ii, jj, RunDir, DirCount, RunCount, AllCount1, AllCount2;
  unsigned int c1, c2, *cors, *arr;
  unsigned char *ts, *gs;
  ok=0; o=0; v=0; len1=0; len0=0; ts=ss+sw; gs=ss+sw*3;
  arr=allpos+allpos_max; sort=(dir==0);
  //----------------------
  if (mode==5)
  {
    if (pic=(c==2))  // FindPic
    {
      cors=(unsigned int *)(text+w*h*4); j=(err0>>10)+1; n*=2;
      for (y=0; y<h; y+=j)
      {
        for (x=0; x<w; x+=j)
        {
          o=(y*w+x)*4; rr=text[2+o]; gg=text[1+o]; bb=text[o];
          for (i=2; i<n;)
          {
            c1=cors[i++]; c2=cors[i++];
            r=((c1>>16)&0xFF)-rr; g=((c1>>8)&0xFF)-gg; b=(c1&0xFF)-bb;
            v=(c2<0x1000000) ? (3*r*r+4*g*g+2*b*b<=c2)
            : (r*r<=((c2>>16)&0xFF)*((c2>>16)&0xFF)
            && g*g<=((c2>>8)&0xFF)*((c2>>8)&0xFF) && b*b<=(c2&0xFF)*(c2&0xFF));
            if (v) goto NoMatch1;
          }
          s1[len1]=(y*new_h/h)*Stride+(x*new_w/w)*4;
          s0[len1++]=rr<<16|gg<<8|bb;
          NoMatch1:;
        }
      }
      c2=cors[1]; r=(c2>>16)&0xFF; g=(c2>>8)&0xFF; b=c2&0xFF; dR=r*r; dG=g*g; dB=b*b;
    }
    else  // FindMultiColor or FindColor
    {
      shape=(c==1);  // FindShape
      cors=(unsigned int *)text;
      for (i=0; i<n; i++, o+=22)
      {
        c=cors[o]; y=c>>16; x=c&0xFFFF;
        s1[len1]=(y*new_h/h)*Stride+(x*new_w/w)*4;
        s0[len1++]=o+cors[o+1]*2;
      }
      cors+=2;
    }
    goto StartLookUp;
  }
  //----------------------
  // Generate Lookup Table
  for (y=0; y<h; y++)
  {
    for (x=0; x<w; x++)
    {
      i=(mode==4) ? (y*new_h/h)*Stride+(x*new_w/w)*4 : (y*new_h/h)*sw+(x*new_w/w);
      if (text[o++]=='1')
        s1[len1++]=i;
      else
        s0[len0++]=i;
    }
  }
  //----------------------
  // Color Position Mode
  // only used to recognize multicolored Verification Code
  if (mode==4)
  {
    y=c>>16; x=c&0xFFFF;
    c=(y*new_h/h)*Stride+(x*new_w/w)*4;
    goto StartLookUp;
  }
  //----------------------
  // Generate Two Value Image
  o=sy*Stride+sx*4; j=Stride-sw*4; i=0;
  if (mode==1)  // Color Mode
  {
    cors=(unsigned int *)(text+w*h); n*=2;
    for (y=0; y<sh; y++, o+=j)
    {
      for (x=0; x<sw; x++, o+=4, i++)
      {
        rr=Bmp[2+o]; gg=Bmp[1+o]; bb=Bmp[o];
        for (k=0; k<n;)
        {
          c1=cors[k++]; c2=cors[k++];
          r=((c1>>16)&0xFF)-rr; g=((c1>>8)&0xFF)-gg; b=(c1&0xFF)-bb;
          v=(c2<0x1000000) ? (3*r*r+4*g*g+2*b*b<=c2)
          : (r*r<=((c2>>16)&0xFF)*((c2>>16)&0xFF)
          && g*g<=((c2>>8)&0xFF)*((c2>>8)&0xFF) && b*b<=(c2&0xFF)*(c2&0xFF));
          if (v) break;
        }
        ts[i]=(v) ? 1:0;
      }
    }
  }
  else if (mode==2)  // Gray Threshold Mode
  {
    c=(c+1)<<7;
    for (y=0; y<sh; y++, o+=j)
      for (x=0; x<sw; x++, o+=4, i++)
        ts[i]=(Bmp[2+o]*38+Bmp[1+o]*75+Bmp[o]*15<c) ? 1:0;
  }
  else if (mode==3)  // Gray Difference Mode
  {
    for (y=0; y<sh; y++, o+=j)
    {
      for (x=0; x<sw; x++, o+=4, i++)
        gs[i]=(Bmp[2+o]*38+Bmp[1+o]*75+Bmp[o]*15)>>7;
    }
    for (i=0, y=0; y<sh; y++)
    for (x=0; x<sw; x++, i++)
    if (x==0 || x==sw-1 || y==0 || y==sh-1)
      ts[i]=2;
    else
    {
      n=gs[i]+c;
      ts[i]=(gs[i-1]>n || gs[i+1]>n
      || gs[i-sw]>n   || gs[i+sw]>n
      || gs[i-sw-1]>n || gs[i-sw+1]>n
      || gs[i+sw-1]>n || gs[i+sw+1]>n) ? 1:0;
    }
  }
  //----------------------
  StartLookUp:
  for (i=0, y=0; y<sh; y++)
  {
    for (x=0; x<sw; x++, i++)
    {
      if (mode>=4) { ss[i]=4; continue; }
      r=ts[i]; g=(x==0 ? 3 : ts[i-1]); b=(x==sw-1 ? 3 : ts[i+1]);
      if (more_err)
        ss[i]=4|(r==2||r==1||g==1||b==1)<<1|(r==2||r==0||g==0||b==0);
      else
        ss[i]=4|(r==2||r==1)<<1|(r==2||r==0);
    }
  }
  if (mode<4 && more_err) sx++;
  err1=(len1*err1)>>10;
  err0=(len0*err0)>>10;
  if (err1>=len1) len1=0;
  if (err0>=len0) len0=0;
  max=(len1>len0) ? len1 : len0;
  w=new_w; h=new_h; x1=0; y1=0; x2=sw-w; y2=sh-h;
  // 1 ==> ( Left to Right ) Top to Bottom
  // 2 ==> ( Right to Left ) Top to Bottom
  // 3 ==> ( Left to Right ) Bottom to Top
  // 4 ==> ( Right to Left ) Bottom to Top
  // 5 ==> ( Top to Bottom ) Left to Right
  // 6 ==> ( Bottom to Top ) Left to Right
  // 7 ==> ( Top to Bottom ) Right to Left
  // 8 ==> ( Bottom to Top ) Right to Left
  // 9 ==> Center to Four Sides
  if (dir==9)
  {
    x=(x1+x2)/2; y=(y1+y2)/2; i=x2-x1+1; j=y2-y1+1;
    AllCount1=i*j; i=(i>j?i:j)+8;
    AllCount2=i*i; RunCount=0; DirCount=1; RunDir=0;
    for (ii=0; RunCount<AllCount1 && ii<AllCount2;)
    {
      for(jj=0; jj<DirCount; jj++, ii++)
      {
        if(x>=x1 && x<=x2 && y>=y1 && y<=y2)
        {
          RunCount++;
          goto FindPos;
          FindPos_GoBak:;
        }
        if (RunDir==0) y--;
        else if (RunDir==1) x++;
        else if (RunDir==2) y++;
        else x--;
      }
      if (RunDir & 1) DirCount++;
      RunDir = (++RunDir) & 3;
    }
    goto Return1;
  }
  if (dir<1 || dir>8) dir=1;
  if (--dir>3) { r=y1; y1=x1; x1=r; r=y2; y2=x2; x2=r; }
  for (y3=y1; y3<=y2; y3++)
  {
    for (x3=x1; x3<=x2; x3++)
    {
      y=(dir & 2) ? y1+y2-y3 : y3;
      x=(dir & 1) ? x1+x2-x3 : x3;
      if (dir>3) { r=y; y=x; x=r; }
      //----------------------
      FindPos:
      e1=err1; e0=err0; o=y*sw+x;
      if (ss[o]<4) goto NoMatch;
      if (mode<4)
      {
        for (i=0; i<max; i++)
        {
          if (i<len1 && (ss[o+s1[i]]&2)==0 && (--e1)<0) goto NoMatch;
          if (i<len0 && (ss[o+s0[i]]&1)==0 && (--e0)<0) goto NoMatch;
        }
      }
      else if (mode==5)
      {
        o=(sy+y)*Stride+(sx+x)*4;
        if (pic)
        {
          for (i=0; i<max; i++)
          {
            j=o+s1[i]; c=s0[i]; r=Bmp[2+j]-((c>>16)&0xFF);
            g=Bmp[1+j]-((c>>8)&0xFF); b=Bmp[j]-(c&0xFF);
            v=(c2<0x1000000)?(3*r*r+4*g*g+2*b*b>c2):(r*r>dR||g*g>dG||b*b>dB);
            if (v && (--e1)<0) goto NoMatch;
          }
        }
        else
        {
          for (i=0; i<max; i++)
          {
            j=o+s1[i]; rr=Bmp[2+j]; gg=Bmp[1+j]; bb=Bmp[j];
            for (j=i*22, k=cors[j]>0xFFFFFF, n=s0[i]; j<n;)
            {
              c1=cors[j++]; c2=cors[j++];
              if (shape) { if (i==0) c=rr<<16|gg<<8|bb; k=!c1; c1=c; }
              r=((c1>>16)&0xFF)-rr; g=((c1>>8)&0xFF)-gg; b=(c1&0xFF)-bb;
              v=(c2<0x1000000) ? (3*r*r+4*g*g+2*b*b<=c2)
              : (r*r<=((c2>>16)&0xFF)*((c2>>16)&0xFF)
              && g*g<=((c2>>8)&0xFF)*((c2>>8)&0xFF) && b*b<=(c2&0xFF)*(c2&0xFF));
              if (v) { if (k) goto NoMatch2; goto MatchOK; }
            }
            if (k) goto MatchOK;
            NoMatch2:
            if ((--e1)<0) goto NoMatch;
            MatchOK:;
          }
        }
      }
      else  // mode==4
      {
        o=(sy+y)*Stride+(sx+x)*4; j=o+c; rr=Bmp[2+j]; gg=Bmp[1+j]; bb=Bmp[j];
        for (i=0; i<max; i++)
        {
          if (i<len1)
          {
            j=o+s1[i]; r=Bmp[2+j]-rr; g=Bmp[1+j]-gg; b=Bmp[j]-bb;
            if (3*r*r+4*g*g+2*b*b>n && (--e1)<0) goto NoMatch;
          }
          if (i<len0)
          {
            j=o+s0[i]; r=Bmp[2+j]-rr; g=Bmp[1+j]-gg; b=Bmp[j]-bb;
            if (3*r*r+4*g*g+2*b*b<=n && (--e0)<0) goto NoMatch;
          }
        }
      }
      ok++;
      if (allpos)
      {
        allpos[ok-1]=(sy+y)<<16|(sx+x); if (sort) arr[ok-1]=err1-e1;
        if (ok>=allpos_max) goto Return1;
      }
      // Skip areas that may overlap
      if (!sort)
      {
        r=y-h+1; if (r<0) r=0; rr=y+h-1; if (rr>sh-h) rr=sh-h;
        g=x-w+1; if (g<0) g=0; gg=x+w-1; if (gg>sw-w) gg=sw-w;
        for (i=r; i<=rr; i++)
          for (j=g; j<=gg; j++)
            ss[i*sw+j] &= 3;
      }
      NoMatch:
      if (dir==9) goto FindPos_GoBak;
    }
  }
  //----------------------
  Return1:
  if (!sort || !allpos || w*h==1)
    return ok;
  // Sort by smallest error
  for (i=1; i<ok; i++)
  {
    k=arr[i]; v=allpos[i];
    for (j=i-1; j>=0 && arr[j]>k; j--)
    {
      arr[j+1]=arr[j]; allpos[j+1]=allpos[j];
    }
    arr[j+1]=k; allpos[j+1]=v;
  }
  // Clean up overlapping results
  w*=w; h*=h; k=ok; ok=0;
  for (i=0; i<k; i++)
  {
    c1=allpos[i]; x1=c1&0xFFFF; y1=c1>>16;
    for (j=0; j<ok; j++)
    {
      c2=allpos[j]; x=(c2&0xFFFF)-x1; y=(c2>>16)-y1;
      if (x*x<w && y*y<h) goto NoMatch3;
    }
    allpos[ok++]=c1;
    NoMatch3:;
  }
  return ok;
}

)"
}

PicInfo(text)
{
  local
  if !InStr(text, "$")
    return
  static init, info, bmp
  if !VarSetCapacity(init) && (init:="1")
    info:=[], bmp:=[]
  key:=(r:=StrLen(v:=Trim(text,"|")))<10000 ? v
    : DllCall("ntdll\RtlComputeCrc32", "uint",0
    , "Ptr",&v, "uint",r*(1+!!A_IsUnicode), "uint")
  if info.HasKey(key)
    return info[key]
  comment:="", seterr:=err1:=err0:=0
  ; You Can Add Comment Text within The <>
  if RegExMatch(v, "O)<([^>\n]*)>", r)
    v:=StrReplace(v,r[0]), comment:=Trim(r[1])
  ; You can Add two fault-tolerant in the [], separated by commas
  if RegExMatch(v, "O)\[([^\]\n]*)]", r)
  {
    v:=StrReplace(v,r[0]), r:=StrSplit(r[1] ",", ",")
    , seterr:=1, err1:=r[1], err0:=r[2]
  }
  color:=SubStr(v,1,InStr(v,"$")-1), v:=Trim(SubStr(v,InStr(v,"$")+1))
  mode:=InStr(color,"##") ? 5 : InStr(color,"#") ? 4
    : InStr(color,"**") ? 3 : InStr(color,"*") ? 2 : 1
  color:=RegExReplace(StrReplace(color,"@","-"), "[*#\s]")
  (mode=1 || mode=5) && color:=StrReplace(color,"0x")
  if (mode=5)
  {
    if !(v~="^[\s\-\w.]+/[\s\-\w.]+/[\s\-\w./,]+$")  ; <FindPic>
    {
      if !(hBM:=LoadPicture(v))
      {
        MsgBox, 4096, Tip, Can't Load Picture ! %v%
        return
      }
      this.GetBitmapWH(hBM, w, h)
      if (w<1 || h<1)
        return
      hBM2:=this.CreateDIBSection(w, h, 32, Scan0)
      this.CopyHBM(hBM2, 0, 0, hBM, 0, 0, w, h)
      DllCall("DeleteObject", "Ptr",hBM)
      if (!Scan0)
        return
      arr:=StrSplit(color "/", "/"), arr.Pop(), n:=arr.Length()
      bmp.Push(buf:=this.Buffer(w*h*4 + n*2*4)), v:=buf.Ptr, p:=v+w*h*4-4
      DllCall("RtlMoveMemory", "Ptr",v, "Ptr",Scan0, "Ptr",w*h*4)
      DllCall("DeleteObject", "Ptr",hBM2), color:=Trim(arr[1],"-")
      For k1,v1 in arr
        c:=StrSplit(Trim(v1,"-") "-" color, "-")
        , x:=this.Floor(c[2]), x:=(x<=0||x>1?0:Floor(9*255*255*(1-x)*(1-x)))
        , NumPut(this.ToRGB(c[1]), 0|p+=4, "uint")
        , NumPut((InStr(c[2],".")?x:this.Floor("0x" c[2])|0x1000000), 0|p+=4, "uint")
      color:=2
    }
    else  ; <FindMultiColor> or <FindColor> or <FindShape>
    {
      color:=Trim(StrSplit(color "/", "/")[1], "-")
      arr:=StrSplit(Trim(RegExReplace(v, "i)\s|0x"), ","), ",")
      if !(n:=arr.Length())
        return
      bmp.Push(buf:=this.Buffer(n*22*4)), v:=buf.Ptr
      shape:=(n>1 && StrLen(StrSplit(arr[1] "//","/")[3])=1 ? 1:0)
      For k1,v1 in arr
      {
        r:=StrSplit(v1 "/","/"), x:=this.Floor(r[1]), y:=this.Floor(r[2])
        , (A_Index=1) ? (x1:=x2:=x, y1:=y2:=y)
        : (x1:=Min(x1,x), x2:=Max(x2,x), y1:=Min(y1,y), y2:=Max(y2,y))
      }
      For k1,v1 in arr
      {
        r:=StrSplit(v1 "/","/"), x:=this.Floor(r[1])-x1, y:=this.Floor(r[2])-y1
        , NumPut(y<<16|x, 0|p:=v+(A_Index-1)*22*4, "uint")
        , NumPut(n1:=Min(Max(r.Length()-3,0),(shape?1:10)), 0|p+=4, "uint")
        Loop % n1
          c:=StrSplit(Trim(v1:=r[2+A_Index],"-") "-" color, "-")
          , x:=this.Floor(c[2]), x:=(x<=0||x>1?0:Floor(9*255*255*(1-x)*(1-x)))
          , NumPut(this.ToRGB(c[1])&0xFFFFFF|(!shape&&InStr(v1,"-")=1?0x1000000:0), 0|p+=4, "uint")
          , NumPut((InStr(c[2],".")?x:this.Floor("0x" c[2])|0x1000000), 0|p+=4, "uint")
      }
      color:=shape, w:=x2-x1+1, h:=y2-y1+1
    }
  }
  else
  {
    r:=StrSplit(v ".", "."), w:=this.Floor(r[1])
    , v:=this.base64tobit(r[2]), h:=StrLen(v)//w
    if (w<1 || h<1 || StrLen(v)!=w*h)
      return
    arr:=StrSplit(color "/", "/"), arr.Pop(), n:=arr.Length()
    , bmp.Push(buf:=this.Buffer(StrPut(v, "CP0") + n*2*4))
    , StrPut(v, buf.Ptr, "CP0"), v:=buf.Ptr, p:=v+w*h-4
    , color:=this.Floor(color)
    if (mode=1)
    {
      For k1,v1 in arr
        c:=StrSplit(Trim(v1,"-") "-", "-")
        , x:=this.Floor(c[2]), x:=(x<=0||x>1?0:Floor(9*255*255*(1-x)*(1-x)))
        , NumPut(this.ToRGB(c[1]), 0|p+=4, "uint")
        , NumPut((InStr(c[2],".")?x:this.Floor("0x" c[2])|0x1000000), 0|p+=4, "uint")
    }
    else if (mode=4)
    {
      r:=StrSplit(Trim(arr[1],"-") "-", "-")
      , n:=this.Floor(r[2]), n:=(n<=0||n>1?0:Floor(9*255*255*(1-n)*(1-n)))
      , c:=this.Floor(r[1]), color:=(c<1||c>w*h?0:((c-1)//w)<<16|Mod(c-1,w))
    }
  }
  return info[key]:=[v, w, h, seterr, err1, err0, mode, color, n, comment]
}

ToRGB(color)  ; color can use: RRGGBB, Red, Yellow, Black, White
{
  static init, tab
  if !VarSetCapacity(init) && (init:="1")
    tab:=Object("Black", "000000", "White", "FFFFFF"
    , "Red", "FF0000", "Green", "008000", "Blue", "0000FF"
    , "Yellow", "FFFF00", "Silver", "C0C0C0", "Gray", "808080"
    , "Teal", "008080", "Navy", "000080", "Aqua", "00FFFF"
    , "Olive", "808000", "Lime", "00FF00", "Fuchsia", "FF00FF"
    , "Purple", "800080", "Maroon", "800000")
  return this.Floor("0x" (tab.HasKey(color)?tab[color]:color))
}

Buffer(size, FillByte:="")
{
  local
  buf:={}, buf.SetCapacity("_key", size), p:=buf.GetAddress("_key")
  , (FillByte!="" && DllCall("RtlFillMemory","Ptr",p,"Ptr",size,"uchar",FillByte))
  , buf.Ptr:=p, buf.Size:=size
  return buf
}

GetBitsFromScreen(ByRef x:=0, ByRef y:=0, ByRef w:=0, ByRef h:=0
  , ScreenShot:=1, ByRef zx:=0, ByRef zy:=0, ByRef zw:=0, ByRef zh:=0)
{
  local
  static init, CAPTUREBLT
  if !VarSetCapacity(init) && (init:="1")  ; thanks Descolada
  {
    DllCall("Dwmapi\DwmIsCompositionEnabled", "Int*",i:=0)
    CAPTUREBLT:=i ? 0 : 0x40000000
  }
  if InStr(A_OSVersion, ".")  ; thanks QQ:349029755
    Try DllCall("SetThreadDpiAwarenessContext", "Ptr",-3, "Ptr")
  (!IsObject(this.bits) && this.bits:={Scan0:0, hBM:0, oldzw:0, oldzh:0})
  , bits:=this.bits
  if (!ScreenShot && bits.Scan0)
  {
    zx:=bits.zx, zy:=bits.zy, zw:=bits.zw, zh:=bits.zh
    , w:=Min(x+w,zx+zw), x:=Max(x,zx), w-=x
    , h:=Min(y+h,zy+zh), y:=Max(y,zy), h-=y
    return bits
  }
  bch:=A_BatchLines, cri:=A_IsCritical
  Critical
  bits.BindWindow:=id:=this.BindWindow(0,0,1)
  if (id)
  {
    WinGet, id, ID, ahk_id %id%
    WinGetPos, zx, zy, zw, zh, ahk_id %id%
  }
  if (!id)
  {
    SysGet, zx, 76
    SysGet, zy, 77
    SysGet, zw, 78
    SysGet, zh, 79
  }
  this.UpdateBits(bits, zx, zy, zw, zh)
  , w:=Min(x+w,zx+zw), x:=Max(x,zx), w-=x
  , h:=Min(y+h,zy+zh), y:=Max(y,zy), h-=y
  if (!ScreenShot || w<1 || h<1 || !bits.hBM)
  {
    Critical % cri
    SetBatchLines % bch
    return bits
  }
  if IsFunc(k:="GetBitsFromScreen2")
    && %k%(bits, x-zx, y-zy, w, h)
  {
    ; Get the bind window use bits.BindWindow
    ; Each small range of data obtained from DXGI must be
    ; copied to the screenshot cache using FindText().CopyBits()
    zx:=bits.zx, zy:=bits.zy, zw:=bits.zw, zh:=bits.zh
    Critical % cri
    SetBatchLines % bch
    return bits
  }
  mDC:=DllCall("CreateCompatibleDC", "Ptr",0, "Ptr")
  oBM:=DllCall("SelectObject", "Ptr",mDC, "Ptr",bits.hBM, "Ptr")
  if (id)
  {
    if (mode:=this.BindWindow(0,0,0,1))<2
    {
      hDC:=DllCall("GetDCEx", "Ptr",id, "Ptr",0, "int",3, "Ptr")
      DllCall("BitBlt","Ptr",mDC,"int",x-zx,"int",y-zy,"int",w,"int",h
        , "Ptr",hDC, "int",x-zx, "int",y-zy, "uint",0xCC0020|CAPTUREBLT)
      DllCall("ReleaseDC", "Ptr",id, "Ptr",hDC)
    }
    else
    {
      hBM2:=this.CreateDIBSection(zw, zh)
      mDC2:=DllCall("CreateCompatibleDC", "Ptr",0, "Ptr")
      oBM2:=DllCall("SelectObject", "Ptr",mDC2, "Ptr",hBM2, "Ptr")
      DllCall("UpdateWindow", "Ptr",id)
      ; RDW_INVALIDATE=0x1|RDW_ERASE=0x4|RDW_ALLCHILDREN=0x80|RDW_FRAME=0x400
      ; DllCall("RedrawWindow", "Ptr",id, "Ptr",0, "Ptr",0, "uint", 0x485)
      DllCall("PrintWindow", "Ptr",id, "Ptr",mDC2, "uint",(mode>3)*3)
      DllCall("BitBlt","Ptr",mDC,"int",x-zx,"int",y-zy,"int",w,"int",h
        , "Ptr",mDC2, "int",x-zx, "int",y-zy, "uint",0xCC0020)
      DllCall("SelectObject", "Ptr",mDC2, "Ptr",oBM2)
      DllCall("DeleteDC", "Ptr",mDC2)
      DllCall("DeleteObject", "Ptr",hBM2)
    }
  }
  else
  {
    hDC:=DllCall("GetWindowDC","Ptr",id:=DllCall("GetDesktopWindow","Ptr"),"Ptr")
    DllCall("BitBlt","Ptr",mDC,"int",x-zx,"int",y-zy,"int",w,"int",h
      , "Ptr",hDC, "int",x, "int",y, "uint",0xCC0020|CAPTUREBLT)
    DllCall("ReleaseDC", "Ptr",id, "Ptr",hDC)
  }
  if this.CaptureCursor(0,0,0,0,0,1)
    this.CaptureCursor(mDC, zx, zy, zw, zh)
  DllCall("SelectObject", "Ptr",mDC, "Ptr",oBM)
  DllCall("DeleteDC", "Ptr",mDC)
  Critical % cri
  SetBatchLines % bch
  return bits
}

UpdateBits(bits, zx, zy, zw, zh)
{
  local
  if (zw>bits.oldzw || zh>bits.oldzh || !bits.hBM)
  {
    Try DllCall("DeleteObject", "Ptr",bits.hBM)
    bits.hBM:=this.CreateDIBSection(zw, zh, bpp:=32, ppvBits)
    , bits.Scan0:=(!bits.hBM ? 0:ppvBits)
    , bits.Stride:=((zw*bpp+31)//32)*4
    , bits.oldzw:=zw, bits.oldzh:=zh
  }
  bits.zx:=zx, bits.zy:=zy, bits.zw:=zw, bits.zh:=zh
}

CreateDIBSection(w, h, bpp:=32, ByRef ppvBits:=0)
{
  local
  VarSetCapacity(bi, 40, 0), NumPut(40, bi, 0, "int")
  , NumPut(w, bi, 4, "int"), NumPut(-h, bi, 8, "int")
  , NumPut(1, bi, 12, "short"), NumPut(bpp, bi, 14, "short")
  return DllCall("CreateDIBSection", "Ptr",0, "Ptr",&bi
    , "int",0, "Ptr*",ppvBits:=0, "Ptr",0, "int",0, "Ptr")
}

GetBitmapWH(hBM, ByRef w, ByRef h)
{
  local
  VarSetCapacity(bm, size:=(A_PtrSize=8 ? 32:24), 0)
  , DllCall("GetObject", "Ptr",hBM, "int",size, "Ptr",&bm)
  , w:=NumGet(bm,4,"int"), h:=Abs(NumGet(bm,8,"int"))
}

CopyHBM(hBM1, x1, y1, hBM2, x2, y2, w, h, Clear:=0)
{
  local
  if (w<1 || h<1 || !hBM1 || !hBM2)
    return
  mDC1:=DllCall("CreateCompatibleDC", "Ptr",0, "Ptr")
  oBM1:=DllCall("SelectObject", "Ptr",mDC1, "Ptr",hBM1, "Ptr")
  mDC2:=DllCall("CreateCompatibleDC", "Ptr",0, "Ptr")
  oBM2:=DllCall("SelectObject", "Ptr",mDC2, "Ptr",hBM2, "Ptr")
  DllCall("BitBlt", "Ptr",mDC1, "int",x1, "int",y1, "int",w, "int",h
  , "Ptr",mDC2, "int",x2, "int",y2, "uint",0xCC0020)
  if (Clear)
    DllCall("BitBlt", "Ptr",mDC1, "int",x1, "int",y1, "int",w, "int",h
    , "Ptr",mDC1, "int",x1, "int",y1, "uint",MERGECOPY:=0xC000CA)
  DllCall("SelectObject", "Ptr",mDC1, "Ptr",oBM1)
  DllCall("DeleteDC", "Ptr",mDC1)
  DllCall("SelectObject", "Ptr",mDC2, "Ptr",oBM2)
  DllCall("DeleteDC", "Ptr",mDC2)
}

CopyBits(Scan01,Stride1,x1,y1,Scan02,Stride2,x2,y2,w,h,Reverse:=0)
{
  local
  if (w<1 || h<1 || !Scan01 || !Scan02)
    return
  static init, MFCopyImage
  if !VarSetCapacity(init) && (init:="1")
  {
    MFCopyImage:=DllCall("GetProcAddress", "Ptr"
    , DllCall("LoadLibrary", "Str","Mfplat.dll", "Ptr")
    , "AStr","MFCopyImage", "Ptr")
  }
  if (MFCopyImage && !Reverse)  ; thanks QQ:121507989
  {
    return DllCall(MFCopyImage
      , "Ptr",Scan01+y1*Stride1+x1*4, "int",Stride1
      , "Ptr",Scan02+y2*Stride2+x2*4, "int",Stride2
      , "uint",w*4, "uint",h)
  }
  ListLines % (lls:=A_ListLines)?0:0
  SetBatchLines % (bch:=A_BatchLines)?"-1":"-1"
  p1:=Scan01+(y1-1)*Stride1+x1*4
  , p2:=Scan02+(y2-1)*Stride2+x2*4, w*=4
  , (Reverse) && (p2+=(h+1)*Stride2, Stride2:=-Stride2)
  Loop % h
    DllCall("RtlMoveMemory","Ptr",p1+=Stride1,"Ptr",p2+=Stride2,"Ptr",w)
  SetBatchLines % bch
  ListLines % lls
}

DrawHBM(hBM, lines)
{
  local
  mDC:=DllCall("CreateCompatibleDC", "Ptr",0, "Ptr")
  oBM:=DllCall("SelectObject", "Ptr",mDC, "Ptr",hBM, "Ptr")
  oldc:="", brush:=0, VarSetCapacity(rect, 16)
  For k,v in lines  ; [ [x, y, w, h, color] ]
  if IsObject(v)
  {
    if (oldc!=v[5])
    {
      oldc:=v[5], BGR:=(oldc&0xFF)<<16|oldc&0xFF00|(oldc>>16)&0xFF
      DllCall("DeleteObject", "Ptr",brush)
      brush:=DllCall("CreateSolidBrush", "uint",BGR, "Ptr")
    }
    DllCall("SetRect", "Ptr",&rect, "int",v[1], "int",v[2]
      , "int",v[1]+v[3], "int",v[2]+v[4])
    DllCall("FillRect", "Ptr",mDC, "Ptr",&rect, "Ptr",brush)
  }
  DllCall("DeleteObject", "Ptr",brush)
  DllCall("SelectObject", "Ptr",mDC, "Ptr",oBM)
  DllCall("DeleteObject", "Ptr",mDC)
}

; Bind the window so that it can find images when obscured
; by other windows, it's equivalent to always being
; at the front desk. Unbind Window using FindText().BindWindow(0)

BindWindow(bind_id:=0, bind_mode:=0, get_id:=0, get_mode:=0)
{
  local
  (!IsObject(this.bind) && this.bind:={id:0, mode:0, oldStyle:0})
  , bind:=this.bind
  if (get_id)
    return bind.id
  if (get_mode)
    return bind.mode
  if (bind_id)
  {
    bind.id:=bind_id:=this.Floor(bind_id)
    , bind.mode:=bind_mode, bind.oldStyle:=0
    if (bind_mode & 1)
    {
      WinGet, i, ExStyle, ahk_id %bind_id%
      bind.oldStyle:=i
      WinSet, Transparent, 255, ahk_id %bind_id%
      Loop 30
      {
        Sleep 100
        WinGet, i, Transparent, ahk_id %bind_id%
      }
      Until (i=255)
    }
  }
  else
  {
    bind_id:=bind.id
    if (bind.mode & 1)
      WinSet, ExStyle, % bind.oldStyle, ahk_id %bind_id%
    bind.id:=0, bind.mode:=0, bind.oldStyle:=0
  }
}

; Use FindText().CaptureCursor(1) to Capture Cursor
; Use FindText().CaptureCursor(0) to Cancel Capture Cursor

CaptureCursor(hDC:=0, zx:=0, zy:=0, zw:=0, zh:=0, get_cursor:=0)
{
  local
  if (get_cursor)
    return this.Cursor
  if (hDC=1 || hDC=0) && (zw=0)
  {
    this.Cursor:=hDC
    return
  }
  VarSetCapacity(mi, 40, 0), NumPut(16+A_PtrSize, mi, "int")
  DllCall("GetCursorInfo", "Ptr",&mi)
  bShow:=NumGet(mi, 4, "int")
  hCursor:=NumGet(mi, 8, "Ptr")
  x:=NumGet(mi, 8+A_PtrSize, "int")
  y:=NumGet(mi, 12+A_PtrSize, "int")
  if (!bShow) || (x<zx || y<zy || x>=zx+zw || y>=zy+zh)
    return
  VarSetCapacity(ni, 40, 0)
  DllCall("GetIconInfo", "Ptr",hCursor, "Ptr",&ni)
  xCenter:=NumGet(ni, 4, "int")
  yCenter:=NumGet(ni, 8, "int")
  hBMMask:=NumGet(ni, (A_PtrSize=8?16:12), "Ptr")
  hBMColor:=NumGet(ni, (A_PtrSize=8?24:16), "Ptr")
  DllCall("DrawIconEx", "Ptr",hDC
    , "int",x-xCenter-zx, "int",y-yCenter-zy, "Ptr",hCursor
    , "int",0, "int",0, "int",0, "int",0, "int",3)
  DllCall("DeleteObject", "Ptr",hBMMask)
  DllCall("DeleteObject", "Ptr",hBMColor)
}

MCode(hex)
{
  local
  flag:=((hex~="[^A-Fa-f\d\s]") ? 1:4), len:=0
  Loop 2
    if !DllCall("crypt32\CryptStringToBinary", "Str",hex, "uint",0, "uint",flag
    , "Ptr",(A_Index=1?0:(p:=this.Buffer(len)).Ptr), "uint*",len, "Ptr",0, "Ptr",0)
      return
  if DllCall("VirtualProtect", "Ptr",p.Ptr, "Ptr",len, "uint",0x40, "uint*",0)
    return p
}

bin2hex(addr, size, base64:=0)
{
  local
  flag:=(base64 ? 1:4)|0x40000000, len:=0
  Loop 2
    DllCall("crypt32\CryptBinaryToString", "Ptr",addr, "uint",size, "uint",flag
    , "Ptr",(A_Index=1?0:(p:=this.Buffer(len*2)).Ptr), "uint*",len)
  return RegExReplace(StrGet(p.Ptr, len), "\s+")
}

base64tobit(s)
{
  local
  ListLines % (lls:=A_ListLines)?0:0
  Chars:="0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
  SetFormat, IntegerFast, d
  Loop Parse, Chars
    if InStr(s, A_LoopField, 1)
      s:=RegExReplace(s, "[" A_LoopField "]", ((i:=A_Index-1)>>5&1)
      . (i>>4&1) . (i>>3&1) . (i>>2&1) . (i>>1&1) . (i&1))
  s:=RegExReplace(RegExReplace(s,"[^01]+"),"10*$")
  ListLines % lls
  return s
}

bit2base64(s)
{
  local
  ListLines % (lls:=A_ListLines)?0:0
  s:=RegExReplace(s,"[^01]+")
  s.=SubStr("100000",1,6-Mod(StrLen(s),6))
  s:=RegExReplace(s,".{6}","|$0")
  Chars:="0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
  SetFormat, IntegerFast, d
  Loop Parse, Chars
    s:=StrReplace(s, "|" . ((i:=A_Index-1)>>5&1)
    . (i>>4&1) . (i>>3&1) . (i>>2&1) . (i>>1&1) . (i&1), A_LoopField)
  ListLines % lls
  return s
}

ASCII(s)
{
  local
  if RegExMatch(s, "O)\$(\d+)\.([\w+/]+)", r)
  {
    s:=RegExReplace(this.base64tobit(r[2]),".{" r[1] "}","$0`n")
    s:=StrReplace(StrReplace(s,"0","_"),"1","0")
  }
  else s:=""
  return s
}

; You can put the text library at the beginning of the script,
; and Use FindText().PicLib(Text,1) to add the text library to PicLib()'s Lib,
; Use FindText().PicLib("comment1|comment2|...") to get text images from Lib

PicLib(comments, add_to_Lib:=0, index:=1)
{
  local
  (!IsObject(this.Lib) && this.Lib:=[]), Lib:=this.Lib
  , (!Lib.HasKey(index) && Lib[index]:=[]), Lib:=Lib[index]
  if (add_to_Lib)
  {
    re:="O)<([^>\n]*)>[^$\n]+\$[^""\r\n]+"
    Loop Parse, comments, |
      if RegExMatch(A_LoopField, re, r)
      {
        s1:=Trim(r[1]), s2:=""
        Loop Parse, s1
          s2.=Format("_{:d}", Ord(A_LoopField))
        (s2!="") && Lib[s2]:=r[0]
      }
  }
  else
  {
    Text:=""
    Loop Parse, comments, |
    {
      s1:=Trim(A_LoopField), s2:=""
      Loop Parse, s1
        s2.=Format("_{:d}", Ord(A_LoopField))
      (Lib.HasKey(s2)) && Text.="|" Lib[s2]
    }
    return Text
  }
}

; Decompose a string into individual characters and get their data

PicN(Number, index:=1)
{
  return this.PicLib(RegExReplace(Number,".","|$0"), 0, index)
}

; Use FindText().PicX(Text) to automatically cut into multiple characters
; Can't be used in ColorPos mode, because it can cause position errors

PicX(Text)
{
  local
  if !RegExMatch(Text, "O)(<[^$\n]+)\$(\d+)\.([\w+/]+)", r)
    return Text
  v:=this.base64tobit(r[3]), Text:=""
  c:=StrLen(StrReplace(v,"0"))<=StrLen(v)//2 ? "1":"0"
  txt:=RegExReplace(v,".{" r[2] "}","$0`n")
  While InStr(txt,c)
  {
    While !(txt~="m`n)^" c)
      txt:=RegExReplace(txt,"m`n)^.")
    i:=0
    While (txt~="m`n)^.{" i "}" c)
      i:=Format("{:d}",i+1)
    v:=RegExReplace(txt,"m`n)^(.{" i "}).*","$1")
    txt:=RegExReplace(txt,"m`n)^.{" i "}")
    if (v!="")
      Text.="|" r[1] "$" i "." this.bit2base64(v)
  }
  return Text
}

; Screenshot and retained as the last screenshot.

ScreenShot(x1:=0, y1:=0, x2:=0, y2:=0)
{
  this.FindText(,, x1, y1, x2, y2)
}

; Get the RGB color of a point from the last screenshot.
; If the point to get the color is beyond the range of
; Screen, it will return White color (0xFFFFFF).

GetColor(x, y, fmt:=1)
{
  local
  bits:=this.GetBitsFromScreen(,,,,0,zx,zy,zw,zh), x-=zx, y-=zy
  , c:=(x>=0 && x<zw && y>=0 && y<zh && bits.Scan0)
  ? NumGet(bits.Scan0+y*bits.Stride+x*4,"uint") : 0xFFFFFF
  return (fmt ? Format("0x{:06X}",c&0xFFFFFF) : c)
}

; Set the RGB color of a point in the last screenshot

SetColor(x, y, color:=0x000000)
{
  local
  bits:=this.GetBitsFromScreen(,,,,0,zx,zy,zw,zh), x-=zx, y-=zy
  if (x>=0 && x<zw && y>=0 && y<zh && bits.Scan0)
    NumPut(color, bits.Scan0+y*bits.Stride+x*4, "uint")
}

; Identify a line of text or verification code
; based on the result returned by FindText().
; offsetX is the maximum interval between two texts,
; if it exceeds, a "*" sign will be inserted.
; offsetY is the maximum height difference between two texts.
; overlapW is used to set the width of the overlap.
; Return Association array {text:Text, x:X, y:Y, w:W, h:H}

Ocr(ok, offsetX:=20, offsetY:=20, overlapW:=0)
{
  local
  ocr_Text:=ocr_X:=ocr_Y:=min_X:=dx:=""
  For k,v in ok
    x:=v.1
    , min_X:=(A_Index=1 || x<min_X ? x : min_X)
    , max_X:=(A_Index=1 || x>max_X ? x : max_X)
  While (min_X!="" && min_X<=max_X)
  {
    LeftX:=""
    For k,v in ok
    {
      x:=v.1, y:=v.2
      if (x<min_X) || (ocr_Y!="" && Abs(y-ocr_Y)>offsetY)
        Continue
      ; Get the leftmost X coordinates
      if (LeftX="" || x<LeftX)
        LeftX:=x, LeftY:=y, LeftW:=v.3, LeftH:=v.4, LeftOCR:=v.id
    }
    if (LeftX="")
      Break
    if (ocr_X="")
      ocr_X:=LeftX, min_Y:=LeftY, max_Y:=LeftY+LeftH
    ; If the interval exceeds the set value, add "*" to the result
    ocr_Text.=(ocr_Text!="" && LeftX>dx ? "*":"") . LeftOCR
    ; Update for next search
    min_X:=LeftX+LeftW-(overlapW>LeftW//2 ? LeftW//2:overlapW)
    , dx:=LeftX+LeftW+offsetX, ocr_Y:=LeftY
    , (LeftY<min_Y && min_Y:=LeftY)
    , (LeftY+LeftH>max_Y && max_Y:=LeftY+LeftH)
  }
  (ocr_X="") && ocr_X:=min_Y:=min_X:=max_Y:=0
  return {text:ocr_Text, x:ocr_X, y:min_Y, w:min_X-ocr_X, h:max_Y-min_Y}
}

; Sort the results of FindText() from left to right
; and top to bottom, ignore slight height difference

Sort(ok, dy:=10)
{
  local
  if !IsObject(ok)
    return ok
  s:="", n:=150000, ypos:=[]
  For k,v in ok
  {
    x:=v.x, y:=v.y, add:=1
    For k1,v1 in ypos
    if Abs(y-v1)<=dy
    {
      y:=v1, add:=0
      Break
    }
    if (add)
      ypos.Push(y)
    s.=(y*n+x) "." k "|"
  }
  s:=Trim(s,"|")
  Sort, s, N D|
  ok2:=[]
  For k,v in StrSplit(s,"|")
    ok2.Push(ok[SubStr(v,InStr(v,".")+1)])
  return ok2
}

; Sort the results of FindText() according to the nearest distance

Sort2(ok, px, py)
{
  local
  if !IsObject(ok)
    return ok
  s:=""
  For k,v in ok
    s.=((v.x-px)**2+(v.y-py)**2) "." k "|"
  s:=Trim(s,"|")
  Sort, s, N D|
  ok2:=[]
  For k,v in StrSplit(s,"|")
    ok2.Push(ok[SubStr(v,InStr(v,".")+1)])
  return ok2
}

; Sort the results of FindText() according to the search direction

Sort3(ok, dir:=1)
{
  local
  if !IsObject(ok)
    return ok
  s:="", n:=150000
  For k,v in ok
    x:=v.1, y:=v.2
    , s.=(dir=1 ? y*n+x
    : dir=2 ? y*n-x
    : dir=3 ? -y*n+x
    : dir=4 ? -y*n-x
    : dir=5 ? x*n+y
    : dir=6 ? x*n-y
    : dir=7 ? -x*n+y
    : dir=8 ? -x*n-y : y*n+x) "." k "|"
  s:=Trim(s,"|")
  Sort, s, N D|
  ok2:=[]
  For k,v in StrSplit(s,"|")
    ok2.Push(ok[SubStr(v,InStr(v,".")+1)])
  return ok2
}

; Prompt mouse position in remote assistance

MouseTip(x:="", y:="", w:=10, h:=10, d:=3)
{
  local
  if (x="")
  {
    VarSetCapacity(pt,16,0), DllCall("GetCursorPos","Ptr",&pt)
    x:=NumGet(pt,0,"uint"), y:=NumGet(pt,4,"uint")
  }
  Loop 4
  {
    this.RangeTip(x-w, y-h, 2*w+1, 2*h+1, (A_Index & 1 ? "Red":"Blue"), d)
    Sleep 500
  }
  this.RangeTip()
}

; Shows a range of the borders, similar to the ToolTip

RangeTip(x:="", y:="", w:="", h:="", color:="Red", d:=3, num:=1)
{
  local
  ListLines % (lls:=A_ListLines)?0:0
  static init, tab
  if !VarSetCapacity(init) && (init:="1")
    tab:=[]
  (!tab.HasKey(num) && tab[num]:=[0,0,0,0]), Range:=tab[num]
  if (x="")
  {
    if (Range[1])
    Loop 4
    {
      Gui, % Range[A_Index] ":Destroy"
      Range[A_Index]:=0
    }
    ListLines % lls
    return
  }
  if !(Range[1])
  {
    Loop 4
    {
      Gui, New, +Hwndid +AlwaysOnTop -Caption +ToolWindow -DPIScale +E0x08000000
      Range[A_Index]:=id
    }
  }
  x:=Floor(x), y:=Floor(y), w:=Floor(w), h:=Floor(h), d:=Floor(d)
  Loop 4
  {
    i:=A_Index
    , x1:=(i=2 ? x+w : x-d)
    , y1:=(i=3 ? y+h : y-d)
    , w1:=(i=1 || i=3 ? w+2*d : d)
    , h1:=(i=2 || i=4 ? h+2*d : d)
    Gui, % Range[i] ":Color", %color%
    Gui, % Range[i] ":Show", NA x%x1% y%y1% w%w1% h%h1%
  }
  ListLines % lls
}

State(key)
{
  return GetKeyState(key,"P") || GetKeyState(key)
}

; Use RButton to select the screen range

GetRange(ww:=25, hh:=8, key:="RButton")
{
  local
  static init, KeyOff, hk
  if !VarSetCapacity(init) && (init:="1")
    KeyOff:=this.GetRange.Bind(this, "Off")
  if (ww=="Off")
    return hk:=Trim(A_ThisHotkey, "*")
  ;---------------------
  GetRange_HotkeyIf:=_Gui:=this.GuiNew()
  _Gui.Opt("-Caption +ToolWindow +E0x80000")
  _Gui.Title:="GetRange_HotkeyIf"
  _Gui.Show("NA x0 y0 w0 h0")
  ;---------------------
  if GetKeyState("Ctrl")
    Send {Ctrl Up}
  Hotkey, IfWinExist, GetRange_HotkeyIf
  keys:=key "|Up|Down|Left|Right"
  For k,v in StrSplit(keys, "|")
  {
    if GetKeyState(v)
      Send {%v% Up}
    Hotkey, *%v%, %KeyOff%, On UseErrorLevel
  }
  Hotkey, IfWinExist
  ;---------------------
  Critical % (cri:=A_IsCritical)?"Off":"Off"
  CoordMode, Mouse
  tip:=this.Lang("s5")
  hk:="", oldx:=oldy:="", keydown:=0
  Loop
  {
    Sleep 50
    MouseGetPos, x2, y2
    if (hk=key) || this.State(key) || this.State("Ctrl")
    {
      keydown++
      if (keydown=1)
        MouseGetPos, x1, y1, Bind_ID
      timeout:=A_TickCount+3000
      While (A_TickCount<timeout) && (this.State(key) || this.State("Ctrl"))
        Sleep 50
      hk:=""
      if (keydown>=2)
        Break
    }
    else if (hk="Up") || this.State("Up")
      (hh>1 && hh--), hk:=""
    else if (hk="Down") || this.State("Down")
      hh++, hk:=""
    else if (hk="Left") || this.State("Left")
      (ww>1 && ww--), hk:=""
    else if (hk="Right") || this.State("Right")
      ww++, hk:=""
    x:=(keydown?x1:x2), y:=(keydown?y1:y2)
    this.RangeTip(x-ww, y-hh, 2*ww+1, 2*hh+1, (A_MSec<500?"Red":"Blue"))
    if (oldx=x2 && oldy=y2)
      Continue
    oldx:=x2, oldy:=y2
    ToolTip % "x: " x " y: " y "`n" tip
  }
  ToolTip
  this.RangeTip()
  Hotkey, IfWinExist, GetRange_HotkeyIf
  For k,v in StrSplit(keys, "|")
    Hotkey, *%v%, %KeyOff%, Off UseErrorLevel
  Hotkey, IfWinExist
  GetRange_HotkeyIf.Destroy()
  Critical % cri
  return [x-ww, y-hh, x+ww, y+hh, Bind_ID]
}

GetRange2(key:="LButton")
{
  local
  FindText_GetRange:=_Gui:=this.GuiNew()
  _Gui.Opt("+LastFound +AlwaysOnTop -Caption +ToolWindow -DPIScale +E0x08000000")
  _Gui.BackColor:="White"
  WinSet, Transparent, 10
  this.GetBitsFromScreen(,,,,0,x,y,w,h)
  _Gui.Title:="FindText_GetRange"
  _Gui.Show("NA x" x " y" y " w" w " h" h)
  CoordMode, Mouse
  tip:=this.Lang("s7"), oldx:=oldy:=""
  Loop
  {
    Sleep 50
    MouseGetPos, x1, y1
    if (oldx=x1 && oldy=y1)
      Continue
    oldx:=x1, oldy:=y1
    ToolTip % "x: " x1 " y: " y1 " w: 0 h: 0`n" tip
  }
  Until this.State(key) || this.State("Ctrl")
  Loop
  {
    Sleep 50
    MouseGetPos, x2, y2
    x:=Min(x1,x2), y:=Min(y1,y2), w:=Abs(x2-x1)+1, h:=Abs(y2-y1)+1
    this.RangeTip(x, y, w, h, (A_MSec<500 ? "Red":"Blue"))
    if (oldx=x2 && oldy=y2)
      Continue
    oldx:=x2, oldy:=y2
    ToolTip % "x: " x " y: " y " w: " w " h: " h "`n" tip
  }
  Until !(this.State(key) || this.State("Ctrl"))
  ToolTip
  this.RangeTip()
  FindText_GetRange.Destroy()
  Clipboard:=x "," y "," (x+w-1) "," (y+h-1)
  return [x, y, x+w-1, y+h-1]
}

BitmapFromScreen(ByRef x:=0, ByRef y:=0, ByRef w:=0, ByRef h:=0
  , ScreenShot:=1, ByRef zx:=0, ByRef zy:=0, ByRef zw:=0, ByRef zh:=0)
{
  local
  bits:=this.GetBitsFromScreen(x,y,w,h,ScreenShot,zx,zy,zw,zh)
  if (w<1 || h<1 || !bits.hBM)
    return
  hBM:=this.CreateDIBSection(w, h)
  this.CopyHBM(hBM, 0, 0, bits.hBM, x-zx, y-zy, w, h, 1)
  return hBM
}

; Quickly save screen image to BMP file for debugging
; if file = 0 or "", save to Clipboard

SavePic(file:=0, x1:=0, y1:=0, x2:=0, y2:=0, ScreenShot:=1)
{
  local
  x1:=this.Floor(x1), y1:=this.Floor(y1), x2:=this.Floor(x2), y2:=this.Floor(y2)
  if (x1=0 && y1=0 && x2=0 && y2=0)
    n:=150000, x:=y:=-n, w:=h:=2*n
  else
    x:=Min(x1,x2), y:=Min(y1,y2), w:=Abs(x2-x1)+1, h:=Abs(y2-y1)+1
  hBM:=this.BitmapFromScreen(x, y, w, h, ScreenShot)
  this.SaveBitmapToFile(file, hBM)
  DllCall("DeleteObject", "Ptr",hBM)
}

; Save Bitmap To File, if file = 0 or "", save to Clipboard
; hBM_or_file can be a bitmap handle or file path, eg: "c:\1.bmp"

SaveBitmapToFile(file, hBM_or_file, x:=0, y:=0, w:=0, h:=0)
{
  local
  if hBM_or_file is number
    hBM_or_file:="HBITMAP:*" hBM_or_file
  if !hBM:=DllCall("CopyImage", "Ptr",LoadPicture(hBM_or_file)
  , "int",0, "int",0, "int",0, "uint",0x2008)
    return
  if (file) || (w!=0 && h!=0)
  {
    (w=0 || h=0) && this.GetBitmapWH(hBM, w, h)
    hBM2:=this.CreateDIBSection(w, -h, bpp:=(file ? 24 : 32))
    this.CopyHBM(hBM2, 0, 0, hBM, x, y, w, h)
    DllCall("DeleteObject", "Ptr",hBM), hBM:=hBM2
  }
  VarSetCapacity(dib, dib_size:=(A_PtrSize=8 ? 104:84), 0)
  , DllCall("GetObject", "Ptr",hBM, "int",dib_size, "Ptr",&dib)
  , pbi:=&dib+(bitmap_size:=A_PtrSize=8 ? 32:24)
  , size:=NumGet(pbi+20, "uint"), pBits:=NumGet(pbi-A_PtrSize, "Ptr")
  if (!file)
  {
    hdib:=DllCall("GlobalAlloc", "uint",2, "Ptr",40+size, "Ptr")
    pdib:=DllCall("GlobalLock", "Ptr",hdib, "Ptr")
    DllCall("RtlMoveMemory", "Ptr",pdib, "Ptr",pbi, "Ptr",40)
    DllCall("RtlMoveMemory", "Ptr",pdib+40, "Ptr",pBits, "Ptr",size)
    DllCall("GlobalUnlock", "Ptr",hdib)
    DllCall("OpenClipboard", "Ptr",0)
    DllCall("EmptyClipboard")
    DllCall("SetClipboardData", "uint",8, "Ptr",hdib)
    DllCall("CloseClipboard")
  }
  else
  {
    if InStr(file,"\") && !FileExist(dir:=RegExReplace(file,"[^\\]*$"))
      Try FileCreateDir, % dir
    VarSetCapacity(bf, 14, 0), NumPut(0x4D42, bf, "short")
    NumPut(54+size, bf, 2, "uint"), NumPut(54, bf, 10, "uint")
    f:=FileOpen(file, "w"), f.RawWrite(bf, 14)
    , f.RawWrite(pbi+0, 40), f.RawWrite(pBits+0, size), f.Close()
  }
  DllCall("DeleteObject", "Ptr",hBM)
}

; Show the saved Picture file

ShowPic(file:="", show:=1, ByRef x:="", ByRef y:="", ByRef w:="", ByRef h:="")
{
  local
  if (file="")
  {
    this.ShowScreenShot()
    return
  }
  if !(hBM:=LoadPicture(file))
    return
  this.GetBitmapWH(hBM, w, h)
  bits:=this.GetBitsFromScreen(,,,,0,x,y,zw,zh)
  this.UpdateBits(bits, x, y, Max(w,zw), Max(h,zh))
  this.CopyHBM(bits.hBM, 0, 0, hBM, 0, 0, w, h)
  DllCall("DeleteObject", "Ptr",hBM)
  if (show)
    this.ShowScreenShot(x, y, x+w-1, y+h-1, 0)
  return 1
}

; Show the memory Screenshot for debugging

ShowScreenShot(x1:=0, y1:=0, x2:=0, y2:=0, ScreenShot:=1)
{
  local
  static init, hPic, oldx, oldy, oldw, oldh, FindText_Screen
  if !VarSetCapacity(init) && (init:="1")
    FindText_Screen:=""
  x1:=this.Floor(x1), y1:=this.Floor(y1), x2:=this.Floor(x2), y2:=this.Floor(y2)
  if (x1=0 && y1=0 && x2=0 && y2=0)
  {
    if (FindText_Screen)
      FindText_Screen.Destroy(), FindText_Screen:=""
    return
  }
  x:=Min(x1,x2), y:=Min(y1,y2), w:=Abs(x2-x1)+1, h:=Abs(y2-y1)+1
  if !hBM:=this.BitmapFromScreen(x,y,w,h,ScreenShot)
    return
  ;---------------
  if (!FindText_Screen)
  {
    FindText_Screen:=_Gui:=this.GuiNew()  ; WS_EX_NOACTIVATE:=0x08000000
    _Gui.Opt("+AlwaysOnTop -Caption +ToolWindow -DPIScale +E0x08000000")
    _Gui.MarginX:=0, _Gui.MarginY:=0
    id:=_Gui.Add("Pic", "w" w " h" h), hPic:=id.Hwnd
    _Gui.Title:="Show Pic"
    _Gui.Show("NA x" x " y" y " w" w " h" h)
    oldx:=x, oldy:=y, oldw:=w, oldh:=h
  }
  else if (oldx!=x || oldy!=y || oldw!=w || oldh!=h)
  {
    if (oldw!=w || oldh!=h)
      FindText_Screen[hPic].Move(,, w, h)
    FindText_Screen.Show("NA x" x " y" y " w" w " h" h)
    oldx:=x, oldy:=y, oldw:=w, oldh:=h
  }
  this.BitmapToWindow(hPic, 0, 0, hBM, 0, 0, w, h)
  DllCall("DeleteObject", "Ptr",hBM)
}

BitmapToWindow(hwnd, x1, y1, hBM, x2, y2, w, h)
{
  local
  mDC:=DllCall("CreateCompatibleDC", "Ptr",0, "Ptr")
  oBM:=DllCall("SelectObject", "Ptr",mDC, "Ptr",hBM, "Ptr")
  hDC:=DllCall("GetDC", "Ptr",hwnd, "Ptr")
  DllCall("BitBlt", "Ptr",hDC, "int",x1, "int",y1, "int",w, "int",h
    , "Ptr",mDC, "int",x2, "int",y2, "uint",0xCC0020)
  DllCall("ReleaseDC", "Ptr",hwnd, "Ptr",hDC)
  DllCall("SelectObject", "Ptr",mDC, "Ptr",oBM)
  DllCall("DeleteDC", "Ptr",mDC)
}

; Quickly get the search data of screen image

GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold:=""
  , ScreenShot:=1, ByRef rx:="", ByRef ry:="", cut:=1)
{
  local
  if (x1=0 && y1=0 && x2=0 && y2=0)
    return this.Gui("CaptureS", ScreenShot)
  SetBatchLines % (bch:=A_BatchLines)?"-1":"-1"
  x1:=this.Floor(x1), y1:=this.Floor(y1), x2:=this.Floor(x2), y2:=this.Floor(y2)
  x:=Min(x1,x2), y:=Min(y1,y2), w:=Abs(x2-x1)+1, h:=Abs(y2-y1)+1
  bits:=this.GetBitsFromScreen(x,y,w,h,ScreenShot,zx,zy)
  if (w<1 || h<1 || !bits.Scan0)
  {
    SetBatchLines % bch
    return
  }
  ListLines % (lls:=A_ListLines)?0:0
  gs:=[]
  j:=bits.Stride-w*4, p:=bits.Scan0+(y-zy)*bits.Stride+(x-zx)*4-j-4
  Loop % h + 0*(k:=0)
  Loop % w + 0*(p+=j)
    c:=NumGet(0|p+=4,"uint")
    , gs[++k]:=(((c>>16)&0xFF)*38+((c>>8)&0xFF)*75+(c&0xFF)*15)>>7
  if InStr(Threshold,"**")
  {
    Threshold:=Trim(Threshold,"* "), (Threshold="" && Threshold:=50)
    s:="", sw:=w, w-=2, h-=2, x++, y++
    Loop % h + 0*(y1:=0)
    Loop % w + 0*(y1++)
      i:=y1*sw+A_Index+1, j:=gs[i]+Threshold
      , s.=( gs[i-1]>j || gs[i+1]>j
      || gs[i-sw]>j || gs[i+sw]>j
      || gs[i-sw-1]>j || gs[i-sw+1]>j
      || gs[i+sw-1]>j || gs[i+sw+1]>j ) ? "1":"0"
    Threshold:="**" Threshold
  }
  else
  {
    Threshold:=Trim(Threshold,"* ")
    if (Threshold="")
    {
      pp:=[]
      Loop 256
        pp[A_Index-1]:=0
      Loop % w*h
        pp[gs[A_Index]]++
      IP0:=IS0:=0
      Loop 256
        k:=A_Index-1, IP0+=k*pp[k], IS0+=pp[k]
      Threshold:=Floor(IP0/IS0)
      Loop 20
      {
        LastThreshold:=Threshold
        IP1:=IS1:=0
        Loop % LastThreshold+1
          k:=A_Index-1, IP1+=k*pp[k], IS1+=pp[k]
        IP2:=IP0-IP1, IS2:=IS0-IS1
        if (IS1!=0 && IS2!=0)
          Threshold:=Floor((IP1/IS1+IP2/IS2)/2)
        if (Threshold=LastThreshold)
          Break
      }
    }
    s:=""
    Loop % w*h
      s.=gs[A_Index]<=Threshold ? "1":"0"
    Threshold:="*" Threshold
  }
  ListLines % lls
  ;--------------------
  w:=Format("{:d}",w), CutUp:=CutDown:=0
  if (cut=1)
  {
    re1:="(^0{" w "}|^1{" w "})"
    re2:="(0{" w "}$|1{" w "}$)"
    While (s~=re1)
      s:=RegExReplace(s,re1), CutUp++
    While (s~=re2)
      s:=RegExReplace(s,re2), CutDown++
  }
  rx:=x+w//2, ry:=y+CutUp+(h-CutUp-CutDown)//2
  s:="|<>" Threshold "$" w "." this.bit2base64(s)
  ;--------------------
  SetBatchLines % bch
  return s
}

; Wait for the screen image to change within a few seconds
; Take a Screenshot before using it: FindText().ScreenShot()

WaitChange(time:=-1, x1:=0, y1:=0, x2:=0, y2:=0)
{
  local
  hash:=this.GetPicHash(x1, y1, x2, y2, 0)
  time:=this.Floor(time), timeout:=A_TickCount+Round(time*1000)
  Loop
  {
    if (hash!=this.GetPicHash(x1, y1, x2, y2, 1))
      return 1
    if (time>=0 && A_TickCount>=timeout)
      Break
    Sleep 10
  }
  return 0
}

; Wait for the screen image to stabilize

WaitNotChange(time:=1, timeout:=30, x1:=0, y1:=0, x2:=0, y2:=0)
{
  local
  oldhash:="", time:=this.Floor(time)
  , timeout:=A_TickCount+Round(this.Floor(timeout)*1000)
  Loop
  {
    hash:=this.GetPicHash(x1, y1, x2, y2, 1), t:=A_TickCount
    if (hash!=oldhash)
      oldhash:=hash, timeout2:=t+Round(time*1000)
    if (t>=timeout2)
      return 1
    if (t>=timeout)
      return 0
    Sleep 100
  }
}

GetPicHash(x1:=0, y1:=0, x2:=0, y2:=0, ScreenShot:=1)
{
  local
  static init:=DllCall("LoadLibrary", "Str","ntdll", "Ptr")
  x1:=this.Floor(x1), y1:=this.Floor(y1), x2:=this.Floor(x2), y2:=this.Floor(y2)
  if (x1=0 && y1=0 && x2=0 && y2=0)
    n:=150000, x:=y:=-n, w:=h:=2*n
  else
    x:=Min(x1,x2), y:=Min(y1,y2), w:=Abs(x2-x1)+1, h:=Abs(y2-y1)+1
  bits:=this.GetBitsFromScreen(x,y,w,h,ScreenShot,zx,zy), x-=zx, y-=zy
  if (w<1 || h<1 || !bits.Scan0)
    return 0
  hash:=0, Stride:=bits.Stride, p:=bits.Scan0+(y-1)*Stride+x*4, w*=4
  ListLines % (lls:=A_ListLines)?0:0
  Loop % h
    hash:=(hash*31+DllCall("ntdll\RtlComputeCrc32", "uint",0
      , "Ptr",p+=Stride, "uint",w, "uint"))&0xFFFFFFFF
  ListLines % lls
  return hash
}

WindowToScreen(ByRef x, ByRef y, x1, y1, id:="")
{
  local
  if (!id)
    WinGet, id, ID, A
  VarSetCapacity(rect, 16, 0)
  , DllCall("GetWindowRect", "Ptr",id, "Ptr",&rect)
  , x:=x1+NumGet(rect,"int"), y:=y1+NumGet(rect,4,"int")
}

ScreenToWindow(ByRef x, ByRef y, x1, y1, id:="")
{
  local
  this.WindowToScreen(dx, dy, 0, 0, id), x:=x1-dx, y:=y1-dy
}

ClientToScreen(ByRef x, ByRef y, x1, y1, id:="")
{
  local
  if (!id)
    WinGet, id, ID, A
  VarSetCapacity(pt, 8, 0), NumPut(0, pt, "int64")
  , DllCall("ClientToScreen", "Ptr",id, "Ptr",&pt)
  , x:=x1+NumGet(pt,"int"), y:=y1+NumGet(pt,4,"int")
}

ScreenToClient(ByRef x, ByRef y, x1, y1, id:="")
{
  local
  this.ClientToScreen(dx, dy, 0, 0, id), x:=x1-dx, y:=y1-dy
}

; It is not like FindText always use Screen Coordinates,
; But like built-in command PixelGetColor using CoordMode Settings

PixelGetColor(x, y, ScreenShot:=1, id:="")
{
  if (A_CoordModePixel="Window")
    this.WindowToScreen(x, y, x, y, id)
  else if (A_CoordModePixel="Client")
    this.ClientToScreen(x, y, x, y, id)
  if (ScreenShot)
    this.ScreenShot(x, y, x, y)
  return this.GetColor(x, y)
}

; It is not like FindText always use Screen Coordinates,
; But like built-in command ImageSearch using CoordMode Settings
; ImageFile can use "*n *TransBlack/White/RRGGBB-DRDGDB... d:\a.bmp"

ImageSearch(ByRef rx:="", ByRef ry:="", x1:=0, y1:=0, x2:=0, y2:=0
  , ImageFile:="", ScreenShot:=1, FindAll:=0, dir:=1)
{
  local
  dx:=dy:=0
  if (A_CoordModePixel="Window")
    this.WindowToScreen(dx, dy, 0, 0)
  else if (A_CoordModePixel="Client")
    this.ClientToScreen(dx, dy, 0, 0)
  text:=""
  Loop Parse, ImageFile, |
  if (v:=Trim(A_LoopField))!=""
  {
    text.=InStr(v,"$") ? "|" v : "|##"
    . (RegExMatch(v, "O)(^|\s)\*(\d+)\s", r)
    ? Format("{:06X}", r[2]<<16|r[2]<<8|r[2]) : "000000")
    . (RegExMatch(v, "Oi)(^|\s)\*Trans(\S+)\s", r) ? "/" Trim(r[2],"/"):"")
    . "$" Trim(RegExReplace(v,"(^|\s)\*\S+"))
  }
  x1:=this.Floor(x1), y1:=this.Floor(y1), x2:=this.Floor(x2), y2:=this.Floor(y2)
  if (x1=0 && y1=0 && x2=0 && y2=0)
    n:=150000, x1:=y1:=-n, x2:=y2:=n
  if (ok:=this.FindText(,, x1+dx, y1+dy, x2+dx, y2+dy
    , 0, 0, text, ScreenShot, FindAll,,,, dir))
  {
    For k,v in ok  ; you can use ok:=FindText().ok
      v.1-=dx, v.2-=dy, v.x-=dx, v.y-=dy
    rx:=ok[1].1, ry:=ok[1].2, ErrorLevel:=0
    return ok
  }
  else
  {
    rx:=ry:="", ErrorLevel:=1
    return 0
  }
}

; It is not like FindText always use Screen Coordinates,
; But like built-in command PixelSearch using CoordMode Settings
; ColorID can use "RRGGBB-DRDGDB|RRGGBB-DRDGDB", Variation in 0-255

PixelSearch(ByRef rx:="", ByRef ry:="", x1:=0, y1:=0, x2:=0, y2:=0
  , ColorID:="", Variation:=0, ScreenShot:=1, FindAll:=0, dir:=1)
{
  local
  n:=this.Floor(Variation), text:=Format("##{:06X}$0/0/", n<<16|n<<8|n)
  . Trim(StrReplace(ColorID, "|", "/"), "- /")
  return this.ImageSearch(rx, ry, x1, y1, x2, y2, text, ScreenShot, FindAll, dir)
}

; Pixel count of certain colors within the range indicated by Screen Coordinates
; ColorID can use "RRGGBB-DRDGDB|RRGGBB-DRDGDB", Variation in 0-255

PixelCount(x1:=0, y1:=0, x2:=0, y2:=0, ColorID:="", Variation:=0, ScreenShot:=1)
{
  local
  x1:=this.Floor(x1), y1:=this.Floor(y1), x2:=this.Floor(x2), y2:=this.Floor(y2)
  if (x1=0 && y1=0 && x2=0 && y2=0)
    n:=150000, x:=y:=-n, w:=h:=2*n
  else
    x:=Min(x1,x2), y:=Min(y1,y2), w:=Abs(x2-x1)+1, h:=Abs(y2-y1)+1
  bits:=this.GetBitsFromScreen(x,y,w,h,ScreenShot,zx,zy), x-=zx, y-=zy
  sum:=0, VarSetCapacity(s1,4), VarSetCapacity(s0,4), VarSetCapacity(ss,w*(h+3))
  ini:={ bits:bits, ss:&ss, s1:&s1, s0:&s0, allpos:0, allpos_max:0
    , err1:0, err0:0, zoomW:1, zoomH:1 }
  n:=this.Floor(Variation), text:=Format("##{:06X}$0/0/", n<<16|n<<8|n)
  . Trim(StrReplace(ColorID, "|", "/"), "- /")
  if IsObject(j:=this.PicInfo(text))
    sum:=this.PicFind(ini, j, 1, x, y, w, h)
  return sum
}

; Create color blocks containing a specified number of specified colors
; ColorID can use "RRGGBB-DRDGDB|RRGGBB-DRDGDB", "*128", "**50"
; Count1, Count0 is the minimum number of black and white dots after binarization of this color block

ColorBlock(ColorID, w, h, Count1:=0, Count0:=0)
{
  local
  (Count0>0 && Count1:=0)
  Text:="|<>[" (1-Count1/(w*h)) "," (1-Count0/(w*h)) "]"
  . Trim(StrReplace(ColorID,"|","/"),"- /") . Format("${:d}.",w)
  . this.bit2base64(StrReplace(Format(Format("{{}:0{:d}d{}}",w*h),0),"0"
  , (Count0>0 ? "0":"1")))
  return Text
}

Click(x:="", y:="", other1:="", other2:="", GoBack:=0)
{
  local
  CoordMode, Mouse, % (bak:=A_CoordModeMouse)?"Screen":"Screen"
  if GoBack
    MouseGetPos, oldx, oldy
  MouseMove, x, y, 0
  Sleep 30
  Click % x "," y "," other1 "," other2
  if GoBack
    MouseMove, oldx, oldy, 0
  CoordMode, Mouse, %bak%
  return 1
}

; Running AHK code dynamically with new threads

Class Thread
{
  __New(args*)
  {
    this.pid:=this.Exec(args*)
  }
  __Delete()
  {
    Process, Close, % this.pid
  }
  Exec(s, Ahk:="", args:="")    ; required AHK v1.1.34+ and Ahk2Exe Use .exe
  {
    local
    Ahk:=Ahk ? Ahk : A_IsCompiled ? A_ScriptFullPath : A_AhkPath
    s:="`nDllCall(""SetWindowText"",""Ptr"",A_ScriptHwnd,""Str"",""<AHK>"")`n"
      . "`nSetBatchLines,-1`n" . s, s:=RegExReplace(s, "\R", "`r`n")
    Try
    {
      shell:=ComObjCreate("WScript.Shell")
      oExec:=shell.Exec("""" Ahk """ /script /force /CP0 * " args)
      oExec.StdIn.Write(s)
      oExec.StdIn.Close(), pid:=oExec.ProcessID
    }
    Catch
    {
      f:=A_Temp "\~ahk.tmp"
      s:="`r`nTry FileDelete " f "`r`n" s
      Try FileDelete % f
      FileAppend % s, % f
      r:=this.Clear.Bind(this)
      SetTimer % r, -3000
      Run "%Ahk%" /script /force /CP0 "%f%" %args%,, UseErrorLevel, pid
    }
    return pid
  }
  Clear()
  {
    Try FileDelete % A_Temp "\~ahk.tmp"
    SetTimer,, Off
  }
}

; FindText().QPC() Use the same as A_TickCount

QPC()
{
  static init, f, c
  if !VarSetCapacity(init) && (init:="1")
    f:=0, c:=DllCall("QueryPerformanceFrequency", "Int64*",f)+(f/=1000)
  return (!DllCall("QueryPerformanceCounter","Int64*",c))*0+(c/f)
}

; FindText().ToolTip() Use the same as ToolTip

ToolTip(s:="", x:="", y:="", num:=1, arg:="")
{
  local
  static init, ini, tip, timer
  if !VarSetCapacity(init) && (init:="1")
    ini:=[], tip:=[], timer:=[]
  f:="ToolTip_" . this.Floor(num)
  if (s="")
  {
    Try tip[f].Destroy()
    ini[f]:="", tip[f]:=""
    return
  }
  ;-----------------
  r1:=A_CoordModeToolTip
  r2:=A_CoordModeMouse
  CoordMode Mouse, Screen
  MouseGetPos x1, y1
  CoordMode Mouse, %r1%
  MouseGetPos x2, y2
  CoordMode Mouse, %r2%
  (x!="" && x:="x" (this.Floor(x)+x1-x2))
  , (y!="" && y:="y" (this.Floor(y)+y1-y2))
  , (x="" && y="" && x:="x" (x1+16) " y" (y1+16))
  ;-----------------
  bgcolor:=arg.bgcolor!="" ? arg.bgcolor : "FAFBFC"
  color:=arg.color!="" ? arg.color : "Black"
  font:=arg.font ? arg.font : "Consolas"
  size:=arg.size ? arg.size : "10"
  bold:=arg.bold ? arg.bold : ""
  trans:=arg.trans!="" ? arg.trans & 255 : 255
  timeout:=arg.timeout!="" ? arg.timeout : ""
  ;-----------------
  r:=bgcolor "|" color "|" font "|" size "|" bold "|" trans "|" s
  if (!ini.HasKey(f) || ini[f]!=r)
  {
    ini[f]:=r
    Try tip[f].Destroy()
    tip[f]:=_Gui:=this.GuiNew()  ; WS_EX_LAYERED:=0x80000, WS_EX_TRANSPARENT:=0x20
    _Gui.Opt("+LastFound +AlwaysOnTop -Caption +ToolWindow -DPIScale +E0x80020")
    _Gui.MarginX:=2, _Gui.MarginY:=2
    _Gui.BackColor:=bgcolor
    _Gui.SetFont("c" color " s" size " " bold, font)
    _Gui.Add("Text",, s)
    _Gui.Title:=f
    _Gui.Show("Hide")
    WinSet, Transparent, % trans
  }
  tip[f].Opt("+AlwaysOnTop")
  tip[f].Show("NA " x " " y)
  if (timeout)
  {
    (!timer.HasKey(f) && timer[f]:=this.ToolTip.Bind(this,"","","",num))
    , r:=timer[f]
    SetTimer % r, % -Round(Abs(this.Floor(timeout)*1000))-1
  }
}

; FindText().ObjView()  view object values for Debug

ObjView(obj, keyname:="")
{
  local
  if IsObject(obj)  ; thanks lexikos's type(v)
  {
    s:=""
    For k,v in obj
      s.=this.ObjView(v, keyname "[" (StrLen(k)>1000
      || [k].GetCapacity(1) ? """" k """":k) "]")
  }
  else
    s:=keyname ": " (StrLen(obj)>1000
    || [obj].GetCapacity(1) ? """" obj """":obj) "`n"
  if (keyname!="")
    return s
  ;------------------
  _Gui:=this.GuiNew("+AlwaysOnTop")
  _Gui.Add("Button", "y270 w350 gCancel Default", "OK")
  _Gui.Add("Edit", "xp y10 w350 h250 -Wrap -WantReturn")
  _Gui["Edit1"].Value:=s
  _Gui.Title:="Debug view object values"
  _Gui.Show()
  DetectHiddenWindows 0
  WinWaitClose % "ahk_id " _Gui.Hwnd
  _Gui.Destroy()
}

EditScroll(hEdit, regex:="", line:=0, pos:=0)
{
  local
  ControlGetText, s,, ahk_id %hEdit%
  pos:=(regex!="") ? InStr(SubStr(s,1,s~=regex) " ","`n",0,-1)
    : (line>1) ? InStr(s,"`n",0,1,line-1) : pos
  SendMessage, 0xB1, pos, pos,, ahk_id %hEdit%
  SendMessage, 0xB7,,,, ahk_id %hEdit%
}

LastCtrl()
{
  local
  return (G:=this.GuiFromHwnd(WinExist()))[G.LastHwnd]
}

Hide(args*)
{
  WinMinimize
  WinHide
  ToolTip
  DetectHiddenWindows 0
  WinWaitClose % "ahk_id " WinExist()
}

SC(RGB, hwnd)
{
  SendMessage,0x2001,0,(RGB&0xFF)<<16|RGB&0xFF00|(RGB>>16)&0xFF,,% "ahk_id " hwnd
}

;==== Optional GUI interface ====

Gui(cmd, arg1:="", args*)
{
  local
  static
  local bch, cri, lls, _Gui
  ListLines % InStr("MouseMove|ToolTipOff",cmd)?0:A_ListLines
  static init
  if !VarSetCapacity(init) && (init:="1")
  {
    SavePicDir:=A_Temp "\Ahk_ScreenShot\"
    G_ := this.Gui.Bind(this)
    G_G := this.Gui.Bind(this, "G")
    G_Run := this.Gui.Bind(this, "Run")
    G_Show := this.Gui.Bind(this, "Show")
    G_KeyDown := this.Gui.Bind(this, "KeyDown")
    G_LButtonDown := this.Gui.Bind(this, "LButtonDown")
    G_RButtonDown := this.Gui.Bind(this, "RButtonDown")
    G_MouseMove := this.Gui.Bind(this, "MouseMove")
    G_ScreenShot := this.Gui.Bind(this, "ScreenShot")
    G_ShowPic := this.Gui.Bind(this, "ShowPic")
    G_Slider := this.Gui.Bind(this, "Slider")
    G_ToolTip := this.Gui.Bind(this, "ToolTip")
    G_ToolTipOff := this.Gui.Bind(this, "ToolTipOff")
    G_SaveScr := this.Gui.Bind(this, "SaveScr")
    G_PicShowOK := this.Gui.Bind(this, "PicShowOK")
    G_Drag := this.Gui.Bind(this, "Drag")
    FindText_Capture:=FindText_Main:=""
    PrevControl:=x:=y:=oldx:=oldy:=""
    Pics:=[], hBM_old:=dx:=dy:=0
    bch:=A_BatchLines, cri:=A_IsCritical
    Critical
    #NoEnv
    Lang:=this.Lang(,1), Tip_Text:=this.Lang(,2)
    G_.Call("MakeCaptureWindow")
    G_.Call("MakeMainWindow")
    OnMessage(0x100, G_KeyDown)
    OnMessage(0x201, G_LButtonDown)
    OnMessage(0x204, G_RButtonDown)
    OnMessage(0x200, G_MouseMove)
    Menu, Tray, Add
    Menu, Tray, Add, % Lang["s1"], % G_Show
    if (!A_IsCompiled && A_LineFile=A_ScriptFullPath)
    {
      Menu, Tray, Default, % Lang["s1"]
      Menu, Tray, Click, 1
      Menu, Tray, Icon, Shell32.dll, 23
    }
    Critical % cri
    SetBatchLines % bch
    this.GuiNew("+LastFound").Destroy()
  }
  Switch cmd
  {
  Case "G":
    id:=this.LastCtrl()
    Try id.OnEvent("Click", G_Run)
    Catch
      Try id.OnEvent("Change", G_Run)
    return
  Case "Run":
    Critical
    G_.Call(arg1.Name)
    return
  Case "Show":
    FindText_Main.Show(arg1 ? "Center" : "")
    ControlFocus,, % "ahk_id " hscr
    return
  Case "Cancel", "Cancel2":
    WinHide
    return
  Case "MakeCaptureWindow":
    WindowColor:="0xDDEEFF"
    Try FindText_Capture.Destroy()
    FindText_Capture:=_Gui:=this.GuiNew()
    _Gui.Opt("+LastFound +AlwaysOnTop -DPIScale")
    _Gui.MarginX:=15, _Gui.MarginY:=10
    _Gui.BackColor:=WindowColor
    _Gui.SetFont("s12", "Verdana")
    Tab:=_Gui.Add("Tab3", "vMyTab1 -Wrap", StrSplit(Lang["s18"],"|"))
    Tab.UseTab(1)
    C_:=[], Cid_:=[]
    , nW:=71, nH:=25, w:=h:=12, pW:=nW*(w+1)-1, pH:=(nH+1)*(h+1)-1
    id:=_Gui.Add("Text", "w" pW " h" pH), Cid_[id.Hwnd]:=-1
    _Gui.Opt("-Theme")
    ListLines % (lls:=A_ListLines)?0:0
    Loop % nW*(nH+1)
    {
      i:=A_Index, j:=i=1 ? "xp yp Section" : Mod(i,nW)=1 ? "xs y+1":"x+1"
      id:=_Gui.Add("Progress", j " w" w " h" h " -E0x20000 Smooth")
      C_[i]:=id.Hwnd, Cid_[id.Hwnd]:=i
    }
    ListLines % lls
    _Gui.Opt("+Theme")
    _Gui.Add("Slider", "xs w" pW " vMySlider1 +Center Page20 Line10 NoTicks AltSubmit")
    G_G.Call()
    _Gui.Add("Slider", "ys h" pH " vMySlider2 +Center Page20 Line10 NoTicks AltSubmit +Vertical")
    G_G.Call()
    Tab.UseTab(2)
    id:=_Gui.Add("Pic", "w" (pW-135) " h" pH " +Border -Background Section"), hPic:=id.Hwnd
    Pic_hBM:=this.CreateDIBSection(Pic_w:=(pW-135), Pic_h:=pH)
    _Gui.Add("Slider", "xs wp vMySlider3 +Center Page20 Line10 NoTicks AltSubmit")
    G_G.Call()
    _Gui.Add("Slider", "ys h" pH " vMySlider4 +Center Page20 Line10 NoTicks AltSubmit +Vertical")
    G_G.Call()
    _Gui.Add("ListBox", "ys w120 h200 vSelectBox AltSubmit 0x100")
    G_G.Call()
    _Gui.Add("Button", "y+0 wp vClearAll", Lang["ClearAll"])
    G_G.Call()
    _Gui.Add("Button", "y+0 wp vOpenDir", Lang["OpenDir"])
    G_G.Call()
    _Gui.Add("Button", "y+0 wp vLoadPic", Lang["LoadPic"])
    G_G.Call()
    _Gui.Add("Button", "y+0 wp vSavePic", Lang["SavePic"])
    G_G.Call()
    Tab.UseTab()
    ;--------------
    _Gui.Add("Text", "xm Section", Lang["SelGray"])
    _Gui.Add("Edit", "x+5 yp-3 w80 vSelGray ReadOnly")
    _Gui.Add("Text", "x+15 ys", Lang["SelColor"])
    _Gui.Add("Edit", "x+5 yp-3 w150 vSelColor ReadOnly")
    _Gui.Add("Text", "x+15 ys", Lang["SelR"])
    _Gui.Add("Edit", "x+5 yp-3 w80 vSelR ReadOnly")
    _Gui.Add("Text", "x+5 ys", Lang["SelG"])
    _Gui.Add("Edit", "x+5 yp-3 w80 vSelG ReadOnly")
    _Gui.Add("Text", "x+5 ys", Lang["SelB"])
    _Gui.Add("Edit", "x+5 yp-3 w80 vSelB ReadOnly")
    ;--------------
    id:=_Gui.Add("Button", "xm Hidden Section", Lang["Auto"])
    id.GetPos(pX, pY, pW, pH)
    w:=Round(pW*0.75), i:=Round(w*3+15+pW*0.5-w*1.5)
    _Gui.Add("Button", "xm+" i " yp w" w " hp -Wrap vRepU", Lang["RepU"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp hp -Wrap vCutU", Lang["CutU"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp hp -Wrap vCutU3", Lang["CutU3"])
    G_G.Call()
    _Gui.Add("Button", "xm wp hp -Wrap vRepL", Lang["RepL"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp hp -Wrap vCutL", Lang["CutL"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp hp -Wrap vCutL3", Lang["CutL3"])
    G_G.Call()
    _Gui.Add("Button", "x+15 w" pW " hp -Wrap vAuto", Lang["Auto"])
    G_G.Call()
    _Gui.Add("Button", "x+15 w" w " hp -Wrap vRepR", Lang["RepR"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp hp -Wrap vCutR", Lang["CutR"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp hp -Wrap vCutR3", Lang["CutR3"])
    G_G.Call()
    _Gui.Add("Button", "xm+" i " wp hp -Wrap vRepD", Lang["RepD"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp hp -Wrap vCutD", Lang["CutD"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp hp -Wrap vCutD3", Lang["CutD3"])
    G_G.Call()
    ;--------------
    Tab:=_Gui.Add("Tab3", "ys -Wrap", StrSplit(Lang["s2"],"|"))
    Tab.UseTab(1)
    _Gui.Add("Text", "x+30 y+35", Lang["Threshold"])
    _Gui.Add("Edit", "x+15 w100 vThreshold")
    _Gui.Add("Button", "x+15 yp-3 vGray2Two", Lang["Gray2Two"])
    G_G.Call()
    Tab.UseTab(2)
    _Gui.Add("Text", "x+30 y+35", Lang["GrayDiff"])
    _Gui.Add("Edit", "x+15 w100 vGrayDiff", "50")
    _Gui.Add("Button", "x+15 yp-3 vGrayDiff2Two", Lang["GrayDiff2Two"])
    G_G.Call()
    Tab.UseTab(3)
    _Gui.Add("Text", "x+10 y+15 Section", Lang["Similar1"] " 0")
    _Gui.Add("Slider", "x+0 w100 vSimilar1 +Center Page1 NoTicks ToolTip")
    G_G.Call()
    _Gui.Add("Text", "x+0", "100")
    _Gui.Add("Button", "x+10 ys-2 vAddColorSim", Lang["AddColorSim"])
    G_G.Call()
    _Gui.Add("Text", "x+25 ys+4", Lang["DiffRGB2"])
    _Gui.Add("Edit", "x+5 ys w80 vDiffRGB2 Limit3")
    _Gui.Add("UpDown", "vdRGB2 Range0-255 Wrap", 50)
    _Gui.Add("Button", "x+10 ys-2 vAddColorDiff", Lang["AddColorDiff"])
    G_G.Call()
    _Gui.Add("Button", "xs vUndo2", Lang["Undo2"])
    G_G.Call()
    _Gui.Add("Edit", "x+10 yp+2 w340 vColorList")
    _Gui.Add("Button", "x+10 yp-2 vColor2Two", Lang["Color2Two"])
    G_G.Call()
    Tab.UseTab(4)
    _Gui.Add("Text", "x+30 y+35", Lang["Similar2"] " 0")
    _Gui.Add("Slider", "x+0 w120 vSimilar2 +Center Page1 NoTicks ToolTip")
    G_G.Call()
    _Gui.Add("Text", "x+0", "100")
    _Gui.Add("Button", "x+15 yp-3 vColorPos2Two", Lang["ColorPos2Two"])
    G_G.Call()
    Tab.UseTab(5)
    _Gui.Add("Text", "x+30 y+15 Section", Lang["Similar3"] " 0")
    _Gui.Add("Slider", "x+0 w120 vSimilar3 +Center Page1 NoTicks ToolTip")
    G_G.Call()
    _Gui.Add("Text", "x+0", "100")
    _Gui.Add("Button", "x+15 ys-2 vUndo", Lang["Undo"])
    G_G.Call()
    _Gui.Add("Checkbox", "xs vMultiColor", Lang["MultiColor"])
    G_G.Call()
    _Gui.Add("Checkbox", "x+50 vFindShape", Lang["FindShape"])
    G_G.Call()
    Tab.UseTab()
    ;--------------
    _Gui.Add("Button", "xm vReset", Lang["Reset"])
    G_G.Call()
    _Gui.Add("Checkbox", "x+15 yp+5 vModify", Lang["Modify"])
    G_G.Call()
    _Gui.Add("Text", "x+30", Lang["Comment"])
    _Gui.Add("Edit", "x+5 yp-2 w250 vComment")
    _Gui.Add("Button", "x+10 yp-3 vSplitAdd", Lang["SplitAdd"])
    G_G.Call()
    _Gui.Add("Button", "x+10 vAllAdd", Lang["AllAdd"])
    G_G.Call()
    _Gui.Add("Button", "x+30 wp vOK", Lang["OK"])
    G_G.Call()
    _Gui.Add("Button", "x+15 wp vCancel", Lang["Cancel"])
    G_G.Call()
    _Gui.Add("Button", "xm vBind0", Lang["Bind0"])
    G_G.Call()
    _Gui.Add("Button", "x+10 vBind1", Lang["Bind1"])
    G_G.Call()
    _Gui.Add("Button", "x+10 vBind2", Lang["Bind2"])
    G_G.Call()
    _Gui.Add("Button", "x+10 vBind3", Lang["Bind3"])
    G_G.Call()
    _Gui.Add("Button", "x+10 vBind4", Lang["Bind4"])
    G_G.Call()
    _Gui.Add("Button", "x+30 vSavePic2", Lang["SavePic2"])
    G_G.Call()
    _Gui.Title:=Lang["s3"]
    _Gui.Show("Hide")
    _Gui.OnEvent("DropFiles", G_Drag)
    return
  Case "Drag":
    Try G_.Call("LoadPic", args[2][1])
    return
  Case "MakeMainWindow":
    Try FindText_Main.Destroy()
    FindText_Main:=_Gui:=this.GuiNew()
    _Gui.Opt("+LastFound +AlwaysOnTop -DPIScale")
    _Gui.MarginX:=15, _Gui.MarginY:=10
    _Gui.BackColor:=WindowColor
    _Gui.SetFont("s12", "Verdana")
    _Gui.Add("Text", "xm", Lang["NowHotkey"])
    _Gui.Add("Edit", "x+5 w160 vNowHotkey ReadOnly")
    _Gui.Add("Hotkey", "x+5 w160 vSetHotkey1")
    s:="F1|F2|F3|F4|F5|F6|F7|F8|F9|F10|F11|F12|LWin|Ctrl|Shift|Space|MButton"
      . "|ScrollLock|CapsLock|Ins|Esc|BS|Del|Tab|Home|End|PgUp|PgDn"
      . "|NumpadDot|NumpadSub|NumpadAdd|NumpadDiv|NumpadMult"
    _Gui.Add("DDL", "x+5 w160 vSetHotkey2", StrSplit(s,"|"))
    _Gui.Add("Button", "x+15 vApply", Lang["Apply"])
    G_G.Call()
    _Gui.Add("GroupBox", "xm y+0 w280 h55 vMyGroup cBlack")
    _Gui.Add("Text", "xp+15 yp+20 Section", Lang["Myww"] ": ")
    _Gui.Add("Text", "x+0 w80", nW//2)
    _Gui.Add("UpDown", "vMyww Range1-100", nW//2)
    _Gui.Add("Text", "x+15 ys", Lang["Myhh"] ": ")
    _Gui.Add("Text", "x+0 w80", nH//2)
    id:=_Gui.Add("UpDown", "vMyhh Range1-100", nH//2)
    id.GetPos(pX, pY, pW, pH)
    _Gui["MyGroup"].Move(,, pX+pW, pH+30)
    id:=_Gui.Add("Checkbox", "x+100 ys vAddFunc", Lang["AddFunc"] " FindText()")
    id.GetPos(pX, pY, pW, pH)
    pW:=pX+pW-15, pW:=(pW<720?720:pW), w:=pW//5
    _Gui.Add("Button", "xm y+18 w" w " vCutL2", Lang["CutL2"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp vCutR2", Lang["CutR2"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp vCutU2", Lang["CutU2"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp vCutD2", Lang["CutD2"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp vUpdate", Lang["Update"])
    G_G.Call()
    _Gui.SetFont("s6 bold", "Verdana")
    _Gui.Add("Edit", "xm y+10 w" pW " h260 vMyPic -Wrap HScroll")
    _Gui.SetFont("s12 norm", "Verdana")
    w:=pW//3
    _Gui.Add("Button", "xm w" w " vCapture", Lang["Capture"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp vTest", Lang["Test"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp vCopy", Lang["Copy"])
    G_G.Call()
    _Gui.Add("Button", "xm y+0 wp vCaptureS", Lang["CaptureS"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp vGetRange", Lang["GetRange"])
    G_G.Call()
    _Gui.Add("Button", "x+0 wp vGetOffset", Lang["GetOffset"])
    G_G.Call()
    _Gui.Add("Edit", "xm y+10 w130 hp vClipText")
    _Gui.Add("Button", "x+0 vPaste", Lang["Paste"])
    G_G.Call()
    _Gui.Add("Button", "x+0 vTestClip", Lang["TestClip"])
    G_G.Call()
    id:=_Gui.Add("Button", "x+0 vGetClipOffset", Lang["GetClipOffset"])
    G_G.Call()
    id.GetPos(x,, w)
    w:=((pW+15)-(x+w))//2
    _Gui.Add("Edit", "x+0 w" w " hp vOffset")
    _Gui.Add("Button", "x+0 wp vCopyOffset", Lang["CopyOffset"])
    G_G.Call()
    _Gui.SetFont("cBlue")
    id:=_Gui.Add("Edit", "xm w" pW " h250 vscr -Wrap HScroll"), hscr:=id.Hwnd
    _Gui.Title:=Lang["s4"]
    _Gui.Show("Hide")
    G_.Call("LoadScr")
    OnExit(G_SaveScr)
    return
  Case "LoadScr":
    f:=A_Temp "\~scr1.tmp"
    FileRead, s, % f
    FindText_Main["scr"].Value:=s
    return
  Case "SaveScr":
    f:=A_Temp "\~scr1.tmp"
    s:=FindText_Main["scr"].Value
    Try FileDelete % f
    FileAppend % s, % f
    return
  Case "Capture", "CaptureS":
    _Gui:=FindText_Main
    if show_gui:=WinExist("ahk_id " _Gui.Hwnd)
      this.Hide()
    if (cmd="Capture")
    {
      w:=_Gui["Myww"].Value
      h:=_Gui["Myhh"].Value
      p:=this.GetRange(w, h)
      sx:=p[1], sy:=p[2], sw:=p[3]-p[1]+1, sh:=p[4]-p[2]+1
      , Bind_ID:=p[5], bind_mode:=""
      _Gui:=FindText_Capture
      _Gui["MyTab1"].Choose(1)
    }
    else
    {
      sx:=0, sy:=0, sw:=1, sh:=1, Bind_ID:=WinExist("A"), bind_mode:=""
      _Gui:=FindText_Capture
      _Gui["MyTab1"].Choose(2)
    }
    n:=150000, x:=y:=-n, w:=h:=2*n
    hBM:=this.BitmapFromScreen(x,y,w,h,(arg1=0?0:1))
    Pics:=[], Pics[hBM]:=1, hBM_x:=hBM_y:=0
    G_.Call("CaptureUpdate")
    G_.Call("PicUpdate")
    Names:=["HBITMAP:*" hBM], s:="<New>"
    Loop Files, % SavePicDir "*.bmp"
      Names.Push(v:=A_LoopFileFullPath), s.="|" RegExReplace(v,"i)^.*\\|\.bmp$")
    _Gui["SelectBox"].Delete()
    _Gui["SelectBox"].Add(StrSplit(Trim(s,"|"),"|"))
    ;------------------------
    s:="SelGray|SelColor|SelR|SelG|SelB|Threshold|Comment|ColorList"
    Loop Parse, s, |
      _Gui[A_LoopField].Value:=""
    For k,v in ["Similar1","Similar2","Similar3"]
      _Gui[v].Value:=90
    _Gui["Modify"].Value:=Modify:=0
    _Gui["MultiColor"].Value:=MultiColor:=0
    _Gui["FindShape"].Value:=FindShape:=0
    _Gui["GrayDiff"].Value:=50
    _Gui["Gray2Two"].Focus()
    _Gui["Gray2Two"].Opt("+Default")
    _Gui.Show("Center")
    Event:=Result:=""
    DetectHiddenWindows 0
    Critical, Off
    WinWaitClose % "ahk_id " _Gui.Hwnd
    Critical
    ToolTip
    Pics[hBM]:=1, hBM_old:=0
    For k,v in Pics
      Try DllCall("DeleteObject", "Ptr",k)
    Text:=RegExMatch(Result,"O)\|<[^>\n]*>[^$\n]+\$[^""\r\n]+",r)?r[0]:""
    ;------------------------
    _Gui:=FindText_Main
    if (bind_mode!="")
    {
      WinGetTitle, tt, ahk_id %Bind_ID%
      WinGetClass, tc, ahk_id %Bind_ID%
      tt:=Trim(SubStr(tt,1,30) (tc ? " ahk_class " tc:""))
      tt:=StrReplace(RegExReplace(tt,"[;``]","``$0"),"""","""""")
      Result:="`nSetTitleMatchMode 2`nid:=WinExist(""" tt """)"
        . "`nFindText().BindWindow(id" (bind_mode=0 ? "":"," bind_mode)
        . ")  `; " Lang["s6"] " FindText().BindWindow(0)`n`n" Result
    }
    if (Event="OK")
    {
      s:=""
      if (!A_IsCompiled)
        Try FileRead, s, %A_LineFile%
      re:="Oi)\n\s*FindText[^\n]+args\*[\s\S]*?Script_End[(){}\s]+}"
      s:=RegExMatch(s, re, r) ? "`n;==========`n" r[0] "`n" : ""
      _Gui["scr"].Value:=Result "`n" s
      _Gui["MyPic"].Value:=Trim(this.ASCII(Result),"`n")
    }
    else if (Event="SplitAdd" || Event="AllAdd")
    {
      s:=_Gui["scr"].Value
      r:=SubStr(s, 1, InStr(s,"=FindText("))
      i:=j:=0, re:="<[^>\n]*>[^$\n]+\$[^""\r\n]+"
      While j:=RegExMatch(r, re,, j+1)
        i:=InStr(r, "`n", 0, j)
      _Gui["scr"].Value:=SubStr(s,1,i) . Result . SubStr(s,i+1)
      _Gui["MyPic"].Value:=Trim(this.ASCII(Result),"`n")
    }
    if (Event) && RegExMatch(Result, "O)\$\d+\.[\w+/]{1,100}", r)
      this.EditScroll(hscr, "\Q" r[0] "\E")
    Event:=Result:=s:=""
    ;----------------------
    if (show_gui && arg1="")
      G_Show.Call()
    else Clipboard:=Text
    return Text
  Case "CaptureUpdate":
    nX:=sx, nY:=sy, nW:=sw, nH:=sh
    bits:=this.GetBitsFromScreen(nX,nY,nW,nH,0,zx,zy)
    cors:=[], show:=[], ascii:=[]
    , SelPos:=bg:=color:=Result:=""
    , dx:=dy:=CutLeft:=CutRight:=CutUp:=CutDown:=0
    ListLines % (lls:=A_ListLines)?0:0
    if (nW>0 && nH>0 && bits.Scan0)
    {
      j:=bits.Stride-nW*4, p:=bits.Scan0+(nY-zy)*bits.Stride+(nX-zx)*4-j-4
      Loop % nH + 0*(k:=0)
      Loop % nW + 0*(p+=j)
        show[++k]:=1, cors[k]:=NumGet(0|p+=4,"uint")
    }
    Loop % 25 + 0*(ty:=dy-1)*(k:=0)
    Loop % 71 + 0*(tx:=dx-1)*(ty++)
      this.SC(((++tx)<nW && ty<nH ? cors[ty*nW+tx+1]:WindowColor), C_[++k])
    Loop % 71 + 0*(k:=71*25)
      this.SC(0xFFFFAA, C_[++k])
    ListLines % lls
    _Gui:=FindText_Capture
    _Gui["MySlider1"].Enabled:=nW>71
    _Gui["MySlider2"].Enabled:=nH>25
    _Gui["MySlider1"].Value:=0
    _Gui["MySlider2"].Value:=0
    return
  Case "PicUpdate":
    Try i:=0, i:=Pics.HasKey(hBM_old)
    Try (!i) && DllCall("DeleteObject", "Ptr",hBM_old)
    this.GetBitmapWH(hBM, hBM_w, hBM_h), hBM_old:=hBM
    G_.Call("PicShow", 1)
    return
  Case "MySlider3", "MySlider4":
    hBM_x:=Round(FindText_Capture["MySlider3"].Value*(hBM_w-Pic_w)/100)
    hBM_y:=Round(FindText_Capture["MySlider4"].Value*(hBM_h-Pic_h)/100)
    G_.Call("PicShow")
    return
  Case "PicShow":
    w:=hBM_w-Pic_w, h:=hBM_h-Pic_h
    , hBM_x:=Max(Min(hBM_x,w),0), hBM_y:=Max(Min(hBM_y,h),0)
    if (w<0 || h<0)
      this.DrawHBM(Pic_hBM, [[0, 0, Pic_w, Pic_h, WindowColor]])
    this.CopyHBM(Pic_hBM,0,0,hBM,hBM_x,hBM_y,Min(Pic_w,hBM_w),Min(Pic_h,hBM_h))
    if (arg1)
      G_PicShowOK.Call()
    else
    {
      this.BitmapToWindow(hPic,0,0,Pic_hBM,0,0,Pic_w,Pic_h)
      SetTimer % G_PicShowOK, -1000
    }
    FindText_Capture["MySlider3"].Value:=w>0?Round(hBM_x/w*100):0
    FindText_Capture["MySlider4"].Value:=h>0?Round(hBM_y/h*100):0
    return
  Case "PicShowOK":
    FindText_Capture[hPic].Value:="*w0 *h0 HBITMAP:*" Pic_hBM
    return
  Case "Reset":
    G_.Call("CaptureUpdate")
    return
  Case "LoadPic":
    FindText_Capture.Opt("+OwnDialogs")
    f:=arg1
    if (f="")
    {
      if !FileExist(SavePicDir)
        FileCreateDir % SavePicDir
      f:=SavePicDir "*.bmp"
      Loop Files, % f
        f:=A_LoopFileFullPath
      FileSelectFile, f,, %f%, Select Picture
    }
    if !InStr(f,"HBITMAP:") && !FileExist(f)
    {
      MsgBox, 4096, Tip, % Lang["s17"]
      return
    }
    if !this.ShowPic(f, 0, sx, sy, sw, sh)
      return
    hBM:=this.BitmapFromScreen(sx, sy, sw, sh, 0)
    sw:=Min(sw,71), sh:=Min(sh,25)
    G_.Call("CaptureUpdate")
    G_.Call("PicUpdate")
    return
  Case "SavePic":
    FindText_Capture.Hide()
    this.ScreenShot(), this.ShowPic("HBITMAP:*" hBM)
    Try this.GuiFromHwnd(WinExist("Show Pic")).Opt("+OwnDialogs")
    Loop
    {
      p:=this.GetRange2()
      MsgBox, 4099, Tip, % Lang["s15"]
      IfMsgBox, No
        Continue
      Break
    }
    IfMsgBox, Yes
      G_.Call("ScreenShot", p[1] "|" p[2] "|" p[3] "|" p[4] "|0")
    this.ShowPic()
    return
  Case "SelectBox":
    SelectBox:=FindText_Capture["SelectBox"].Value
    Try f:="", f:=Names[SelectBox]
    if (f!="")
      G_.Call("LoadPic", f)
    return
  Case "ClearAll":
    FindText_Capture.Opt("+OwnDialogs")
    MsgBox, 4100, Tip, % Lang["s19"]
    IfMsgBox, Yes
    {
      FindText_Capture.Hide()
      FileDelete % SavePicDir "*.bmp"
    }
    return
  Case "OpenDir":
    if !FileExist(SavePicDir)
      FileCreateDir % SavePicDir
    Run % SavePicDir
    return
  Case "GetRange":
    _Gui:=FindText_Main
    _Gui.Opt("+LastFound")
    this.Hide()
    p:=this.GetRange2(), v:=p[1] ", " p[2] ", " p[3] ", " p[4]
    s:=_Gui["scr"].Value
    re:="i)(=FindText\([^\n]*?)([^(,\n]*,){4}([^,\n]*,[^,\n]*,[^,\n]*Text)"
    if SubStr(s,1,s~="i)\n\s*FindText[^\n]+args\*")~=re
    {
      s:=RegExReplace(s, re, "$1 " v ",$3",, 1)
      _Gui["scr"].Value:=s
    }
    _Gui["Offset"].Value:=v
    G_Show.Call()
    return
  Case "Test", "TestClip":
    _Gui:=FindText_Main
    _Gui.Opt("+LastFound")
    this.Hide()
    ;----------------------
    if (cmd="Test")
      s:=_Gui["scr"].Value
    else
      s:=_Gui["ClipText"].Value
    if (cmd="Test") && InStr(s, "MCode(")
    {
      s:="`n#NoEnv`nMenu, Tray, Click, 1`n" s "`nExitApp`n"
      Thread1:=new this.Thread(s)
      DetectHiddenWindows, 1
      WinWait % "ahk_class AutoHotkey ahk_pid " Thread1.pid,, 3
      if (!ErrorLevel)
        WinWaitClose,,, 30
      ; Thread1:=""  ; kill the Thread
    }
    else
    {
      t:=A_TickCount, v:=X:=Y:=""
      if RegExMatch(s, "O)<[^>\n]*>[^$\n]+\$[^""\r\n]+", r)
        v:=this.FindText(X, Y, 0,0,0,0, 0,0, r[0])
      r:=StrSplit(Lang["s8"] "||||", "|")
      MsgBox, 4096, Tip, % r[1] ":`t" (IsObject(v)?v.Length():v) "`n`n"
        . r[2] ":`t" (A_TickCount-t) " " r[3] "`n`n"
        . r[4] ":`t" X ", " Y "`n`n"
        . r[5] ":`t<" (IsObject(v)?v[1].id:"") ">", 3
      Try For i,j in v
        if (i<=2)
          this.MouseTip(j.x, j.y)
      v:="", Clipboard:=X "," Y
    }
    ;----------------------
    G_Show.Call()
    return
  Case "GetOffset", "GetClipOffset":
    FindText_Main.Hide()
    p:=this.GetRange()
    _Gui:=FindText_Main
    if (cmd="GetOffset")
      s:=_Gui["scr"].Value
    else
      s:=_Gui["ClipText"].Value
    if RegExMatch(s, "O)<[^>\n]*>[^$\n]+\$[^""\r\n]+", r)
    && this.FindText(X, Y, 0,0,0,0, 0,0, r[0])
    {
      r:=StrReplace("X+" ((p[1]+p[3])//2-X)
        . ", Y+" ((p[2]+p[4])//2-Y), "+-", "-")
      if (cmd="GetOffset")
      {
        re:="i)(\(\)\.\w*Click\w*\()[^,\n]*,[^,)\n]*"
        if SubStr(s,1,s~="i)\n\s*FindText[^\n]+args\*")~=re
          s:=RegExReplace(s, re, "$1" r,, 1)
        _Gui["scr"].Value:=s
      }
      _Gui["Offset"].Value:=r
    }
    s:="", G_Show.Call()
    return
  Case "Paste":
    if RegExMatch(Clipboard, "O)\|?<[^>\n]*>[^$\n]+\$[^""\r\n]+", r)
    {
      FindText_Main["ClipText"].Value:=r[0]
      FindText_Main["MyPic"].Value:=Trim(this.ASCII(r[0]),"`n")
    }
    return
  Case "CopyOffset":
    Clipboard:=FindText_Main["Offset"].Value
    return
  Case "Copy":
    ControlGet, s, Selected,,, ahk_id %hscr%
    if (s="")
    {
      s:=FindText_Main["scr"].Value
      r:=FindText_Main["AddFunc"].Value
      if (r != 1)
        s:=RegExReplace(s, "i)\n\s*FindText[^\n]+args\*[\s\S]*")
        , s:=RegExReplace(s, "i)\n; ok:=FindText[\s\S]*")
        , s:=SubStr(s, (s~="i)\n[ \t]*Text"))
    }
    Clipboard:=RegExReplace(s, "\R", "`r`n")
    ControlFocus,, % "ahk_id " hscr
    return
  Case "Apply":
    _Gui:=FindText_Main
    NowHotkey:=_Gui["NowHotkey"].Value
    SetHotkey1:=_Gui["SetHotkey1"].Value
    SetHotkey2:=_Gui["SetHotkey2"].Text
    if (NowHotkey!="")
      Hotkey, *%NowHotkey%,, Off UseErrorLevel
    k:=SetHotkey1!="" ? SetHotkey1 : SetHotkey2
    if (k!="")
      Hotkey, *%k%, %G_ScreenShot%, On UseErrorLevel
    _Gui["NowHotkey"].Value:=k
    _Gui["SetHotkey1"].Value:=""
    _Gui["SetHotkey2"].Choose(0)
    return
  Case "ScreenShot":
    Critical
    if !FileExist(SavePicDir)
      FileCreateDir % SavePicDir
    Loop
      f:=SavePicDir . Format("{:03d}.bmp",A_Index)
    Until !FileExist(f)
    this.SavePic(f, StrSplit(arg1,"|")*)
    CoordMode, ToolTip
    this.ToolTip(Lang["s9"],, 0,, { bgcolor:"Yellow", color:"Red"
      , size:48, bold:"bold", trans:200, timeout:0.2 })
    return
  Case "Bind0", "Bind1", "Bind2", "Bind3", "Bind4":
    this.BindWindow(Bind_ID, bind_mode:=SubStr(cmd,5))
    n:=150000, x:=y:=-n, w:=h:=2*n
    hBM:=this.BitmapFromScreen(x,y,w,h,1)
    G_.Call("PicUpdate")
    FindText_Capture["MyTab1"].Choose(2)
    this.BindWindow(0)
    return
  Case "MySlider1", "MySlider2":
    SetTimer % G_Slider, -10
    return
  Case "Slider":
    Critical
    dx:=nW>71 ? Round(FindText_Capture["MySlider1"].Value*(nW-71)/100):0
    dy:=nH>25 ? Round(FindText_Capture["MySlider2"].Value*(nH-25)/100):0
    if (oldx=dx && oldy=dy)
      return
    ListLines % (lls:=A_ListLines)?0:0
    Loop % 25 + 0*(ty:=dy-1)*(k:=0)
    Loop % 71 + 0*(tx:=dx-1)*(ty++)
      this.SC(((++tx)>=nW || ty>=nH || !show[i:=ty*nW+tx+1]
      ? WindowColor : bg="" ? cors[i] : ascii[i] ? 0:0xFFFFFF), C_[++k])
    Loop % 71*(oldx!=dx) + 0*(i:=nW*nH+dx)*(k:=71*25)
      this.SC((show[++i]?0xFF0000:0xFFFFAA), C_[++k])
    ListLines % lls
    oldx:=dx, oldy:=dy
    return
  Case "RepColor", "CutColor":
    if (cmd="RepColor")
      show[k]:=1, c:=(bg="" ? cors[k] : ascii[k] ? 0:0xFFFFFF)
    else
      show[k]:=0, c:=WindowColor
    if (tx:=Mod(k-1,nW)-dx)>=0 && tx<71 && (ty:=(k-1)//nW-dy)>=0 && ty<25
      this.SC(c, C_[ty*71+tx+1])
    return
  Case "RepL":
    if (CutLeft<=0) || (bg!="" && InStr(color,"**") && CutLeft=1)
      return
    k:=CutLeft-nW, CutLeft--
    Loop % nH
      k+=nW, (A_Index>CutUp && A_Index<nH+1-CutDown && G_.Call("RepColor"))
    return
  Case "CutL":
    if (CutLeft+CutRight>=nW)
      return
    CutLeft++, k:=CutLeft-nW
    Loop % nH
      k+=nW, (A_Index>CutUp && A_Index<nH+1-CutDown && G_.Call("CutColor"))
    return
  Case "CutL3":
    Loop 3
      G_.Call("CutL")
    return
  Case "RepR":
    if (CutRight<=0) || (bg!="" && InStr(color,"**") && CutRight=1)
      return
    k:=1-CutRight, CutRight--
    Loop % nH
      k+=nW, (A_Index>CutUp && A_Index<nH+1-CutDown && G_.Call("RepColor"))
    return
  Case "CutR":
    if (CutLeft+CutRight>=nW)
      return
    CutRight++, k:=1-CutRight
    Loop % nH
      k+=nW, (A_Index>CutUp && A_Index<nH+1-CutDown && G_.Call("CutColor"))
    return
  Case "CutR3":
    Loop 3
      G_.Call("CutR")
    return
  Case "RepU":
    if (CutUp<=0) || (bg!="" && InStr(color,"**") && CutUp=1)
      return
    k:=(CutUp-1)*nW, CutUp--
    Loop % nW
      k++, (A_Index>CutLeft && A_Index<nW+1-CutRight && G_.Call("RepColor"))
    return
  Case "CutU":
    if (CutUp+CutDown>=nH)
      return
    CutUp++, k:=(CutUp-1)*nW
    Loop % nW
      k++, (A_Index>CutLeft && A_Index<nW+1-CutRight && G_.Call("CutColor"))
    return
  Case "CutU3":
    Loop 3
      G_.Call("CutU")
    return
  Case "RepD":
    if (CutDown<=0) || (bg!="" && InStr(color,"**") && CutDown=1)
      return
    k:=(nH-CutDown)*nW, CutDown--
    Loop % nW
      k++, (A_Index>CutLeft && A_Index<nW+1-CutRight && G_.Call("RepColor"))
    return
  Case "CutD":
    if (CutUp+CutDown>=nH)
      return
    CutDown++, k:=(nH-CutDown)*nW
    Loop % nW
      k++, (A_Index>CutLeft && A_Index<nW+1-CutRight && G_.Call("CutColor"))
    return
  Case "CutD3":
    Loop 3
      G_.Call("CutD")
    return
  Case "Gray2Two":
    ListLines % (lls:=A_ListLines)?0:0
    gs:=[], k:=0
    Loop % nW*nH
      gs[++k]:=((((c:=cors[k])>>16)&0xFF)*38+((c>>8)&0xFF)*75+(c&0xFF)*15)>>7
    _Gui:=FindText_Capture
    _Gui["Threshold"].Focus()
    Threshold:=_Gui["Threshold"].Value
    if (Threshold="")
    {
      pp:=[]
      Loop 256
        pp[A_Index-1]:=0
      Loop % nW*nH
        if (show[A_Index])
          pp[gs[A_Index]]++
      IP0:=IS0:=0
      Loop 256
        k:=A_Index-1, IP0+=k*pp[k], IS0+=pp[k]
      Threshold:=Floor(IP0/IS0)
      Loop 20
      {
        LastThreshold:=Threshold
        IP1:=IS1:=0
        Loop % LastThreshold+1
          k:=A_Index-1, IP1+=k*pp[k], IS1+=pp[k]
        IP2:=IP0-IP1, IS2:=IS0-IS1
        if (IS1!=0 && IS2!=0)
          Threshold:=Floor((IP1/IS1+IP2/IS2)/2)
        if (Threshold=LastThreshold)
          Break
      }
      _Gui["Threshold"].Value:=Threshold
    }
    Threshold:=Round(Threshold)
    color:="*" Threshold, k:=i:=0
    Loop % nW*nH
      ascii[++k]:=v:=(gs[k]<=Threshold)
      , (show[k] && i:=(v?i+1:i-1))
    bg:=(i>0 ? "1":"0"), G_.Call("BlackWhite")
    ListLines % lls
    return
  Case "GrayDiff2Two":
    _Gui:=FindText_Capture
    GrayDiff:=_Gui["GrayDiff"].Value
    if (GrayDiff="")
    {
      _Gui.Opt("+OwnDialogs")
      MsgBox, 4096, Tip, % Lang["s11"], 1
      return
    }
    ListLines % (lls:=A_ListLines)?0:0
    gs:=[], k:=0
    Loop % nW*nH
      gs[++k]:=((((c:=cors[k])>>16)&0xFF)*38+((c>>8)&0xFF)*75+(c&0xFF)*15)>>7
    if (CutLeft=0)
      G_.Call("CutL")
    if (CutRight=0)
      G_.Call("CutR")
    if (CutUp=0)
      G_.Call("CutU")
    if (CutDown=0)
      G_.Call("CutD")
    GrayDiff:=Round(GrayDiff)
    color:="**" GrayDiff, k:=i:=0
    Loop % nW*nH
      j:=gs[++k]+GrayDiff
      , ascii[k]:=v:=( gs[k-1]>j || gs[k+1]>j
      || gs[k-nW]>j || gs[k+nW]>j
      || gs[k-nW-1]>j || gs[k-nW+1]>j
      || gs[k+nW-1]>j || gs[k+nW+1]>j )
      , (show[k] && i:=(v?i+1:i-1))
    bg:=(i>0 ? "1":"0"), G_.Call("BlackWhite")
    ListLines % lls
    return
  Case "AddColorSim", "AddColorDiff":
    _Gui:=FindText_Capture
    c:=StrReplace(_Gui["SelColor"].Value, "0x")
    if (c="")
    {
      _Gui.Opt("+OwnDialogs")
      MsgBox, 4096, Tip, % Lang["s12"], 1
      return
    }
    s:=_Gui["ColorList"].Value
    if InStr(cmd, "Sim")
      v:=_Gui["Similar1"].Value, v:=c "-" Round(v/100,2)
    else
      v:=_Gui["dRGB2"].Value, v:=c "-" Format("{:06X}",v<<16|v<<8|v)
    s:=RegExReplace("/" s, "/" c "-[^/]*") . "/" v
    _Gui["ColorList"].Value:=Trim(s,"/")
    ControlSend,, {End}, % "ahk_id " _Gui["ColorList"].Hwnd
    G_.Call("Color2Two")
    return
  Case "Undo2":
    _Gui:=FindText_Capture
    s:=_Gui["ColorList"].Value
    s:=RegExReplace("/" s, "/[^/]+$")
    _Gui["ColorList"].Value:=Trim(s,"/")
    ControlSend,, {End}, % "ahk_id " _Gui["ColorList"].Hwnd
    return
  Case "Color2Two":
    _Gui:=FindText_Capture
    color:=RegExReplace(_Gui["ColorList"].Value, "i)\s|0x")
    if (color="")
    {
      _Gui.Opt("+OwnDialogs")
      MsgBox, 4096, Tip, % Lang["s16"], 1
      return
    }
    ListLines % (lls:=A_ListLines)?0:0
    k:=i:=v:=0, arr:=StrSplit(Trim(StrReplace(color,"@","-"), "/"), "/")
    Loop % nW*nH
    {
      c:=cors[++k], rr:=(c>>16)&0xFF, gg:=(c>>8)&0xFF, bb:=c&0xFF
      For k1,v1 in arr
      {
        r:=StrSplit(Trim(v1,"-") "-", "-"), c:=this.ToRGB(r[1]), n:=r[2]
        , r:=((c>>16)&0xFF)-rr, g:=((c>>8)&0xFF)-gg, b:=(c&0xFF)-bb
        if InStr(n, ".")
        {
          n:=this.Floor(n), n:=(n<=0||n>1?0:Floor(9*255*255*(1-n)*(1-n)))
          if v:=(3*r*r+4*g*g+2*b*b<=n)
            Break
        }
        else
        {
          c:=this.Floor("0x" n), dR:=(c>>16)&0xFF, dG:=(c>>8)&0xFF, dB:=c&0xFF
          if v:=(Abs(r)<=dR && Abs(g)<=dG && Abs(b)<=dB)
            Break
        }
      }
      ascii[k]:=v, (show[k] && i:=(v?i+1:i-1))
    }
    bg:=(i>0 ? "1":"0"), G_.Call("BlackWhite")
    ListLines % lls
    return
  Case "ColorPos2Two":
    _Gui:=FindText_Capture
    c:=_Gui["SelColor"].Value
    if (c="")
    {
      _Gui.Opt("+OwnDialogs")
      MsgBox, 4096, Tip, % Lang["s12"], 1
      return
    }
    n:=_Gui["Similar2"].Value, n:=Round(n/100,2), color:="#" c "-" n
    , n:=(n<=0||n>1?0:Floor(9*255*255*(1-n)*(1-n)))
    , rr:=(c>>16)&0xFF, gg:=(c>>8)&0xFF, bb:=c&0xFF, k:=i:=0
    ListLines % (lls:=A_ListLines)?0:0
    Loop % nW*nH
      c:=cors[++k], r:=((c>>16)&0xFF)-rr, g:=((c>>8)&0xFF)-gg, b:=(c&0xFF)-bb
      , ascii[k]:=v:=3*r*r+4*g*g+2*b*b<=n, (show[k] && i:=(v?i+1:i-1))
    bg:=(i>0 ? "1":"0"), G_.Call("BlackWhite")
    ListLines % lls
    return
  Case "BlackWhite":
    Loop % 25 + 0*(ty:=dy-1)*(k:=0)
    Loop % 71 + 0*(tx:=dx-1)*(ty++)
    if (k++)*0 + (++tx)<nW && ty<nH && show[i:=ty*nW+tx+1]
      this.SC((ascii[i]?0:0xFFFFFF), C_[k])
    return
  Case "Modify":
    Modify:=FindText_Capture["Modify"].Value
    return
  Case "MultiColor":
    MultiColor:=FindText_Capture["MultiColor"].Value
    Result:=""
    ToolTip
    return
  Case "FindShape":
    FindShape:=FindText_Capture["FindShape"].Value
    (FindShape && !MultiColor) && FindText_Capture["MultiColor"].Value:=MultiColor:=1
    return
  Case "Undo":
    Result:=RegExReplace(Result, ",[^/]+/[^/]+/[^/]+$")
    ToolTip % Trim(Result, ",")
    return
  Case "Similar1", "Similar2", "Similar3":
    i:=FindText_Capture[cmd].Value
    For k,v in ["Similar1","Similar2","Similar3"]
      (v!=cmd) && FindText_Capture[v].Value:=i
    return
  Case "GetTxt":
    txt:=""
    if (bg="")
      return
    k:=0
    ListLines % (lls:=A_ListLines)?0:0
    Loop % nH
    {
      v:=""
      Loop % nW
        v.=!show[++k] ? "" : ascii[k] ? "1":"0"
      txt.=v="" ? "" : v "`n"
    }
    ListLines % lls
    return
  Case "Auto":
    G_.Call("GetTxt")
    if (txt="")
    {
      FindText_Capture.Opt("+OwnDialogs")
      MsgBox, 4096, Tip, % Lang["s13"], 1
      return
    }
    While InStr(txt,bg)
    {
      if (txt~="^" bg "+\n")
        txt:=RegExReplace(txt, "^" bg "+\n"), G_.Call("CutU")
      else if !(txt~="m`n)[^\n" bg "]$")
        txt:=RegExReplace(txt, "m`n)" bg "$"), G_.Call("CutR")
      else if (txt~="\n" bg "+\n$")
        txt:=RegExReplace(txt, "\n\K" bg "+\n$"), G_.Call("CutD")
      else if !(txt~="m`n)^[^\n" bg "]")
        txt:=RegExReplace(txt, "m`n)^" bg), G_.Call("CutL")
      else Break
    }
    txt:=""
    return
  Case "OK", "SplitAdd", "AllAdd":
    _Gui:=FindText_Capture
    _Gui.Opt("+OwnDialogs")
    G_.Call("GetTxt")
    if (txt="") && (!MultiColor)
    {
      MsgBox, 4096, Tip, % Lang["s13"], 1
      return
    }
    if InStr(color,"#") && (!MultiColor)
    {
      k:=i:=j:=0
      ListLines % (lls:=A_ListLines)?0:0
      Loop % nW*nH
      {
        if (!show[++k])
          Continue
        i++
        if (k=SelPos)
        {
          j:=i
          Break
        }
      }
      ListLines % lls
      if (j=0)
      {
        MsgBox, 4096, Tip, % Lang["s12"], 1
        return
      }
      color:="#" j "-" StrSplit(color "-","-")[2]
    }
    Comment:=_Gui["Comment"].Value
    if (cmd="SplitAdd") && (!MultiColor)
    {
      if InStr(color,"#")
      {
        MsgBox, 4096, Tip, % Lang["s14"], 3
        return
      }
      bg:=StrLen(StrReplace(txt,"0"))
        > StrLen(StrReplace(txt,"1")) ? "1":"0"
      s:="", i:=0, k:=nW*nH+1+CutLeft
      Loop % w:=nW-CutLeft-CutRight
      {
        i++
        if (!show[k++] && A_Index<w)
          Continue
        i:=Format("{:d}",i)
        v:=RegExReplace(txt,"m`n)^(.{" i "}).*","$1")
        txt:=RegExReplace(txt,"m`n)^.{" i "}"), i:=0
        While InStr(v,bg)
        {
          if (v~="^" bg "+\n")
            v:=RegExReplace(v,"^" bg "+\n")
          else if !(v~="m`n)[^\n" bg "]$")
            v:=RegExReplace(v,"m`n)" bg "$")
          else if (v~="\n" bg "+\n$")
            v:=RegExReplace(v,"\n\K" bg "+\n$")
          else if !(v~="m`n)^[^\n" bg "]")
            v:=RegExReplace(v,"m`n)^" bg)
          else Break
        }
        if (v!="")
        {
          v:=Format("{:d}.",InStr(v,"`n")-1) . this.bit2base64(v)
          s.="`nText.=""|<" SubStr(Comment,1,1) ">" color "$" v """`n"
          Comment:=SubStr(Comment, 2)
        }
      }
      Event:=cmd, Result:=s
      _Gui.Hide()
      return
    }
    if (!MultiColor)
      txt:=Format("{:d}.",InStr(txt,"`n")-1) . this.bit2base64(txt)
    else
    {
      n:=_Gui["Similar3"].Value, n:=Round(n/100,2), color:="##" n
      , n:=(n<=0||n>1?0:Floor(9*255*255*(1-n)*(1-n)))
      , arr:=StrSplit(Trim(StrReplace(Result,",","/"),"/"),"/"), s:="", i:=1
      SetFormat, IntegerFast, d
      Loop % arr.Length()//3
        x1:=arr[i++], y1:=arr[i++], c1:=arr[i++], c:="0x" c1
        , (A_Index=1 && (x:=x1, y:=y1, rr:=(c>>16)&0xFF, gg:=(c>>8)&0xFF, bb:=c&0xFF))
        , r:=((c>>16)&0xFF)-rr, g:=((c>>8)&0xFF)-gg, b:=(c&0xFF)-bb
        , s.="," (x1-x) "/" (y1-y) "/" (FindShape?3*r*r+4*g*g+2*b*b<=n:c1)
      txt:=SubStr(s,2)
    }
    s:="`nText.=""|<" Comment ">" color "$" txt """`n"
    if (cmd="SplitAdd" || cmd="AllAdd")
    {
      Event:=cmd, Result:=s
      _Gui.Hide()
      return
    }
    x:=nX+CutLeft+(nW-CutLeft-CutRight)//2
    y:=nY+CutUp+(nH-CutUp-CutDown)//2
    s:=StrReplace(s, "Text.=", "Text:="), r:=StrSplit(Lang["s8"] "|||||||", "|")
    s:="`; #Include <FindText>`n"
    . "`nt1:=A_TickCount, Text:=X:=Y:=""""`n" s
    . "`nif (ok:=FindText(X, Y, " x "-150000, "
    . y "-150000, " x "+150000, " y "+150000, 0, 0, Text))"
    . "`n{"
    . "`n  `; FindText()." . "Click(" . "X, Y, ""L"")"
    . "`n}`n"
    . "`n`; ok:=FindText(X:=""wait"", Y:=3, 0,0,0,0,0,0,Text)    `; " r[7]
    . "`n`; ok:=FindText(X:=""wait0"", Y:=-1, 0,0,0,0,0,0,Text)  `; " r[8]
    . "`n`nMsgBox, 4096, Tip, `% """ r[1] ":``t"" (IsObject(ok)?ok.Length():ok)"
    . "`n  . ""``n``n" r[2] ":``t"" (A_TickCount-t1) "" " r[3] """"
    . "`n  . ""``n``n" r[4] ":``t"" X "", "" Y"
    . "`n  . ""``n``n" r[5] ":``t<"" (IsObject(ok)?ok[1].id:"""") "">""`n"
    . "`nTry For i,v in ok  `; ok " r[6] " ok:=FindText().ok"
    . "`n  if (i<=2)"
    . "`n    FindText().MouseTip(ok[i].x, ok[i].y)`n"
    Event:=cmd, Result:=s
    _Gui.Hide()
    return
  Case "SavePic2":
    x:=nX+CutLeft, w:=nW-CutLeft-CutRight
    y:=nY+CutUp, h:=nH-CutUp-CutDown
    G_.Call("ScreenShot", x "|" y "|" (x+w-1) "|" (y+h-1) "|0")
    return
  Case "ShowPic":
    ControlGet, i, CurrentLine,,, ahk_id %hscr%
    ControlGet, s, Line, %i%,, ahk_id %hscr%
    FindText_Main["MyPic"].Value:=Trim(this.ASCII(s),"`n")
    return
  Case "KeyDown":
    Critical
    _Gui:=FindText_Main
    if (WinExist()!=_Gui.Hwnd)
      return
    Try ctrl:="", ctrl:=args[3]
    if (ctrl=hscr)
      SetTimer % G_ShowPic, -150
    else if (ctrl=_Gui["ClipText"].Hwnd)
    {
      s:=_Gui["ClipText"].Value
      _Gui["MyPic"].Value:=Trim(this.ASCII(s),"`n")
    }
    return
  Case "LButtonDown":
    Critical
    if (WinExist()!=FindText_Capture.Hwnd)
      return G_.Call("KeyDown", arg1, args*)
    CoordMode, Mouse
    MouseGetPos, k1, k2,, k6, 2
    if (k6=hPic)
    {
      ListLines % (lls:=A_ListLines)?0:0
      Loop
      {
        Sleep 50
        MouseGetPos, k3, k4
        this.RangeTip(Min(k1,k3), Min(k2,k4)
        , Abs(k1-k3)+1, Abs(k2-k4)+1, (A_MSec<500 ? "Red":"Blue"))
      }
      Until !this.State("LButton")
      ListLines % lls
      this.RangeTip()
      this.GetBitsFromScreen(,,,,0,zx,zy)
      this.ClientToScreen(sx, sy, 0, 0, hPic)
      sx:=Min(k1,k3)-sx+hBM_x+zx, sy:=Min(k2,k4)-sy+hBM_y+zy
      , sw:=Abs(k1-k3)+1, sh:=Abs(k2-k4)+1
      if (sw+sh)<5
        sx-=71//2, sy-=25//2, sw:=71, sh:=25
      G_.Call("CaptureUpdate")
      FindText_Capture["MyTab1"].Choose(1)
      return
    }
    if !(Cid_.HasKey(k6) && k5:=Cid_[k6])
      return
    if (k5=-1)
    {
      MouseMove, k1+2, k2+2, 0
      MouseGetPos,,,, k6, 2
      MouseMove, k1, k2, 0
      if !(Cid_.HasKey(k6) && k5:=Cid_[k6]) || (k5=-1)
        return
    }
    if (k5>71*25)
    {
      k1:=nW*nH+dx+(k5-71*25)
      this.SC(((show[k1]:=!show[k1])?0xFF0000:0xFFFFAA), k6)
      return
    }
    k3:=Mod(k5-1,71)+dx, k4:=(k5-1)//71+dy
    if (k3>=nW || k4>=nH)
      return
    k1:=k4*nW+k3+1
    if (Modify && bg!="" && show[k1])
      this.SC(((ascii[k1]:=!ascii[k1])?0:0xFFFFFF), k6)
    else
    {
      k2:=cors[k1], SelPos:=k1
      _Gui:=FindText_Capture
      _Gui["SelGray"].Value:=(((k2>>16)&0xFF)*38+((k2>>8)&0xFF)*75+(k2&0xFF)*15)>>7
      _Gui["SelColor"].Value:=Format("0x{:06X}",k2&0xFFFFFF)
      _Gui["SelR"].Value:=(k2>>16)&0xFF
      _Gui["SelG"].Value:=(k2>>8)&0xFF
      _Gui["SelB"].Value:=k2&0xFF
    }
    if (MultiColor && show[k1])
    {
      (FindShape && Result="") && G_.Call("ColorPos2Two")
      k2:=Format(",{:d}/{:d}/{:06X}", nX+k3, nY+k4, cors[k1]&0xFFFFFF)
      , Result.=InStr(Result,k2) ? "":k2
      ToolTip % Trim(Result, ",")
    }
    return
  Case "RButtonDown":
    Critical
    MouseGetPos,,,, k2, 2
    if (k2!=hPic)
      return
    CoordMode, Mouse
    MouseGetPos, k1, k2
    k5:=hBM_x, k6:=hBM_y
    ListLines % (lls:=A_ListLines)?0:0
    Loop
    {
      Sleep 10
      MouseGetPos, k3, k4
      hBM_x:=k5+k1-k3, hBM_y:=k6+k2-k4
      G_.Call("PicShow")
    }
    Until !this.State("RButton")
    ListLines % lls
    return
  Case "MouseMove":
    Try ctrl_name:="", ctrl_name:=this.GuiCtrlFromHwnd(args[3]).Name
    if (PrevControl != ctrl_name)
    {
      ToolTip
      PrevControl:=ctrl_name
      Try SetTimer % G_ToolTip, % (PrevControl ? -500:"Off")
      Try SetTimer % G_ToolTipOff, % (PrevControl ? -5500:"Off")
    }
    return
  Case "ToolTip":
    MouseGetPos,,, _TT
    if WinExist("ahk_id " _TT " ahk_class AutoHotkeyGUI")
      Try ToolTip % Tip_Text[PrevControl]
    return
  Case "ToolTipOff":
    ToolTip
    return
  Case "CutL2", "CutR2", "CutU2", "CutD2":
    s:=FindText_Main["MyPic"].Value
    s:=Trim(s,"`n") . "`n", v:=SubStr(cmd,4,1)
    if (v="U")
      s:=RegExReplace(s,"^[^\n]+\n")
    else if (v="D")
      s:=RegExReplace(s,"[^\n]+\n$")
    else if (v="L")
      s:=RegExReplace(s,"m`n)^[^\n]")
    else if (v="R")
      s:=RegExReplace(s,"m`n)[^\n]$")
    FindText_Main["MyPic"].Value:=Trim(s,"`n")
    return
  Case "Update":
    ControlFocus,, % "ahk_id " hscr
    ControlGet, i, CurrentLine,,, ahk_id %hscr%
    ControlGet, s, Line, %i%,, ahk_id %hscr%
    if !RegExMatch(s, "O)(<[^>\n]*>[^$\n]+\$)\d+\.[\w+/]+", r)
      return
    v:=FindText_Main["MyPic"].Value
    v:=Trim(v,"`n") . "`n", w:=Format("{:d}",InStr(v,"`n")-1)
    v:=StrReplace(StrReplace(v,"0","1"),"_","0")
    s:=StrReplace(s, r[0], r[1] . w "." this.bit2base64(v))
    v:="{End}{Shift Down}{Home}{Shift Up}{Del}"
    ControlSend,, %v%, ahk_id %hscr%
    Control, EditPaste, %s%,, ahk_id %hscr%
    ControlSend,, {Home}, ahk_id %hscr%
    return
  }
}

Lang(text:="", getLang:=0)
{
  local
  static init, Lang1, Lang2
  if !VarSetCapacity(init) && (init:="1")
  {
    s:="
    (
Myww       = Width = Adjust the width of the capture range
Myhh       = Height = Adjust the height of the capture range
AddFunc    = Add = Additional FindText() in Copy
NowHotkey  = Hotkey = Current screenshot hotkey
SetHotkey1 = = First sequence Screenshot hotkey
SetHotkey2 = = Second sequence Screenshot hotkey
Apply      = Apply = Apply new screenshot hotkey
CutU2      = CutU = Cut the Upper Edge of the text in the edit box below
CutL2      = CutL = Cut the Left Edge of the text in the edit box below
CutR2      = CutR = Cut the Right Edge of the text in the edit box below
CutD2      = CutD = Cut the Lower Edge of the text in the edit box below
Update     = Update = Update the text in the edit box below to the line of Code
GetRange   = GetRange = Get screen range to Clipboard and update the search range of the Code
GetOffset  = GetOffset = Get position offset relative to the Text from the Code and update FindText().Click()
GetClipOffset  = GetOffset2 = Get position offset relative to the Text from the Left Box
Capture    = Capture = Initiate Image Capture Sequence
CaptureS   = CaptureS = Restore the Saved ScreenShot by Hotkey and then start capturing
Test       = Test = Test the Text from the Code to see if it can be found on the screen
TestClip   = Test2 = Test the Text from the Left Box and copy the result to Clipboard
Paste      = Paste = Paste the Text from Clipboard to the Left Box
CopyOffset = Copy2 = Copy the Offset to Clipboard
Copy       = Copy = Copy the selected or all of the code to the clipboard
Reset      = Reset = Reset to Original Captured Image
SplitAdd   = SplitAdd = Using Markup Segmentation to Generate Text Library
AllAdd     = AllAdd = Append Another FindText Search Text into Previously Generated Code
Gray2Two      = Gray2Two = Converts Image Pixels from Gray Threshold to Black or White
GrayDiff2Two  = GrayDiff2Two = Converts Image Pixels from Gray Difference to Black or White
Color2Two     = Color2Two = Converts Image Pixels from Color List to Black or White
ColorPos2Two  = ColorPos2Two = Converts Image Pixels from Color Position to Black or White
SelGray    = Gray = Gray value of the selected color
SelColor   = Color = The selected color
SelR       = R = Red component of the selected color
SelG       = G = Green component of the selected color
SelB       = B = Blue component of the selected color
RepU       = -U = Undo Cut the Upper Edge by 1
CutU       = U = Cut the Upper Edge by 1
CutU3      = U3 = Cut the Upper Edge by 3
RepL       = -L = Undo Cut the Left Edge by 1
CutL       = L = Cut the Left Edge by 1
CutL3      = L3 = Cut the Left Edge by 3
Auto       = Auto = Automatic Cut Edge after image has been converted to black and white
RepR       = -R = Undo Cut the Right Edge by 1
CutR       = R = Cut the Right Edge by 1
CutR3      = R3 = Cut the Right Edge by 3
RepD       = -D = Undo Cut the Lower Edge by 1
CutD       = D = Cut the Lower Edge by 1
CutD3      = D3 = Cut the Lower Edge by 3
Modify     = Modify = Allows Modify the Black and White Image
MultiColor = FindMultiColor = Click multiple colors with the mouse, then Click OK button
FindShape  = FindShape = Click multiple colors, it will be binarized based on the first color
Undo       = Undo = Undo the last selected color
Undo2      = Undo = Undo the last added color in Color List
Comment    = Comment = Optional Comment used to Label Code ( Within <> )
Threshold  = Gray Threshold = Gray Threshold which Determines Black or White Pixel Conversion (0-255)
GrayDiff   = Gray Difference = Gray Difference which Determines Black or White Pixel Conversion (0-255)
Similar1   = Similarity = Adjust color similarity as Equivalent to The Selected Color
Similar2   = Similarity = Adjust color similarity as Equivalent to The Selected Color
Similar3   = Similarity = Adjust color similarity as Equivalent to The Selected Color
AddColorSim  = Add = Add Color to Color List and Run Color2Two
AddColorDiff = Add = Add Color to Color List and Run Color2Two
ColorList  = = Color list for converting black and white images
DiffRGB    = R/G/B = Determine the allowed R/G/B Error (0-255) when Find MultiColor
DiffRGB2   = R/G/B = Determine the allowed R/G/B Error (0-255)
Bind0      = BindWin1 = Bind the window and Use GetDCEx() to get the image of background window
Bind1      = BindWin1+ = Bind the window Use GetDCEx() and Modify the window to support transparency
Bind2      = BindWin2 = Bind the window and Use PrintWindow() to get the image of background window
Bind3      = BindWin2+ = Bind the window Use PrintWindow() and Modify the window to support transparency
Bind4      = BindWin3 = Bind the window and Use PrintWindow(,,3) to get the image of background window
OK         = OK = Create New FindText Code for Testing
OK2        = OK = Restore this ScreenShot then Capturing
Cancel     = Cancel = Close the Window Don't Do Anything
Cancel2    = Cancel = Close the Window Don't Do Anything
ClearAll   = ClearAll = Clean up all saved ScreenShots
OpenDir    = OpenDir = Open the saved screenshots directory
SavePic    = SavePic = Select a range and save as a picture
SavePic2   = SavePic = Save the trimmed original image as a picture
LoadPic    = LoadPic = Load a picture as Capture image
ClipText   = = Displays the Text data from clipboard
Offset     = = Displays the results of GetOffset2 or GetRange
SelectBox  = = Select a screenshot to display in the upper left corner of the screen
s1  = FindText
s2  = Gray|GrayDiff|Color|ColorPos|MultiColor
s3  = Capture Image To Text
s4  = Capture Image To Text and Find Text Tool
s5  = Direction keys to fine tune\nFirst click RButton(or Ctrl)\nMove the mouse away\nSecond click RButton(or Ctrl)
s6  = Unbind Window using
s7  = Drag a range with LButton(or Ctrl)\nCoordinates are copied to clipboard
s8  = Found|Time|ms|Pos|Result|value can be get from|Wait 3 seconds for appear|Wait indefinitely for disappear
s9  = Success
s10 = The Capture Position|Perspective binding window\nRight click to finish capture
s11 = Please Set Gray Difference First !
s12 = Please select the core color first !
s13 = Please convert the image to black or white first !
s14 = Can't be used in ColorPos mode, because it can cause position errors
s15 = Are you sure about the scope of your choice ?\n\nIf not, you can choose again
s16 = Please add colors to the color list first !
s17 = The picture you want to open was not found !
s18 = Capture|ScreenShot
s19 = Are you sure to delete all screenshots ?
    )"
    Lang1:=[], Lang2:=[]
    Loop Parse, s, `n, `r
      if InStr(v:=A_LoopField, "=")
        r:=StrSplit(StrReplace(v "==","\n","`n"), "=", "`t ")
        , Lang1[r[1]]:=r[2], Lang2[r[1]]:=r[3]
  }
  return getLang=1 ? Lang1 : getLang=2 ? Lang2 : Lang1[text]
}

;---------------------------------
; Gui-V1-V2 Compatibility Library  By FeiYue
;---------------------------------

GuiNew(args*) {
  return new this.GuiCreate(args*)
}

GuiFromHwnd(hwnd:="AllGuiObj", RecurseParent:=0) {
  static init, AllGuiObj
  if !VarSetCapacity(init) && (init:="1")
    AllGuiObj:=[]
  if (hwnd=="AllGuiObj")
    return AllGuiObj
  if (RecurseParent)
    While hwnd && !AllGuiObj.HasKey(hwnd)
      hwnd:=DllCall("GetParent", "Ptr",hwnd, "Ptr")
  return AllGuiObj[hwnd]
}

GuiCtrlFromHwnd(hwnd) {
  return this.GuiFromHwnd(hwnd,1)[hwnd]
}

GuiOnEvent(EventName, args*) {
  return this.GuiFromHwnd(WinExist())["_" EventName].Call(0,args*)
}

GuiClose(args*) {
  return FindText().GuiOnEvent("Close",args*)
}

GuiEscape(args*) {
  return FindText().GuiOnEvent("Escape",args*)
}

GuiSize(args*) {
  return FindText().GuiOnEvent("Size",args*)
}

GuiContextMenu(args*) {
  return FindText().GuiOnEvent("ContextMenu",args*)
}

GuiDropFiles(args*) {
  return FindText().GuiOnEvent("DropFiles",0,args*)
}

Class GuiCreate
{  ;// GuiCreate Class Begin

__New(opts:="", title:="", args*) {
  local
  Gui, New, % opts " +Hwndhwnd +LabelFindTextClass.Gui", % title
  this.Hwnd:=hwnd, this.ClassNN:=[]
  FindText().GuiFromHwnd()[hwnd]:=this
}

__Delete() {
  this.Destroy()
}

Destroy() {
  local
  if !(hwnd:=this.Hwnd)
    return
  this.Hwnd:="", FindText().GuiFromHwnd().Delete(hwnd)
  Try Gui, % hwnd ":Destroy"
  For k,v in this
    (v.Hwnd && v.Hwnd:=""), this[k]:=""
}

OnEvent(EventName, Callback, AddRemove:=1) {
  if IsObject(Callback)
    this["_" EventName]:=Callback
}

Opt(opts) {
  Gui, % this.Hwnd ":" RegExReplace(opts,"i)[+\-\s]Label\S*")
}

Add(type, opts:="", text:="") {
  local
  static init, type2class
  if !VarSetCapacity(init) && (init:="1")
    type2class:=[]
  type:=(type="DropDownList"?"DDL":type="Picture"?"Pic":type)
  name:=RegExMatch(opts,"i)(^|[+\-\s])V(?!Scroll\b|ertical\b)\K\S*",r)?r:""
  opts:=RegExReplace(opts,"i)(^|[+\-\s])V(?!Scroll\b|ertical\b)\S*")
  if IsObject(text)
  {
    s:=""
    For k,v in text
      s.="|" v
    text:=Trim(s, "|")
  }
  Gui, % this.Hwnd ":Add", % type, % opts " +Hwndhwnd", % text
  this.LastHwnd:=hwnd
  if type2class.HasKey(type)
    s:=type2class[type]
  else
  {
    WinGetClass, s, ahk_id %hwnd%
    type2class[type]:=s
  }
  this.ClassNN[s]:=n:=Floor(this.ClassNN[s])+1, classnn:=s . n
  obj:= new this.Control(this.Hwnd, hwnd, type, classnn, name)
  this[hwnd]:=obj, this[classnn]:=obj
  if (name) && !(name~="i)^(Destroy|OnEvent|Opt|Add"
  . "|SetFont|Show|Hide|Move|GetClientPos|GetPos|Maximize"
  . "|Minimize|Restore|Flash|Submit|Hwnd|Name|Title"
  . "|BackColor|MarginX|MarginY|MenuBar|FocusedCtrl)$")
    this[name]:=obj
  return obj
}

SetFont(opts:="", FontName:="") {
  Gui, % this.Hwnd ":Font", % opts, % FontName
}

Show(opts:="", args*) {
  Gui, % this.Hwnd ":Show", % opts
}

Hide() {
  Gui, % this.Hwnd ":Hide"
}

Move(x:="", y:="", w:="", h:="") {
  local
  this.GetPos(pX, pY, pW, pH)
  x:=(x=""?pX:x), y:=(y=""?pY:y), w:=(w=""?pW:w), h:=(h=""?pH:h)
  DllCall("MoveWindow", "Ptr",this.Hwnd, "int",x, "int",y, "int",w, "int",h, "int",1)
}

GetClientPos(ByRef x:="", ByRef y:="", ByRef w:="", ByRef h:="") {
  local
  VarSetCapacity(rect, 16, 0)
  , DllCall("GetClientRect",  "Ptr",this.Hwnd, "Ptr",&rect)
  , DllCall("ClientToScreen", "Ptr",this.Hwnd, "Ptr",&rect)
  , x:=NumGet(rect, 0, "int"), y:=NumGet(rect, 4, "int")
  , w:=NumGet(rect, 8, "int")-x, h:=NumGet(rect, 12, "int")-y
}

GetPos(ByRef x:="", ByRef y:="", ByRef w:="", ByRef h:="") {
  local
  VarSetCapacity(rect, 16, 0)
  , DllCall("GetWindowRect",  "Ptr",this.Hwnd, "Ptr",&rect)
  , x:=NumGet(rect, 0, "int"), y:=NumGet(rect, 4, "int")
  , w:=NumGet(rect, 8, "int")-x, h:=NumGet(rect, 12, "int")-y
}

Maximize() {
  Gui, % this.Hwnd ":Maximize"
}

Minimize() {
  Gui, % this.Hwnd ":Minimize"
}

Restore() {
  Gui, % this.Hwnd ":Restore"
}

Flash(k:=1) {
  Gui, % this.Hwnd ":Flash", % k ? "":"Off"
}

Submit(hide:=1) {
  local
  (hide && this.Hide()), arr:=[]
  For k,v in this
    if k is number
      if (v.Name!="")
        arr[v.Name]:=v.Value
  return arr
}

BackColor {
  get {
    return this._BackColor
  }
  set {
    this._BackColor:=value
    Gui, % this.Hwnd ":Color", % value
    return value
  }
}

MarginX {
  get {
    return this._MarginX
  }
  set {
    this._MarginX:=value
    Gui, % this.Hwnd ":Margin", % value
    return value
  }
}

MarginY {
  get {
    return this._MarginY
  }
  set {
    this._MarginY:=value
    Gui, % this.Hwnd ":Margin",, % value
    return value
  }
}

MenuBar {
  get {
    return this._MenuBar
  }
  set {
    this._MenuBar:=value
    Gui, % this.Hwnd ":Menu", % value
    return value
  }
}

Title {
  get {
    local
    VarSetCapacity(v, 260*2)
    DllCall("GetWindowText", "Ptr",this.Hwnd, "Str",v, "Int",260)
    return v
  }
  set {
    DllCall("SetWindowText", "Ptr",this.Hwnd, "Str",value)
    return value
  }
}

FocusedCtrl {
  get {
    local
    GuiControlGet, v, % this.Hwnd ":Focus"
    return this[v]
  }
}

Class Control
{  ;// Control Class Begin

__New(GuiHwnd, hwnd, type, classnn, name) {
  this.GuiHwnd:=GuiHwnd, this.Hwnd:=hwnd
  this.Type:=type, this.ClassNN:=classnn, this.Name:=name
}

Opt(opts) {
  GuiControl, % opts, % this.Hwnd
}

OnEvent(EventName, Callback, AddRemove:=1) {
  local
  r:=this.OnEvent_G.Bind(this, Callback)
  GuiControl, +g, % this.Hwnd, % r
}

OnEvent_G(Callback, args*) {
  if IsObject(Callback)
    return %Callback%(this, args*)
}

GetPos(ByRef x:="", ByRef y:="", ByRef w:="", ByRef h:="") {
  local
  GuiControlGet, p, Pos, % this.Hwnd
  x:=Floor(pX), y:=Floor(pY), w:=Floor(pW), h:=Floor(pH)
}

Move(x:="", y:="", w:="", h:="") {
  local
  s:=(x=""?"":" x" x) (y=""?"":" y" y) (w=""?"":" w" w) (h=""?"":" h" h)
  GuiControl, Move, % this.Hwnd, % s
}

Redraw() {
  GuiControl, MoveDraw, % this.Hwnd
}

Focus() {
  Try GuiControl, Focus, % this.Hwnd
}

UseTab(Name:="", Exact:="", index:="") {
  Gui, % this.GuiHwnd ":Tab", % Name, % index, % Exact?"Exact":""
}

SetFont(opts:="", FontName:="") {
  Gui, % this.GuiHwnd ":Font", % opts, % FontName
  GuiControl, Font, % this.Hwnd
}

Add(text) {
  local
  if IsObject(text)
  {
    s:=""
    For k,v in text
      s.="|" v
    text:=Trim(s, "|")
  }
  GuiControl,, % this.Hwnd, % text
}

Delete(N:="") {
  if (N="")
    GuiControl,, % this.Hwnd, |
  else
    this.Choose(N), this.Choose(0)
}

Choose(N) {
  if N is number
    GuiControl, Choose, % this.Hwnd, % N
  else
    GuiControl, ChooseString, % this.Hwnd, % N
}

Gui {
  get {
    return FindText().GuiFromHwnd(this.GuiHwnd)
  }
}

Enabled {
  get {
    local
    GuiControlGet, v, Enabled, % this.Hwnd
    return v
  }
  set {
    GuiControl, % "Enable" (!!value), % this.Hwnd
    return value
  }
}

Visible {
  get {
    local
    GuiControlGet, v, Visible, % this.Hwnd
    return v
  }
  set {
    GuiControl, % "Show" (!!value), % this.Hwnd
    return value
  }
}

Focused {
  get {
    local
    GuiControlGet, v, % this.GuiHwnd ":Focus"
    return (v=this.ClassNN)
  }
}

Value {
  get {
    local
    if (this.Type~="i)^(ListBox|DDL|ComboBox|Tab)$")
      this.Opt("+AltSubmit")
    GuiControlGet, v,, % this.Hwnd
    return v
  }
  set {
    if (this.Type~="i)^(ListBox|DDL|ComboBox|Tab)$")
      GuiControl, Choose, % this.Hwnd, % value
    else
      GuiControl,, % this.Hwnd, % value
    return value
  }
}

Text {
  get {
    local
    if (this.Type~="i)^(ListBox|DDL|ComboBox|Tab)$")
      this.Opt("-AltSubmit")
    GuiControlGet, v,, % this.Hwnd
    return v
  }
  set {
    if (this.Type~="i)^(ListBox|DDL|ComboBox|Tab)$")
      GuiControl, ChooseString, % this.Hwnd, % value
    else
      GuiControl,, % this.Hwnd, % value
    return value
  }
}

}  ;// Control Class End

}  ;// GuiCreate Class End

Script_End() {
}

}  ;// Class End

;================= The End =================

;
  
; Update Listen button text with current port
UpdateListenButton:
    Gui, Submit, NoHide
    GuiControlGet, btnText,, btnListen
    ; Only update if currently showing "Start Listening" (not "Stop Listening")
    If (InStr(btnText, "Start Listening")) {
        GuiControl,, btnListen, Start Listening (%hostPort%)
    }
Return

btnListen:
    GuiControlGet, btnText,, btnListen
    
    If (InStr(btnText, "Start Listening")) {
        GuiControlGet, hostPort,, hostPort
        
        ; Validate port
        If (hostPort = "" || hostPort < 1 || hostPort > 65535) {
            MsgBox, 0x10, Invalid Port, Please enter a valid port number (1-65535)
            Return
        }
        
        ; Start listening on specified port
        If (i := AHKsock_Listen(hostPort, "ServerEvents")) {
            AddLog("ERROR: AHKsock_Listen() failed with return value = " i " and ErrorLevel = " ErrorLevel)
            Return
        }
        GuiControl,, btnListen, Stop Listening (%hostPort%)
        AddLog("Server started on port " hostPort)
    } Else {
        ; Stop listening
        GuiControlGet, hostPort,, hostPort
        AHKsock_Listen(hostPort)
        GuiControl,, btnListen, Start Listening (%hostPort%)
        AddLog("Server stopped")
        
        ; Close all client connections
        For index, socket in Clients
            AHKsock_Close(socket)
        Clients := []
        UpdateClientCount()
    }
Return

btnPress3:
    SendCommandToAll("PRESS:3")
Return

btnPress1:
    SendCommandToAll("PRESS:1")
Return

btnPress31:
    SendCommandToAll("PRESS:3")
    Sleep, 100
    SendCommandToAll("PRESS:1")
Return

btnCtrlPress1:
    GuiControlGet, winTitle,, winTitle
    SendCommandToAll("CTRLSEND:" winTitle ":|:1")
Return

btnCtrlPress3:
    GuiControlGet, winTitle,, winTitle
    SendCommandToAll("CTRLSEND:" winTitle ":|:3")
Return

btnCtrlCustom:
    Gui, +OwnDialogs
    GuiControlGet, winTitle,, winTitle
    InputBox, key, ControlSend Custom, Enter key to send to window '%winTitle%':,,300,130
    If (!ErrorLevel && key)
        SendCommandToAll("CTRLSEND:" winTitle ":|:" key)
Return

btnCustom:
    Gui, +OwnDialogs
    helpText := "═══ COMMAND FORMATS ═══`n"
    helpText .= "PRESS:key - Press key on all clients`n"
    helpText .= "CTRLSEND:windowtitle:|:key - Send to specific window`n"
    helpText .= "CALL:FunctionName - Execute function on all`n"
    helpText .= "CALL:FunctionName(param) - With parameters`n"
    helpText .= "LOCAL:command - Execute only locally`n`n"
    
    helpText .= "═══ COMBAT FUNCTIONS ═══`n"
    helpText .= "CALL:TryCastDPSSkills`n"
    helpText .= "CALL:TryCastHealingSkill`n"
    helpText .= "CALL:TryCastCC`n"
    helpText .= "CALL:LoopCastUntilMobDead`n"
    helpText .= "nethealing,target,action - Control healing`n"
    helpText .= "netbuffs,target - Activate all buff timers`n`n"
    
    helpText .= "═══ NAVIGATION ═══`n"
    helpText .= "CALL:GoToWaypoint(25)`n"
    helpText .= "CALL:StartTravel (full route)`n"
    helpText .= "CALL:StopTravel`n"
    helpText .= "netnav,target,WP/NODE - Network navigation`n`n"
    
    helpText .= "═══ BUFFS & UTILITIES ═══`n"
    helpText .= "CALL:gnoll`n"
    helpText .= "CALL:DeathTyrant`n"
    helpText .= "CALL:DestroySkyPotions`n"
    helpText .= "CALL:PerformDuraRepair`n`n"
    
    helpText .= "═══ DEATH DETECTION ═══`n"
    helpText .= "CALL:StartDeathDetection`n"
    helpText .= "CALL:StopDeathDetection`n`n"
    
    helpText .= "═══ WAYPOINT COMMANDS ═══`n"
    helpText .= "netskill,key,target - Send key to windows`n"
    helpText .= "netcombat,duration,target - Combat sequence`n"
    helpText .= "netnav,target,destination - Navigate to WP/NODE`n"
    helpText .= "nethealing,target,start/stop - Control healing`n"
    helpText .= "netbuffs,target - Activate all buff timers`n`n"
    
    helpText .= "═══ EXAMPLES ═══`n"
    helpText .= "PRESS:1 (hotkey 1 all clients)`n"
    helpText .= "CTRLSEND:Rappelz:|:F5 (F5 to window)`n"
    helpText .= "LOCAL:CALL:GoToWaypoint(10) (this only)`n"
    helpText .= "netskill,3,win1 win2 (key 3 to win1&2)`n"
    helpText .= "netcombat,15,all (15s combat all clients)`n"
    helpText .= "netnav,all,WP 13 (all go to waypoint 13)`n"
    helpText .= "nethealing,win1 win2,start (start healing)`n"
    helpText .= "netbuffs,all (activate all buffs including DT & Gnoll)"
    
    ; Create custom GUI with scrollable help text
    Gui, CustomCmd:New
    Gui, CustomCmd:Add, Text, x10 y10, Command Help (scroll to view all):
    Gui, CustomCmd:Add, Edit, x10 y30 w480 h350 vHelpDisplay ReadOnly +VScroll, %helpText%
    Gui, CustomCmd:Add, Text, x10 y390, Enter command:
    Gui, CustomCmd:Add, Edit, x10 y410 w480 vCustomCommand
    Gui, CustomCmd:Add, Button, x10 y440 w100 gCustomCmdOK Default, OK
    Gui, CustomCmd:Add, Button, x120 y440 w100 gCustomCmdCancel, Cancel
    Gui, CustomCmd:Show, w500 h480, Custom Command
    Return
    
CustomCmdOK:
    Gui, CustomCmd:Submit
    Gui, CustomCmd:Destroy
    If (CustomCommand != "") {
        ; Check if command should be executed locally
        If (SubStr(CustomCommand, 1, 6) = "LOCAL:") {
            localCmd := SubStr(CustomCommand, 7)
            AddLog("Executing locally: " localCmd)
            ProcessCommand(localCmd)
        } Else {
            SendCommandToAll(CustomCommand)
        }
    }
    Return

CustomCmdCancel:
CustomCmdGuiClose:
    Gui, CustomCmd:Destroy
    Return

SelectAllClients:
    GuiControl,, TargetWin1, 1
    GuiControl,, TargetWin2, 1
    GuiControl,, TargetWin3, 1
    GuiControl,, TargetWin4, 1
    GuiControl,, TargetWin5, 1
    GuiControl,, TargetWin6, 1
    GuiControl,, TargetWin7, 1
    GuiControl,, TargetWin8, 1
    Return

SelectNoneClients:
    GuiControl,, TargetWin1, 0
    GuiControl,, TargetWin2, 0
    GuiControl,, TargetWin3, 0
    GuiControl,, TargetWin4, 0
    GuiControl,, TargetWin5, 0
    GuiControl,, TargetWin6, 0
    GuiControl,, TargetWin7, 0
    GuiControl,, TargetWin8, 0
    Return

OpenCommandList:
    ; Create a new GUI window with a list of commands
    Gui, CmdList:New, +AlwaysOnTop, Execute Commands on Selected Clients
    Gui, CmdList:Add, Text, x10 y10 w380 h20, Select a command to execute on the checked windows:
    
    ; Add ListBox with available commands
    Gui, CmdList:Add, ListBox, x10 y35 w380 h300 vSelectedCommand, AutoFollow Toggle|Character Select BD5|Get Coords|Load Path for All Clients|Start Healing|Stop Healing|Start DPS|Stop DPS|Setup DPS Navigation|Start Travel|Stop Travel|Press Key: 1|Press Key: 2|Press Key: 3|Press Key: 4|Press Key: 5|Press Key: F1|Press Key: F2|Press Key: F3|Press Key: F4|Press Key: F5|Press Key: F6|Press Key: F7|Press Key: F8|Press Key: Space|Press Key: Enter|Press Key: Escape|Reload Script
    
    Gui, CmdList:Add, Button, x10 y345 w180 h30 gExecuteSelectedCommand Default, Execute on Selected
    Gui, CmdList:Add, Button, x200 y345 w180 h30 gCmdListCancel, Cancel
    
    Gui, CmdList:Show, w400 h390
    Return

ExecuteSelectedCommand:
    Gui, CmdList:Submit, NoHide
    
    If (SelectedCommand = "") {
        MsgBox, Please select a command first!
        Return
    }
    
    ; Get checkbox values from the MAIN GUI (not the CmdList GUI)
    Gui, 1:Default
    GuiControlGet, TargetWin1
    GuiControlGet, TargetWin2
    GuiControlGet, TargetWin3
    GuiControlGet, TargetWin4
    GuiControlGet, TargetWin5
    GuiControlGet, TargetWin6
    GuiControlGet, TargetWin7
    GuiControlGet, TargetWin8
    
    ; Map the selected command to the actual command string
    commandToSend := ""
    
    If (SelectedCommand = "AutoFollow Toggle")
        commandToSend := "AUTOFOLLOW"
    Else If (SelectedCommand = "Character Select BD5")
        commandToSend := "CHARSELECT"
    Else If (SelectedCommand = "Get Coords")
        commandToSend := "GETCOORDS"
    Else If (SelectedCommand = "Load Path for All Clients") {
        ; Prompt user to select a path file
        FileSelectFile, selectedPath, 3, , Select a path file to load on all clients, INI Files (*.ini)
        If (ErrorLevel || selectedPath = "") {
            MsgBox, No file selected. Operation cancelled.
            Return
        }
        ; Read the entire file content
        FileRead, pathContent, %selectedPath%
        If (ErrorLevel) {
            MsgBox, Failed to read the selected file.
            Return
        }
        ; Encode the path content to send it (replace newlines with special marker)
        pathContent := StrReplace(pathContent, "`n", "<NL>")
        pathContent := StrReplace(pathContent, "`r", "")
        commandToSend := "LOADPATH:" . pathContent
    }
    Else If (SelectedCommand = "Start Healing")
        commandToSend := "STARTHEALING"
    Else If (SelectedCommand = "Stop Healing")
        commandToSend := "STOPHEALING"
    Else If (SelectedCommand = "Start DPS")
        commandToSend := "STARTDPS"
    Else If (SelectedCommand = "Stop DPS")
        commandToSend := "STOPDPS"
    Else If (SelectedCommand = "Setup DPS Navigation") {
        ; Prompt for group radius
        InputBox, groupRadius, DPS Navigation Setup, Enter the group radius (default 50):, , 300, 130, , , , , 50
        If (ErrorLevel)
            Return  ; User cancelled
        If (groupRadius = "")
            groupRadius := 50
        commandToSend := "SETUPDPSNAV:" . groupRadius
    }
    Else If (SelectedCommand = "Start Travel")
        commandToSend := "STARTTRAVEL"
    Else If (SelectedCommand = "Stop Travel")
        commandToSend := "STOPTRAVEL"
    Else If (SelectedCommand = "Press Key: 1")
        commandToSend := "PRESS:1"
    Else If (SelectedCommand = "Press Key: 2")
        commandToSend := "PRESS:2"
    Else If (SelectedCommand = "Press Key: 3")
        commandToSend := "PRESS:3"
    Else If (SelectedCommand = "Press Key: 4")
        commandToSend := "PRESS:4"
    Else If (SelectedCommand = "Press Key: 5")
        commandToSend := "PRESS:5"
    Else If (SelectedCommand = "Press Key: F1")
        commandToSend := "PRESS:F1"
    Else If (SelectedCommand = "Press Key: F2")
        commandToSend := "PRESS:F2"
    Else If (SelectedCommand = "Press Key: F3")
        commandToSend := "PRESS:F3"
    Else If (SelectedCommand = "Press Key: F4")
        commandToSend := "PRESS:F4"
    Else If (SelectedCommand = "Press Key: F5")
        commandToSend := "PRESS:F5"
    Else If (SelectedCommand = "Press Key: F6")
        commandToSend := "PRESS:F6"
    Else If (SelectedCommand = "Press Key: F7")
        commandToSend := "PRESS:F7"
    Else If (SelectedCommand = "Press Key: F8")
        commandToSend := "PRESS:F8"
    Else If (SelectedCommand = "Press Key: Space")
        commandToSend := "PRESS:Space"
    Else If (SelectedCommand = "Press Key: Enter")
        commandToSend := "PRESS:Enter"
    Else If (SelectedCommand = "Press Key: Escape")
        commandToSend := "PRESS:Escape"
    Else If (SelectedCommand = "Reload Script")
        commandToSend := "CALL:Reload"
    
    If (commandToSend != "") {
        AddLog("[COMMAND LIST] Executing: " SelectedCommand " (" commandToSend ")")
        AddLog("[DEBUG] Target states - Win1:" TargetWin1 " Win2:" TargetWin2 " Win3:" TargetWin3 " Win4:" TargetWin4 " Win5:" TargetWin5 " Win6:" TargetWin6 " Win7:" TargetWin7 " Win8:" TargetWin8)
        
        ; Execute locally if Win1 is checked
        If (TargetWin1) {
            AddLog("[COMMAND LIST] Executing locally on Win1")
            
            ; Handle special commands directly without going through labels that broadcast
            If (commandToSend = "AUTOFOLLOW") {
                ; Toggle autofollow and call ReturnToMainCharacter directly
                global autofolloww
                if (autofolloww) {
                    autofolloww := false
                    GuiControl,, StatusText, Status: Autofollow Disabled (Local)
                    AddLog("[Local] Autofollow disabled")
                } else {
                    autofolloww := true
                    GuiControl,, StatusText, Status: Autofollow Enabled (Local)
                    AddLog("[Local] Autofollow enabled")
                }
                ReturnToMainCharacter()
            } Else If (commandToSend = "CHARSELECT") {
                ; Call character select function directly
                PerformCharacterSelect()
            } Else If (commandToSend = "GETCOORDS") {
                ; Trigger Get Coords locally
                If (TargetGameWindow != "") {
                    WinActivate, ahk_id %TargetGameWindow%
                    Sleep, 150
                    Clipboard := "/info"
                    Send, {Enter}
                    Sleep, 80
                    Send, ^v
                    Sleep, 80
                    Send, {Enter}
                    Sleep, 300
                    AddLog("[Local] Sent /info command to game window")
                } Else {
                    AddLog("[Local] No game window selected")
                }
            } Else If (commandToSend = "STARTTRAVEL") {
                ; Start travel locally
                AddLog("[Local] Starting travel")
                StartTravel()
            } Else If (commandToSend = "STOPTRAVEL") {
                ; Stop travel locally
                AddLog("[Local] Stopping travel")
                Gosub, StopTravel
            } Else If (InStr(commandToSend, "LOADPATH:")) {
                ; Load path locally
                global SelectedRouteFile, NavSelectedRouteFile, Waypoints, TargetNodes
                pathData := SubStr(commandToSend, 10)
                AddLog("[Local] Loading path data")
                
                ; Decode the path content (restore newlines)
                pathData := StrReplace(pathData, "<NL>", "`n")
                
                ; Create a temporary INI file in the script directory
                tempPathFile := A_ScriptDir . "\temp_loaded_path.ini"
                FileDelete, %tempPathFile%
                FileAppend, %pathData%, %tempPathFile%
                
                If (FileExist(tempPathFile)) {
                    ; Set as the selected route file
                    SelectedRouteFile := tempPathFile
                    NavSelectedRouteFile := tempPathFile
                    
                    ; Load waypoints and nodes using existing functions
                    LoadWaypoints()
                    LoadNodes()
                    
                    ; Update GUI status
                    waypointCount := Waypoints.Length()
                    nodeCount := TargetNodes.Length()
                    GuiControl,, RouteStatus, Route: Loaded from network (%waypointCount% waypoints)
                    GuiControl,, NodeStatus, Nodes: %nodeCount% placed
                    GuiControl,, NavRouteStatus, Route: Loaded from network (%waypointCount% waypoints)
                    
                    ; Enable navigation buttons if waypoints exist
                    if (waypointCount > 0) {
                        GuiControl, Enable, PrevWaypointBtn
                        GuiControl, Enable, NextWaypointBtn
                        GuiControl, Enable, GotoBtn
                    }
                    
                    AddLog("[Local] Path loaded: " waypointCount " waypoints, " nodeCount " nodes")
                } Else {
                    AddLog("[Local] ERROR: Failed to create temporary path file")
                }
            } Else {
                ; For other commands, use ProcessCommand
                ProcessCommand(commandToSend)
            }
        }
        
        ; Send to selected network clients (Win2-Win8) only if any are checked
        If (TargetWin2 || TargetWin3 || TargetWin4 || TargetWin5 || TargetWin6 || TargetWin7 || TargetWin8) {
            AddLog("[DEBUG] Sending to network clients")
            ; AutoFollow and Load Path execute simultaneously on all clients (no sequential queue)
            If (commandToSend = "AUTOFOLLOW" || InStr(commandToSend, "LOADPATH:")) {
                SendCommandToSelectedSimultaneous(commandToSend)
            } Else {
                SendCommandToSelected(commandToSend)
            }
        } Else {
            AddLog("[DEBUG] No network clients selected, skipping network send")
        }
        
        ; Close the command list GUI
        Gui, CmdList:Destroy
    }
    Return

CmdListCancel:
CmdListGuiClose:
    Gui, CmdList:Destroy
    Return

TestAutoFollow:
    AddLog("[TEST] Processing AUTOFOLLOW locally and sending to selected clients...")
    ; Process locally first
    ProcessCommand("AUTOFOLLOW")
    ; Then send to selected clients
    SendCommandToSelected("AUTOFOLLOW")
    Return

TestCharSelect:
    ; Execute locally first using ProcessCommand
    ProcessCommand("CHARSELECT")
    ; Then send to selected clients
    SendCommandToSelected("CHARSELECT")
    Return
Return

SendCommandToAll(command, excludeSocket := "") {
    Global Clients, ClientSocket
    
    ; If we're connected as a client, send to the server
    If (ClientSocket != "" && ClientSocket != -1) {
        message := command . "`n"
        bufferSize := StrPut(message, "CP0")
        VarSetCapacity(msgBuffer, bufferSize)
        bytesWritten := StrPut(message, &msgBuffer, "CP0")
        ; Send the actual bytes (excluding null terminator)
        result := AHKsock_ForceSend(ClientSocket, &msgBuffer, bufferSize - 1)
        ; AHKsock_ForceSend returns nothing on success, negative on error
        If (result = "" || result >= 0)
            AddLog("Sent '" command "' to server (ClientSocket: " ClientSocket ")")
        Else
            AddLog("Failed to send to server (result: " result ")")
        Return
    }
    
    ; Otherwise, we're the server - send to all connected clients
    If (Clients.MaxIndex() = "" || Clients.MaxIndex() = 0) {
        ; Not connected to anyone - that's ok, just execute locally
        Return
    }
    
    ; Add newline delimiter to mark end of message
    message := command . "`n"
    bufferSize := StrPut(message, "CP0")
    sent := 0
    failed := 0
    
    For index, socket in Clients {
        ; Skip the excluded socket (original sender)
        If (excludeSocket != "" && socket = excludeSocket)
            Continue
        ; Get pointer to message variable
        VarSetCapacity(msgBuffer, bufferSize)
        bytesWritten := StrPut(message, &msgBuffer, "CP0")
        ; Try regular Send first (async), if that fails try ForceSend
        result := AHKsock_Send(socket, &msgBuffer, bufferSize - 1)
        AddLog("[DEBUG] Buffer size: " bufferSize ", Bytes written: " bytesWritten ", Sending: " (bufferSize - 1) " bytes")
        ; AHKsock_Send returns bytes queued (>=0) on success, negative on error
        If (result >= 0) {
            sent++
            AddLog("[DEBUG] Sent to socket " socket " successfully")
        } Else {
            failed++
            AddLog("[DEBUG] Failed to send to socket " socket " (result: " result ", ErrorLevel: " ErrorLevel ")")
        }
    }
    
    If (sent > 0)
        AddLog("Sent '" command "' to " sent " client(s)")
    If (failed > 0)
        AddLog("Failed to send to " failed " client(s)")
}

SendCommandToSelected(command) {
    Global Clients, ClientSocket, TargetWin1, TargetWin2, TargetWin3, TargetWin4, TargetWin5, TargetWin6, TargetWin7, TargetWin8
    Global SequentialCommandQueue, SequentialCommandIndex, WaitingForAck
    
    ; Get the checkbox states
    Gui, Submit, NoHide
    
    ; If we're connected as a client, send to the server
    ; The server will handle which clients to target based on the command format
    If (ClientSocket != "" && ClientSocket != -1) {
        ; Build target list based on checkboxes
        targetList := ""
        If (TargetWin2)
            targetList .= "2,"
        If (TargetWin3)
            targetList .= "3,"
        If (TargetWin4)
            targetList .= "4,"
        If (TargetWin5)
            targetList .= "5,"
        If (TargetWin6)
            targetList .= "6,"
        If (TargetWin7)
            targetList .= "7,"
        If (TargetWin8)
            targetList .= "8,"
        
        ; Remove trailing comma
        If (StrLen(targetList) > 0)
            targetList := SubStr(targetList, 1, StrLen(targetList) - 1)
        
        ; Send with target list: SELECTIVE:targets|command
        message := "SELECTIVE:" . targetList . "|" . command . "`n"
        bufferSize := StrPut(message, "CP0")
        VarSetCapacity(msgBuffer, bufferSize)
        bytesWritten := StrPut(message, &msgBuffer, "CP0")
        result := AHKsock_ForceSend(ClientSocket, &msgBuffer, bufferSize - 1)
        If (result = "" || result >= 0)
            AddLog("Sent selective command '" command "' to server for clients: " targetList)
        Else
            AddLog("Failed to send selective command to server (result: " result ")")
        Return
    }
    
    ; Otherwise, we're the server - queue clients for sequential execution
    If (Clients.MaxIndex() = "" || Clients.MaxIndex() = 0) {
        AddLog("No clients connected")
        Return
    }
    
    ; Build array of which client indices are selected (Win2=index 1, Win3=index 2, etc.)
    SequentialCommandQueue := []
    If (TargetWin2)
        SequentialCommandQueue.Push({index: 1, name: "Win2", command: command})
    If (TargetWin3)
        SequentialCommandQueue.Push({index: 2, name: "Win3", command: command})
    If (TargetWin4)
        SequentialCommandQueue.Push({index: 3, name: "Win4", command: command})
    If (TargetWin5)
        SequentialCommandQueue.Push({index: 4, name: "Win5", command: command})
    If (TargetWin6)
        SequentialCommandQueue.Push({index: 5, name: "Win6", command: command})
    If (TargetWin7)
        SequentialCommandQueue.Push({index: 6, name: "Win7", command: command})
    If (TargetWin8)
        SequentialCommandQueue.Push({index: 7, name: "Win8", command: command})
    
    If (SequentialCommandQueue.MaxIndex() = "" || SequentialCommandQueue.MaxIndex() = 0) {
        AddLog("No target clients selected")
        Return
    }
    
    AddLog("Queued command '" command "' for " SequentialCommandQueue.MaxIndex() " client(s) - executing sequentially")
    
    ; Start sequential execution
    SequentialCommandIndex := 1
    WaitingForAck := false
    SendNextQueuedCommand()
}

SendNextQueuedCommand() {
    Global SequentialCommandQueue, SequentialCommandIndex, WaitingForAck, Clients
    
    ; Check if we're done
    If (SequentialCommandIndex > SequentialCommandQueue.MaxIndex()) {
        AddLog("Sequential command execution complete")
        SequentialCommandQueue := []
        SequentialCommandIndex := 0
        WaitingForAck := false
        Return
    }
    
    ; Get current command to send
    currentTask := SequentialCommandQueue[SequentialCommandIndex]
    targetIndex := currentTask.index
    targetName := currentTask.name
    command := currentTask.command
    
    ; Check if this client is connected
    If (Clients.MaxIndex() < targetIndex) {
        AddLog("[Sequential] " targetName " not connected - skipping")
        SequentialCommandIndex++
        SendNextQueuedCommand()
        Return
    }
    
    socket := Clients[targetIndex]
    message := command . "`n"
    bufferSize := StrPut(message, "CP0")
    VarSetCapacity(msgBuffer, bufferSize)
    bytesWritten := StrPut(message, &msgBuffer, "CP0")
    
    AddLog("[Sequential] Sending '" command "' to " targetName " (socket " socket ")")
    result := AHKsock_Send(socket, &msgBuffer, bufferSize - 1)
    
    If (result >= 0) {
        WaitingForAck := true
        ; Set a timer to wait for ACK or timeout after 5 seconds
        SetTimer, CheckSequentialTimeout, -5000
    } Else {
        AddLog("[Sequential] Failed to send to " targetName " - skipping")
        SequentialCommandIndex++
        SendNextQueuedCommand()
    }
}

CheckSequentialTimeout:
    Global WaitingForAck, SequentialCommandQueue, SequentialCommandIndex
    
    If (WaitingForAck) {
        currentTask := SequentialCommandQueue[SequentialCommandIndex]
        AddLog("[Sequential] Timeout waiting for " currentTask.name " - moving to next")
        WaitingForAck := false
        SequentialCommandIndex++
        SendNextQueuedCommand()
    }
Return

SendCommandToSelectedSimultaneous(command) {
    Global Clients, ClientSocket, TargetWin2, TargetWin3, TargetWin4, TargetWin5, TargetWin6, TargetWin7, TargetWin8
    
    ; Get the checkbox states
    Gui, Submit, NoHide
    
    ; If we're connected as a client, send to the server
    If (ClientSocket != "" && ClientSocket != -1) {
        ; Build target list based on checkboxes
        targetList := ""
        If (TargetWin2)
            targetList .= "2,"
        If (TargetWin3)
            targetList .= "3,"
        If (TargetWin4)
            targetList .= "4,"
        If (TargetWin5)
            targetList .= "5,"
        If (TargetWin6)
            targetList .= "6,"
        If (TargetWin7)
            targetList .= "7,"
        If (TargetWin8)
            targetList .= "8,"
        
        ; Remove trailing comma
        If (StrLen(targetList) > 0)
            targetList := SubStr(targetList, 1, StrLen(targetList) - 1)
        
        ; Send with target list: SELECTIVE:targets|command
        message := "SELECTIVE:" . targetList . "|" . command . "`n"
        bufferSize := StrPut(message, "CP0")
        VarSetCapacity(msgBuffer, bufferSize)
        bytesWritten := StrPut(message, &msgBuffer, "CP0")
        result := AHKsock_ForceSend(ClientSocket, &msgBuffer, bufferSize - 1)
        If (result = "" || result >= 0)
            AddLog("Sent selective command '" command "' to server for clients: " targetList)
        Else
            AddLog("Failed to send selective command to server (result: " result ")")
        Return
    }
    
    ; Otherwise, we're the server - send to all selected clients simultaneously
    If (Clients.MaxIndex() = "" || Clients.MaxIndex() = 0) {
        AddLog("No clients connected")
        Return
    }
    
    message := command . "`n"
    bufferSize := StrPut(message, "CP0")
    sent := 0
    failed := 0
    
    ; Send to all selected clients at once (Win2=index 1, Win3=index 2, etc.)
    If (TargetWin2 && Clients.MaxIndex() >= 1) {
        socket := Clients[1]
        VarSetCapacity(msgBuffer, bufferSize)
        StrPut(message, &msgBuffer, "CP0")
        result := AHKsock_Send(socket, &msgBuffer, bufferSize - 1)
        If (result >= 0) {
            sent++
            AddLog("[Simultaneous] Sent '" command "' to Win2")
        } Else {
            failed++
        }
    }
    If (TargetWin3 && Clients.MaxIndex() >= 2) {
        socket := Clients[2]
        VarSetCapacity(msgBuffer, bufferSize)
        StrPut(message, &msgBuffer, "CP0")
        result := AHKsock_Send(socket, &msgBuffer, bufferSize - 1)
        If (result >= 0) {
            sent++
            AddLog("[Simultaneous] Sent '" command "' to Win3")
        } Else {
            failed++
        }
    }
    If (TargetWin4 && Clients.MaxIndex() >= 3) {
        socket := Clients[3]
        VarSetCapacity(msgBuffer, bufferSize)
        StrPut(message, &msgBuffer, "CP0")
        result := AHKsock_Send(socket, &msgBuffer, bufferSize - 1)
        If (result >= 0) {
            sent++
            AddLog("[Simultaneous] Sent '" command "' to Win4")
        } Else {
            failed++
        }
    }
    If (TargetWin5 && Clients.MaxIndex() >= 4) {
        socket := Clients[4]
        VarSetCapacity(msgBuffer, bufferSize)
        StrPut(message, &msgBuffer, "CP0")
        result := AHKsock_Send(socket, &msgBuffer, bufferSize - 1)
        If (result >= 0) {
            sent++
            AddLog("[Simultaneous] Sent '" command "' to Win5")
        } Else {
            failed++
        }
    }
    If (TargetWin6 && Clients.MaxIndex() >= 5) {
        socket := Clients[5]
        VarSetCapacity(msgBuffer, bufferSize)
        StrPut(message, &msgBuffer, "CP0")
        result := AHKsock_Send(socket, &msgBuffer, bufferSize - 1)
        If (result >= 0) {
            sent++
            AddLog("[Simultaneous] Sent '" command "' to Win6")
        } Else {
            failed++
        }
    }
    If (TargetWin7 && Clients.MaxIndex() >= 6) {
        socket := Clients[6]
        VarSetCapacity(msgBuffer, bufferSize)
        StrPut(message, &msgBuffer, "CP0")
        result := AHKsock_Send(socket, &msgBuffer, bufferSize - 1)
        If (result >= 0) {
            sent++
            AddLog("[Simultaneous] Sent '" command "' to Win7")
        } Else {
            failed++
        }
    }
    If (TargetWin8 && Clients.MaxIndex() >= 7) {
        socket := Clients[7]
        VarSetCapacity(msgBuffer, bufferSize)
        StrPut(message, &msgBuffer, "CP0")
        result := AHKsock_Send(socket, &msgBuffer, bufferSize - 1)
        If (result >= 0) {
            sent++
            AddLog("[Simultaneous] Sent '" command "' to Win8")
        } Else {
            failed++
        }
    }
    
    If (sent > 0)
        AddLog("Sent '" command "' simultaneously to " sent " client(s)")
    If (failed > 0)
        AddLog("Failed to send to " failed " client(s)")
}

ServerEvents(sEvent, iSocket = 0, sName = 0, sAddr = 0, sPort = 0, ByRef bData = 0, iLength = 0) {
    Global Clients
    
    If (sEvent = "ACCEPTED") {
        ; A client connected - check if socket already exists before adding
        alreadyExists := False
        For index, socket in Clients {
            If (socket = iSocket) {
                alreadyExists := True
                Break
            }
        }
        
        If (!alreadyExists) {
            Clients.Push(iSocket)
            AddLog("Client connected from " sAddr ":" sPort " (Socket: " iSocket ")")
            AddLog("DEBUG: Array now has " Clients.Length() " clients")
            UpdateClientCount()
        } Else {
            AddLog("DEBUG: Socket " iSocket " already in array, not adding")
        }
        
    } Else If (sEvent = "SEND") {
        ; SEND event - socket completed a send operation
        ; Not used for tracking - sockets can receive anytime after ACCEPTED
        
    } Else If (sEvent = "DISCONNECTED") {
        ; Client disconnected - find and remove from arrays
        removed := False
        For index, socket in Clients {
            If (socket = iSocket) {
                Clients.RemoveAt(index)
                removed := True
                AddLog("Client disconnected (Socket: " iSocket ")")
                AddLog("DEBUG: Removed at index " index ", array now has " Clients.Length() " clients")
                UpdateClientCount()
                Break
            }
        }

        If (!removed) {
            AddLog("DEBUG: DISCONNECTED event for socket " iSocket " but not found in array (current count: " Clients.Length() ")")
        }
        
    } Else If (sEvent = "RECEIVED") {
        ; Received data from client - process it and relay to all other clients
        Global WaitingForAck, SequentialCommandIndex
        data := StrGet(&bData, iLength, "CP0")
        
        ; Remove newline delimiters
        data := StrReplace(data, "`n", "")
        data := StrReplace(data, "`r", "")
        
        If (data != "") {
            AddLog("Received from client " iSocket ": " data)
            
            ; Handle command completion acknowledgment for sequential execution
            If (data = "CMDCOMPLETE") {
                If (WaitingForAck) {
                    AddLog("[Sequential] Command completed, proceeding to next")
                    WaitingForAck := false
                    SetTimer, CheckSequentialTimeout, Off
                    SequentialCommandIndex++
                    SendNextQueuedCommand()
                }
                Return
            }
            
            ; Filter out ACK messages - don't process or broadcast them
            If (SubStr(data, 1, 4) = "ACK:") {
                AddLog("[DEBUG] Acknowledgment received, not broadcasting")
                Return
            }
            
            ; Filter out ERROR messages - don't broadcast them
            If (SubStr(data, 1, 6) = "ERROR:") {
                AddLog("[DEBUG] Error message received, not broadcasting")
                Return
            }
            
            ; Process the command on this server instance
            ProcessCommand(data)
            
            ; Small delay to ensure sockets are stable before relaying
            Sleep, 10
            
            ; Broadcast to all connected clients EXCEPT the sender
            SendCommandToAll(data, iSocket)
        }
    }
}

UpdateClientCount() {
    Global Clients
    count := Clients.Length()
    GuiControl,, lblClients, %count% client(s) connected
}

AddLog(message) {
    GuiControlGet, currentLog,, txtLog
    FormatTime, timestamp,, HH:mm:ss
    newEntry := timestamp . " - " . message . "`n"
    
    ; Add new entry at the top
    newLog := newEntry . currentLog
    
    ; Keep only last 100 lines
    lineCount := 0
    trimmedLog := ""
    Loop, Parse, newLog, `n
    {
        lineCount++
        If (lineCount > 100)
            Break
        trimmedLog .= A_LoopField . "`n"
    }
    
    GuiControl,, txtLog, %trimmedLog%
}

AddClientLog(message) {
    GuiControlGet, currentLog,, txtClientLog
    FormatTime, timestamp,, HH:mm:ss
    newEntry := timestamp . " - " . message . "`n"
    
    ; Add new entry at the top
    newLog := newEntry . currentLog
    
    ; Keep only last 100 lines
    lineCount := 0
    trimmedLog := ""
    Loop, Parse, newLog, `n
    {
        lineCount++
        If (lineCount > 100)
            Break
        trimmedLog .= A_LoopField . "`n"
    }
    
    GuiControl,, txtClientLog, %trimmedLog%
}

GuiEscape:
CloseAHKsock:
    AHKsock_Close()
ExitApp
/*! TheGood
    AHKsock - A simple AHK implementation of Winsock.
    http://www.autohotkey.com/forum/viewtopic.php?p=355775
    Last updated: January 19, 2011
    
FUNCTION LIST:

________________________________________
AHKsock_Listen(sPort, sFunction = False)

Tells AHKsock to listen on the port in sPort, and call the function in sFunction when events occur. If sPort is a port on
which AHKsock is already listening, the action taken depends on sFunction:
    - If sFunction is False, AHKsock will stop listening on the port in sPort.
    - If sFunction is "()", AHKsock will return the name of the current function AHKsock calls when
      a client connects on the port in sPort.
    - If sFunction is a valid function, AHKsock will set that function as the new function to call
      when a client connects on the port in sPort.

Returns blank on success. On failure, it returns one of the following positive integer:
    2: sFunction is not a valid function.
    3: The WSAStartup() call failed. The error is in ErrorLevel.
    4: The Winsock DLL does not support version 2.2.
    5: The getaddrinfo() call failed. The error is in ErrorLevel.
    6: The socket() call failed. The error is in ErrorLevel.
    7: The bind() call failed. The error is in ErrorLevel.
    8: The WSAAsyncSelect() call failed. The error is in ErrorLevel.
    9: The listen() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

See the section titled "STRUCTURE OF THE EVENT-HANDLING FUNCTION AND MORE INFO ABOUT SOCKETS" for more info about how the
function in sFunction interacts with AHKsock.

________________________________________
AHKsock_Connect(sName, sPort, sFunction)

Tells AHKsock to connect to the hostname or IP address in sName on the port in sPort, and call the function in sFunction
when events occur.

Although the function will return right away, the connection attempt will still be in progress. Once the connection attempt
is over, successful or not, sFunction will receive the CONNECTED event. Note that it is important that once AHKsock_Connect
returns, the current thread must stay (or soon after must become) interruptible so that sFunction can be called once the
connection attempt is over.

AHKsock_Connect can only be called again once the previous connection attempt is over. To check if AHKsock_Connect is ready
to make another connection attempt, you may keep polling it by calling AHKsock_Connect(0,0,0) until it returns False.

Returns blank on success. On failure, it returns one of the following positive integer:
    1: AHKsock_Connect is still processing a connection attempt. ErrorLevel contains the name and the port of that
       connection attempt, separated by a tab.
    2: sFunction is not a valid function.
    3: The WSAStartup() call failed. The error is in ErrorLevel.
    4: The Winsock DLL does not support version 2.2.
    5: The getaddrinfo() call failed. The error is in ErrorLevel.
    6: The socket() call failed. The error is in ErrorLevel.
    7: The WSAAsyncSelect() call failed. The error is in ErrorLevel.
    8: The connect() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

See the section titled "STRUCTURE OF THE EVENT-HANDLING FUNCTION AND MORE INFO ABOUT SOCKETS" for more info about how the
function in sFunction interacts with AHKsock.
-+
_______________________________________
AHKsock_Send(iSocket, ptrData, iLength)

Sends the data of length iLength to which ptrData points to the connected socket in iSocket.

Returns the number of bytes sent on success. This can be less than the number requested to be sent in the iLength parameter,
i.e. between 1 and iLength. This would occur if no buffer space is available within the transport system to hold the data to
be transmitted, in which case the number of bytes sent can be between 1 and the requested length, depending on buffer
availability on both the client and server computers. On failure, it returns one of the following negative integer:
    -1: WSAStartup hasn't been called yet.
    -2: Received WSAEWOULDBLOCK. This means that calling send() would have blocked the thread.
    -3: The send() call failed. The error is in ErrorLevel.
    -4: The socket specified in iSocket is not a valid socket. This means either that the socket in iSocket hasn't been
        created using AHKsock_Connect or AHKsock_Listen, or that the socket has already been destroyed.
    -5: The socket specified in iSocket is not cleared for sending. You haven't waited for the SEND event before calling,
        either ever, or not since you last received WSAEWOULDBLOCK.

You may start sending data to the connected socket in iSocket only after the socket's associated function receives the first
SEND event. Upon receiving the event, you may keep calling AHKsock_Send to send data until you receive the error -2, at
which point you must wait once again until you receive another SEND event before sending more data. Not waiting for the SEND
event results in receiving error -5 when calling AHKsock_Send.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

____________________________________________
AHKsock_ForceSend(iSocket, ptrData, iLength)

This function is exactly the same as AHKsock_Send, but with three differences:
    - If only part of the data could be sent, it will automatically keep trying to send the remaining part.
    - If it receives WSAEWOULDBLOCK, it will wait for the socket's SEND event and try sending the data again.
    - If the data buffer to send is larger than the socket's send buffer size, it will automatically send the data in
      smaller chunks in order to avoid a performance hit. See http://support.microsoft.com/kb/823764 for more info.

Therefore, AHKsock_ForceSend will return only when all the data has been sent. Because this function relies on waiting for
the socket's SEND event before continuing to send data, it cannot be called in a critical thread. Also, for the same reason,
it cannot be called from a socket's associated function (not specifically iSocket's associated function, but any socket's
associated function).

Another limitation to consider when choosing between AHKsock_Send and AHKsock_ForceSend is that AHKsock_ForceSend will not
return until all the data has been sent (unless an error occurs). Although the script will still be responsive (new threads
will still be able to launch), the thread from which it was called will not resume until it returns. Therefore, if sending
a large amount of data, you should either use AHKsock_Send, or use AHKsock_ForceSend by feeding it smaller pieces of the
data, allowing you to update the GUI if necessary (e.g. a progress bar).

Returns blank on success, which means that all the data to which ptrData points of length iLength has been sent. On failure,
it returns one of the following negative integer:
    -1: WSAStartup hasn't been called yet.
    -3: The send() call failed. The error is in ErrorLevel.
    -4: The socket specified in iSocket is not a valid socket. This means either that the socket in iSocket hasn't been
        created using AHKsock_Connect or AHKsock_Listen, or that the socket has already been destroyed.
    -5: The current thread is critical.
    -6: The getsockopt() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

____________________________________________
AHKsock_Close(iSocket = -1, iTimeout = 5000)

Closes the socket in iSocket. If no socket is specified, AHKsock_Close will close all the sockets on record, as well as
terminate use of the Winsock 2 DLL (by calling WSACleanup). If graceful shutdown cannot be attained after the timeout
specified in iTimeout (in milliseconds), it will perform a hard shutdown before calling WSACleanup to free resources. See
the section titled "NOTES ON CLOSING SOCKETS AND AHKsock_Close" for more information.

Returns blank on success. On failure, it returns one of the following positive integer:
    1: The shutdown() call failed. The error is in ErrorLevel. AHKsock_Close forcefully closed the socket and freed the
       associated resources.

Note that when AHKsock_Close is called with no socket specified, it will never return an error.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

___________________________________________________________
AHKsock_GetAddrInfo(sHostName, ByRef sIPList, bOne = False)

Retrieves the list of IP addresses that correspond to the hostname in sHostName. The list is contained in sIPList, delimited
by newline characters. If bOne is True, only one IP (the first one) will be returned.

Returns blank on success. On failure, it returns one of the following positive integer:
    1: The WSAStartup() call failed. The error is in ErrorLevel.
    2: The Winsock DLL does not support version 2.2.
    3: Received WSAHOST_NOT_FOUND. No such host is known.
    4: The getaddrinfo() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

_________________________________________________________________________
AHKsock_GetNameInfo(sIP, ByRef sHostName, sPort = 0, ByRef sService = "")

Retrieves the hostname that corresponds to the IP address in sIP. If a port in sPort is supplied, it also retrieves the
service that corresponds to the port in sPort.

Returns blank on success. On failure, it returns on of the following positive integer:
    1: The WSAStartup() call failed. The error is in ErrorLevel.
    2: The Winsock DLL does not support version 2.2.
    3: The IP address supplied in sIP is invalid.
    4: The getnameinfo() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

______________________________________________
AHKsock_SockOpt(iSocket, sOption, iValue = -1)

Retrieves or sets a socket option. Supported options are:
    SO_KEEPALIVE: Enable/Disable sending keep-alives. iValue must be True/False to enable/disable. Disabled by default.
    SO_SNDBUF:    Total buffer space reserved for sends. Set iValue to 0 to completely disable the buffer. Default is 8 KB.
    SO_RCVBUF:    Total buffer space reserved for receives. Default is 8 KB.
    TCP_NODELAY:  Enable/Disable the Nagle algorithm for send coalescing. Set iValue to True to disable the Nagle algorithm,
                  set iValue to False to enable the Nagle algorithm, which is the default.

It is usually best to leave these options to their default (especially the Nagle algorithm). Only change them if you
understand the consequences. See MSDN for more information on those options.

If iValue is specified, it sets the option to iValue and returns blank on success. If iValue is left as -1, it returns the
value of the option specified. On failure, it returns one of the following negative integer:
    -1: The getsockopt() failed. The error is in ErrorLevel.
    -2: The setsockopt() failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

_______________________________________
AHKsock_Settings(sSetting, sValue = "")

Changes the AHKsock setting in sSetting to sValue. If sValue is blank, the current value for that setting is returned. If
sValue is the word "Reset", the setting is restored to its default value. The possible settings are:
    Message: Determines the Windows message numbers used to monitor network events. The message number in iMessage and the
             next number will be used. Default value is 0x8000. For example, calling AHKsock_Settings("Message", 0x8005)
             will cause AHKsock to use 0x8005 and 0x8006 to monitor network events.
    Buffer:  Determines the size of the buffer (in bytes) used when receiving data. This is thus the maximum size of bData
             when the RECEIVED event is raised. If the data received is more than the buffer size, multiple recv() calls
             (and thus multiple RECEIVED events) will be needed. Note that you shouldn't use this setting as a means of
             delimiting frames. See the "NOTES ON RECEIVING AND SENDING DATA" section for more information about receiving
             and sending data. Default value is 64 KB, which is the maximum for TCP.

If you do call AHKsock_Settings to change the values from their default ones, it is best to do so at the beginning of the
script. The message number used cannot be changed as long as there are active connections.

______________________________________
AHKsock_ErrorHandler(sFunction = """")

Sets the function in sFunction to be the new error handler. If sFunction is left at its default value, it returns the name
of the current error handling function.

An error-handling function is optional, but may be useful when troubleshooting applications. The function will be called
anytime there is an error that arises in a thread which wasn't called by the user but by the receival of a Windows message
which was registered using OnMessage.

The function in sFunction must be of the following format:
MyErrorHandler(iError, iSocket)

The possible values for iError are:
     1: The connect() call failed. The error is in ErrorLevel.
     2: The WSAAsyncSelect() call failed. The error is in ErrorLevel.
     3: The socket() call failed. The error is in ErrorLevel.
     4: The WSAAsyncSelect() call failed. The error is in ErrorLevel.
     5: The connect() call failed. The error is in ErrorLevel.
     6: FD_READ event received with an error. The error is in ErrorLevel. The socket is in iSocket.
     7: The recv() call failed. The error is in ErrorLevel. The socket is in iSocket.
     8: FD_WRITE event received with an error. The error is in ErrorLevel. The socket is in iSocket.
     9: FD_ACCEPT event received with an error. The error is in ErrorLevel. The socket is in iSocket.
    10: The accept() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
    11: The WSAAsyncSelect() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
    12: The listen() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
    13: The shutdown() call failed. The error is in ErrorLevel. The socket is in iSocket.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

__________________________________________________________________
NOTES ON SOCKETS AND THE STRUCTURE OF THE EVENT-HANDLING FUNCTION:

The functions used in the sFunction parameter of AHKsock_Listen and AHKsock_Connect must be of the following format:

MyFunction(sEvent, iSocket = 0, sName = 0, sAddr = 0, sPort = 0, ByRef bData = 0, bDataLength = 0)

The variable sEvent contains the event for which MyFunction was called. The event raised is associated with one and only one
socket; the one in iSocket. The meaning of the possible events that can occur depend on the type of socket involved. AHKsock
deals with three different types of sockets:
    - Listening sockets: These sockets are created by a call to AHKsock_Listen. All they do is wait for clients to request
      a connection. These sockets will never appear as the iSocket parameter because requests for connections are
      immediately accepted, and MyFunction immediately receives the ACCEPTED event with iSocket set to the accepted socket.
    - Accepted sockets: These sockets are created once a listening socket receives an incoming connection attempt from a
      client and accepts it. They are thus the sockets that servers use to communicate with clients.
    - Connected sockets: These sockets are created by a successful call to AHKsock_Connect. These are the sockets that
      clients use to communicate with servers.

More info about sockets:
    - You may have multiple client sockets connecting to the same listening socket (ie. on the same port).
    - You may have multiple listening sockets for different ports.
    - You cannot have more than one listening socket for the same port (or you will receive a bind() error).
    - Every single connection between a client and a server will have its own client socket on the client side, and its own
      server (accepted) socket on the server side.

For all of the events that the event-handling function receives,
    - sEvent contains the event that occurred (as described below),
    - iSocket contains the socket on which the event occurred,
    - sName contains a value which depends on the type of socket in iSocket:
        - If the socket is an accepted socket, sName is empty.
        - If the socket is a connected socket, sName is the same value as the sName parameter that was used when
          AHKsock_Connect was called to create the socket. Since AHKsock_Connect accepts both hostnames and IP addresses,
          sName may contain either.
    - sAddr contains the IP address of the socket's endpoint (i.e. the peer's IP address). This means that if the socket in
      iSocket is an accepted socket, sAddr contains the IP address of the client. Conversely, if it is a connected socket,
      sAddr contains the server's IP.
    - sPort contains the server port on which the connection was accepted.

Obviously, if your script only calls AHKsock_Listen (acting as a server) or AHKsock_Connect (acting as a client) you don't
need to check if the socket in iSocket is an accepted socket or a connected socket, since it can only be one or the other.
But if you do call both AHKsock_Listen and AHKsock_Connect with both of them using the same function (e.g. MyFunction), then
you will need to check what type of socket iSocket is by checking the sName parameter.

Of course, it would be easier to simply have two different functions, for example, MyFunction1 and MyFunction2, with one
handling the server part and the other handling the client part so that you don't need to check what type of socket iSocket
is when each function is called. However, this might not be necessary if both server and client are "symmetrical" (i.e. the
conversation doesn't actually change whether or not we're on the server side or the client side). See Example 3 for an
example of this, where only one function is used for both server and client sockets.

The variable sEvent can be one of the following values if iSocket is an accepted socket:
    sEvent =      Event Description:
    ACCEPTED      A client connection was accepted (see the "Listening sockets" section above for more details).
    CONNECTED     <Does not occur on accepted sockets>
    DISCONNECTED  The client disconnected (see AHKsock_Close for more details).
    SEND          You may now send data to the client (see AHKsock_Send for more details).
    RECEIVED      You received data from the client. The data received is in bData and the length is in bDataLength.
    SENDLAST      The client is disconnecting. This is your last chance to send data to it. Once this function returns,
                  disconnection will occur. This event only occurs on the side which did not initiate shutdown (see
                  AHKsock_Close for more details).

The variable sEvent can be one of the following values if iSocket is a connected socket:
    sEvent =      Event Description:
    ACCEPTED      <Does not occur on connected sockets>
    CONNECTED     The connection attempt initiated by calling AHKsock_Connect has completed (see AHKsock_Connect for more
                  details). If it was successful, iSocket will equal the client socket. If it failed, iSocket will equal -1.
                  To get the error code that the failure returned, set an error handling function with AHKsock_ErrorHandler,
                  and read ErrorLevel when iError is equal to 1.
    DISCONNECTED  The server disconnected (see AHKsock_Close for more details).
    SEND          You may now send data to the server (see AHKsock_Send for more details).
    RECEIVED      You received data from the server. The data received is in bData and the length is in bDataLength.
    SENDLAST      The server is disconnecting. This is your last chance to send data to it. Once this function returns,
                  disconnection will occur. This event only occurs on the side which did not initiate shutdown (see 
                  AHKsock_Close for more details).

More information: The event-handling functions described in here are always called with the Critical setting on. This is
necessary in order to ensure proper processing of messages. Note that as long as the event-handling function does not
return, AHKsock cannot process other network messages. Although messages are buffered, smooth operation might suffer when
letting the function run for longer than it should.

___________________________________________
NOTES ON CLOSING SOCKETS AND AHKsock_Close:

There are a few things to note about the AHKsock_Close function. The most important one is this: because the OnExit
subroutine cannot be made interruptible if running due to a call to Exit/ExitApp, AHKsock_Close will not be able to execute
a graceful shutdown if it is called from there. 

A graceful shutdown refers to the proper way of closing a TCP connection. It consists of an exchange of special TCP messages
between the two endpoints to acknowledge that the connection is about to close. It also fires the SENDLAST event in the
socket's associated function to notify that this is the last chance it will have to send data before disconnection. Note
that listening sockets cannot (and therefore do not need to) be gracefully shutdown as it is not an end-to-end connection.
(In practice, you will never have to manually call AHKsock_Close on a listening socket because you do not have access to
them. The socket is closed when you stop listening by calling AHKsock_Listen with no specified value for the second
parameter.)

In order to allow the socket(s) connection(s) to gracefully shutdown (which is always preferable), AHKsock_Close must be
called in a thread which is, or can be made, interruptible. If it is called with a specified socket in iSocket, it will
initiate a graceful shutdown for that socket alone. If it is called with no socket specified, it will initiate a graceful
shutdown for all connected/accepted sockets, and once done, deregister itself from the Windows Sockets implementation and
allow the implementation to free any resources allocated for Winsock (by calling WSACleanup). In that case, if any
subsequent AHKsock function is called, Winsock will automatically be restarted.

Therefore, before exiting your application, AHKsock_Close must be called at least once with no socket specified in order to
free Winsock resources. This can be done in the OnExit subroutine, either if you do not wish to perform a graceful shutdown
(which is not recommended), or if you have already gracefully shutdown all the sockets individually before calling
Exit/ExitApp. Of course, it doesn't have to be done in the OnExit subroutine and can be done anytime before (which is the
recommended method because AHKsock will automatically gracefully shutdown all the sockets on record).

This behaviour has a few repercussions on your application's design. If the only way for the user to terminate your
application is through AHK's default Exit menu item in the tray menu, then upon selecting the Exit menu item, the OnExit sub
will fire, and your application will not have a chance to gracefully shutdown connected sockets. One way around this is to
add your own menu item which will in turn call AHKsock_Close with no socket specified before calling ExitApp to enter the
OnExit sub. See AHKsock Example 1 for an example of this.

This is how the graceful shutdown process occurs between two connected peers:
    a> Once one of the peers (it may be the server of the client) is done sending all its data, it calls AHKsock_Close to
       shutdown the socket. (It is not a good idea to have the last peer receiving data call AHKsock_Close. This will result
       in AHKsock_Send errors on the other peer if more data needs to be sent.) In the next steps, we refer to the peer that
       first calls AHKsock_Close as the invoker, and the other peer simply as the peer.
    b> The peer receives the invoker's intention to close the connection and is given one last chance to send any remaining
       data. This is when the peer's socket's associated function receives the SENDLAST event.
    c> Once the peer is done sending any remaining data (if any), it also calls AHKsock_Close on that same socket to shut it
       down, and then close the socket for good. This happens once the peer's function that received the SENDLAST event
       returns from the event. At this point, the peer's socket's associated function receives the DISCONNECTED event.
    d> This happens in parallel with c>. After the invoker receives the peer's final data (if any), as well as notice that
       the peer has also called AHKsock_Close on the socket, the invoker finally also closes the socket for good. At this
       point, the socket's associated function also receives the DISCONNECTED event.

When AHKsock_Close is called with no socket specified, this process occurs (in parallel) for every connected socket on
record.

____________________________________
NOTES ON RECEIVING AND SENDING DATA:

It's important to understand that AHKsock uses the TCP protocol, which is a stream protocol. This means that the data
received comes as a stream, with no apparent boundaries (i.e. frames or packets). For example, if a peer sends you a string,
it's possible that half the string is received in one RECEIVED event and the other half is received in the next. Of course,
the smaller the string, the less likely this happens. Conversely, the larger the string, the more likely this will occur.

Similarly, calling AHKsock_Send will not necessarily send the data right away. If multiple AHKsock_Send calls are issued,
Winsock might, under certain conditions, wait and accumulate data to send before sending it all at once. This process is
called coalescing. For example, if you send two strings to your peer by using two individual AHKsock_Send calls, the peer
will not necessarily receive two consecutive RECEIVED events for each string, but might instead receive both strings through
a single RECEIVED event.

One efficient method of receiving data as frames is to use length-prefixing. Length-prefixing means that before sending a
frame of variable length to your peer, you first tell it how many bytes will be in the frame. This way, your peer can
divide the received data into frames that can be individually processed. If it received less than a frame, it can store the
received data and wait for the remaining data to arrive before processing the completed frame with the length specified.
This technique is used in in AHKsock Example 3, where peers send each other strings by first declaring how long the string
will be (see the StreamProcessor function of Example 3).

____________________________________
NOTES ON TESTING A STREAM PROCESSOR:

As you write applications that use length-prefixing as described above, you might find it hard to test their ability to
properly cut up and/or put together the data into frames when testing them on the same machine or on a LAN (because the
latency is too low and it is thus harder to stress the connection).

In this case, what you can do to properly test them is to uncomment the comment block in AHKsock_Send, which will sometimes
purposely fail to send part of the data requested. This will allow you to simulate what could happen on a connection going
through the Internet. You may change the probability of failure by changing the number in the If statement.

If your application can still work after uncommenting the block, then it is a sign that it is properly handling frames split
across multiple RECEIVED events. This would also demonstrate your application's ability to cope with partially sent data.
                    */

/****************\
 Main functions  |
                    */

                    AHKsock_Listen(sPort, sFunction = False) {

                        ;Check if there is already a socket listening on this port
                        If (sktListen := AHKsock_Sockets("GetSocketFromNamePort", A_Space, sPort)) {

                            ;Check if we're stopping the listening
                            If Not sFunction {
                                AHKsock_Close(sktListen) ;Close the socket

                                ;Check if we're retrieving the current function
                            } Else If (sFunction = "()") {
                                Return AHKsock_Sockets("GetFunction", sktListen)

                                ;Check if it's a different function
                            } Else If (sFunction <> AHKsock_Sockets("GetFunction", sktListen))
                            AHKsock_Sockets("SetFunction", sktListen, sFunction) ;Update it

                            Return ;We're done
                        }

                        ;Make sure we even have a function
                        If Not IsFunc(sFunction)
                            Return 2 ;sFunction is not a valid function.

                        ;Make sure Winsock has been started up
                        If (i := AHKsock_Startup())
                            Return (i = 1) ? 3 ;The WSAStartup() call failed. The error is in ErrorLevel.
                        : 4 ;The Winsock DLL does not support version 2.2.

                        ;Resolve the local address and port to be used by the server
                        VarSetCapacity(aiHints, 16 + 4 * A_PtrSize, 0)
                        NumPut(1, aiHints, 0, "Int") ;ai_flags = AI_PASSIVE
                        NumPut(2, aiHints, 4, "Int") ;ai_family = AF_INET
                        NumPut(1, aiHints, 8, "Int") ;ai_socktype = SOCK_STREAM
                        NumPut(6, aiHints, 12, "Int") ;ai_protocol = IPPROTO_TCP
                        iResult := DllCall("Ws2_32\GetAddrInfo", "Ptr", 0, "Ptr", &sPort, "Ptr", &aiHints, "Ptr*", aiResult)
                        If (iResult != 0) Or ErrorLevel { ;Check for error
                            ErrorLevel := ErrorLevel ? ErrorLevel : iResult
                            Return 5 ;The getaddrinfo() call failed. The error is in ErrorLevel.
                        }

                        sktListen := -1 ;INVALID_SOCKET
                        sktListen := DllCall("Ws2_32\socket", "Int", NumGet(aiResult+0, 04, "Int")
                        , "Int", NumGet(aiResult+0, 08, "Int")
                        , "Int", NumGet(aiResult+0, 12, "Int"), "Ptr")
                        If (sktListen = -1) Or ErrorLevel { ;Check for INVALID_SOCKET
                            sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                            DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
                            ErrorLevel := sErrorLevel
                            Return 6 ;The socket() call failed. The error is in ErrorLevel.
                        }

                        ;Setup the TCP listening socket
                        iResult := DllCall("Ws2_32\bind", "Ptr", sktListen, "Ptr", NumGet(aiResult+0, 16 + 2 * A_PtrSize), "Int", NumGet(aiResult+0, 16, "Ptr"))
                        If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
                            sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                            DllCall("Ws2_32\closesocket", "Ptr", sktListen)
                            DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
                            ErrorLevel := sErrorLevel
                            Return 7 ;The bind() call failed. The error is in ErrorLevel.
                        }

                        DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)

                        ;Add socket to array with A_Space for Name and IP to indicate that it's a listening socket
                        AHKsock_Sockets("Add", sktListen, A_Space, A_Space, sPort, sFunction)

                        ;We must now actually register the socket
                        If AHKsock_RegisterAsyncSelect(sktListen) {
                            sErrorLevel := ErrorLevel
                            DllCall("Ws2_32\closesocket", "Ptr", sktListen)
                            AHKsock_Sockets("Delete", sktListen) ;Remove from array
                            ErrorLevel := sErrorLevel
                            Return 8 ;The WSAAsyncSelect() call failed. The error is in ErrorLevel.
                        }

                        ;Start listening for incoming connections
                        iResult := DllCall("Ws2_32\listen", "Ptr", sktListen, "Int", 0x7FFFFFFF) ;SOMAXCONN
                        If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
                            sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                            DllCall("Ws2_32\closesocket", "Ptr", sktListen)
                            AHKsock_Sockets("Delete", sktListen) ;Remove from array
                            ErrorLevel := sErrorLevel
                            Return 9 ;The listen() call failed. The error is in ErrorLevel.
                        }
                    }

                    AHKsock_Connect(sName, sPort, sFunction) {
                        Static aiResult, iPointer, bProcessing, iMessage
                        Static sCurName, sCurPort, sCurFunction, sktConnect

                        ;Check if it's just to inquire whether or not a call is possible
                        If (Not sName And Not sPort And Not sFunction)
                            Return bProcessing

                        ;Check if we're busy
                        If bProcessing And (sFunction != iMessage) {
                            ErrorLevel := sCurName A_Tab sCurPort
                            Return 1 ;AHKsock_Connect is still processing a connection attempt. ErrorLevel contains the name and the port,
                            ;delimited by a tab.
                        } Else If bProcessing { ;sFunction = iMessage. The connect operation has finished.

                            ;Check if it was successful
                            If (i := sPort >> 16) {

                                ;Close the socket that failed
                                DllCall("Ws2_32\closesocket", "Ptr", sktConnect)

                                ;Get the next pointer. ai_next
                                iPointer := NumGet(iPointer+0, 16 + 3 * A_PtrSize)

                                ;Check if we reached the end of the linked structs
                                If (iPointer = 0) {

                                    ;We can now free the chain of addrinfo structs
                                    DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)

                                    ;This is to ensure that the user can call AHKsock_Connect() right away upon receiving the message.
                                    bProcessing := False

                                    ;Raise an error (can't use Return 1 because we were called asynchronously)
                                    ErrorLevel := i
                                    AHKsock_RaiseError(1) ;The connect() call failed. The error is in ErrorLevel.

                                    ;Call the function to signal that connection failed
                                    If IsFunc(sCurFunction)
                                        %sCurFunction%("CONNECTED", -1, sCurName, 0, sCurPort)

                                Return
                            }

                        } Else { ;Successful connection!

                            ;Get the IP we successfully connected to
                            sIP := DllCall("Ws2_32\inet_ntoa", "UInt", NumGet(NumGet(iPointer+0, 16 + 2 * A_PtrSize)+4, 0, "UInt"), "AStr")

                            ;We can now free the chain of ADDRINFO structs
                            DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)

                            ;Add socket to array
                            AHKsock_Sockets("Add", sktConnect, sCurName, sIP, sCurPort, sCurFunction)

                            ;This is to ensure that the user can call AHKsock_Connect() right away upon receiving the message.
                            bProcessing := False

                            ;Do this small bit in Critical so that AHKsock_AsyncSelect doesn't receive
                            ;any FD messages before we call the user function
                            Critical

                            ;We must now actually register the socket
                            If AHKsock_RegisterAsyncSelect(sktConnect) {
                                sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                                DllCall("Ws2_32\closesocket", "Ptr", sktConnect)
                                AHKsock_Sockets("Delete", sktConnect) ;Remove from array
                                ErrorLevel := sErrorLevel
                                AHKsock_RaiseError(2) ;The WSAAsyncSelect() call failed. The error is in ErrorLevel.

                                If IsFunc(sCurFunction) ;Call the function to signal that connection failed
                                    %sCurFunction%("CONNECTED", -1, sCurName, 0, sCurPort)

                            } Else If IsFunc(sCurFunction) ;Call the function to signal that connection was successful
                            %sCurFunction%("CONNECTED", sktConnect, sCurName, sIP, sCurPort)

                            Return
                        }

                    } Else { ;We were called

                        ;Make sure we even have a function
                        If Not IsFunc(sFunction)
                            Return 2 ;sFunction is not a valid function.

                        bProcessing := True ;Block future calls to AHKsock_Connect() until we're done

                        ;Keep the values
                        sCurName := sName
                        sCurPort := sPort
                        sCurFunction := sFunction

                        ;Make sure Winsock has been started up
                        If (i := AHKsock_Startup()) {
                            bProcessing := False
                            Return (i = 1) ? 3 ;The WSAStartup() call failed. The error is in ErrorLevel.
                            : 4 ;The Winsock DLL does not support version 2.2.
                        }

                        ;Resolve the server address and port    
                        VarSetCapacity(aiHints, 16 + 4 * A_PtrSize, 0)
                        NumPut(2, aiHints, 4, "Int") ;ai_family = AF_INET
                        NumPut(1, aiHints, 8, "Int") ;ai_socktype = SOCK_STREAM
                        NumPut(6, aiHints, 12, "Int") ;ai_protocol = IPPROTO_TCP
                        iResult := DllCall("Ws2_32\GetAddrInfo", "Ptr", &sName, "Ptr", &sPort, "Ptr", &aiHints, "Ptr*", aiResult)
                        If (iResult != 0) Or ErrorLevel { ;Check for error
                            ErrorLevel := ErrorLevel ? ErrorLevel : iResult
                            bProcessing := False
                            Return 5 ;The getaddrinfo() call failed. The error is in ErrorLevel.
                        }

                        ;Start with the first struct
                        iPointer := aiResult
                    }

                    ;Create a SOCKET for connecting to server
                    sktConnect := DllCall("Ws2_32\socket", "Int", NumGet(iPointer+0, 04, "Int")
                    , "Int", NumGet(iPointer+0, 08, "Int")
                    , "Int", NumGet(iPointer+0, 12, "Int"), "Ptr")
                    If (sktConnect = 0xFFFFFFFF) Or ErrorLevel { ;Check for INVALID_SOCKET
                        sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                        DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
                        bProcessing := False
                        ErrorLevel := sErrorLevel
                        If (sFunction = iMessage) { ;Check if we were called asynchronously
                            AHKsock_RaiseError(3) ;The socket() call failed. The error is in ErrorLevel.

                            ;Call the function to signal that connection failed
                            If IsFunc(sCurFunction)
                                %sCurFunction%("CONNECTED", -1)
                        }
                        Return 6 ;The socket() call failed. The error is in ErrorLevel.
                    }

                    ;Register the socket to know when the connect() function is done. FD_CONNECT = 16
                    iMessage := AHKsock_Settings("Message") + 1
                    If AHKsock_RegisterAsyncSelect(sktConnect, 16, "AHKsock_Connect", iMessage) {
                        sErrorLevel := ErrorLevel
                        DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
                        DllCall("Ws2_32\closesocket", "Ptr", sktConnect)
                        bProcessing := False
                        ErrorLevel := sErrorLevel
                        If (sFunction = iMessage) { ;Check if we were called asynchronously
                            AHKsock_RaiseError(4) ;The WSAAsyncSelect() call failed. The error is in ErrorLevel.

                            ;Call the function to signal that connection failed
                            If IsFunc(sCurFunction)
                                %sCurFunction%("CONNECTED", -1)
                        }
                        Return 7 ;The WSAAsyncSelect() call failed. The error is in ErrorLevel.
                    }

                    ;Connect to server (the connect() call also implicitly binds the socket to any host address and any port)
                    iResult := DllCall("Ws2_32\connect", "Ptr", sktConnect, "Ptr", NumGet(iPointer+0, 16 + 2 * A_PtrSize), "Int", NumGet(iPointer+0, 16))
                    If ErrorLevel Or ((iResult = -1) And (AHKsock_LastError() != 10035)) { ;Check for any error other than WSAEWOULDBLOCK
                        sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                        DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
                        DllCall("Ws2_32\closesocket", "Ptr", sktConnect)
                        bProcessing := False
                        ErrorLevel := sErrorLevel
                        If (sFunction = iMessage) { ;Check if we were called asynchronously
                            AHKsock_RaiseError(5) ;The connect() call failed. The error is in ErrorLevel.

                            ;Call the function to signal that connection failed
                            If IsFunc(sCurFunction)
                                %sCurFunction%("CONNECTED", -1)
                        }
                        Return 8 ;The connect() call failed. The error is in ErrorLevel.
                    }
                }

                AHKsock_Send(iSocket, ptrData = 0, iLength = 0) {

                    ;Make sure the socket is on record. Fail-safe
                    If Not AHKsock_Sockets("Index", iSocket)
                        Return -4 ;The socket specified in iSocket is not a recognized socket.

                    ;Make sure Winsock has been started up
                    If Not AHKsock_Startup(1)
                        Return -1 ;WSAStartup hasn't been called yet.

                    ;Make sure the socket is cleared for sending
                    If Not AHKsock_Sockets("GetSend", iSocket)
                        Return -5 ;The socket specified in iSocket is not cleared for sending.

    /*! Uncomment this block to simulate the possibility of an incomplete send()
    Random, iRand, 1, 100
    If (iRand <= 30) { ;Probability of failure of 30%
        Random, iRand, 1, iLength - 1 ;Randomize how much of the data will not be sent
        iLength -= iRand
    }
                    */

                    iSendResult := DllCall("Ws2_32\send", "Ptr", iSocket, "Ptr", ptrData, "Int", iLength, "Int", 0)
                    If (iSendResult = -1) And ((iErr := AHKsock_LastError()) = 10035) { ;Check specifically for WSAEWOULDBLOCK
                        AHKsock_Sockets("SetSend", iSocket, False) ;Update socket's send status
                        Return -2 ;Calling send() would have blocked the thread. Try again once you get the proper update.
                    } Else If (iSendResult = -1) Or ErrorLevel {
                        ErrorLevel := ErrorLevel ? ErrorLevel : iErr
                        Return -3 ;The send() call failed. The error is in ErrorLevel.
                    } Else Return iSendResult ;The send() operation was successful
                }

                AHKsock_ForceSend(iSocket, ptrData, iLength) {

                    ;Make sure Winsock has been started up
                    If Not AHKsock_Startup(1)
                        Return -1 ;WSAStartup hasn't been called yet

                    ;Make sure the socket is on record. Fail-safe
                    If Not AHKsock_Sockets("Index", iSocket)
                        Return -4

                    ;Make sure that we're not in Critical, or we won't be able to wait for FD_WRITE messages
                    If A_IsCritical
                        Return -5

                    ;Extra precaution to make sure FD_WRITE messages can make it
                    Thread, Priority, 0

                    ;We need to make sure not to fill up the send buffer in one call, or we'll get a performance hit.
                    ;http://support.microsoft.com/kb/823764

                    ;Get the socket's send buffer size
                    If ((iMaxChunk := AHKsock_SockOpt(iSocket, "SO_SNDBUF")) = -1)
                        Return -6

                    ;Check if we'll be sending in chunks or not
                    If (iMaxChunk <= 1) {

                        ;We'll be sending as much as possible everytime!

                        Loop { ;Keep sending the data until we're done or until an error occurs

                            ;Wait until we can send data (ie. when FD_WRITE arrives)
                            While Not AHKsock_Sockets("GetSend", iSocket)
                                Sleep -1

                            Loop { ;Keep sending the data until we get WSAEWOULDBLOCK or until an error occurs
                                If ((iSendResult := AHKsock_Send(iSocket, ptrData, iLength)) < 0) {
                                    If (iSendResult = -2) ;Check specifically for WSAEWOULDBLOCK
                                        Break ;Calling send() would have blocked the thread. Break the loop and we'll try again after we
                                    ;receive FD_WRITE
                                Else Return iSendResult ;Something bad happened with AHKsock_Send. Return the same value we got.
                            } Else {

                                ;AHKsock_Send was able to send bytes. Let's check if it sent only part of what we requested
                                If (iSendResult < iLength) ;Move the offset up by what we were able to send
                                    ptrData += iSendResult, iLength -= iSendResult
                                Else Return ;We're done sending all the data
                                }
                        }
                    }
                } Else {

                    ;We'll be sending in chunks of just under the send buffer size to avoid the performance hit

                    iMaxChunk -= 1 ;Reduce by 1 to be smaller than the send buffer
                    Loop { ;Keep sending the data until we're done or until an error occurs

                        ;Wait until we can send data (ie. when FD_WRITE arrives)
                        While Not AHKsock_Sockets("GetSend", iSocket)
                            Sleep -1

                        ;Check if we have less than the max chunk to send
                        If (iLength < iMaxChunk) {

                            Loop { ;Keep sending the data until we get WSAEWOULDBLOCK or until an error occurs
                                ;Send using the traditional offset method
                                If ((iSendResult := AHKsock_Send(iSocket, ptrData, iLength)) < 0) {
                                    If (iSendResult = -2) ;Check specifically for WSAEWOULDBLOCK
                                        Break ;Calling send() would have blocked the thread. Break the loop and we'll try again after we
                                    ;receive FD_WRITE
                                Else Return iSendResult ;Something bad happened with AHKsock_Send. Return the same value we got.
                            } Else {

                                ;AHKsock_Send was able to send bytes. Let's check if it sent only part of what we requested
                                If (iSendResult < iLength) ;Move the offset up by what we were able to send
                                    ptrData += iSendResult, iLength -= iSendResult
                                Else Return ;We're done sending all the data
                                }
                        }
                    } Else {

                        ;Send up to max chunk
                        If ((iSendResult := AHKsock_Send(iSocket, ptrData, iMaxChunk)) < 0) {
                            If (iSendResult = -2) ;Check specifically for WSAEWOULDBLOCK
                                Continue ;Calling send() would have blocked the thread. Continue the loop and we'll try again after
                            ;we receive FD_WRITE
                            Else Return iSendResult ;Something bad happened with AHKsock_Send. Return the same value we got.
                            } Else ptrData += iSendResult, iLength -= iSendResult ;Move up offset by updating the pointer and length
                    }
                }
            }
        }

        AHKsock_Close(iSocket = -1, iTimeout = 5000) {

            ;Make sure Winsock has been started up
            If Not AHKsock_Startup(1)
                Return ;There's nothing to close

            If (iSocket = -1) { ;We need to close all the sockets

                ;Check if we even have sockets to close
                If Not AHKsock_Sockets() {
                    DllCall("Ws2_32\WSACleanup")
                    AHKsock_Startup(2) ;Reset the value to show that we've turned off Winsock
                    Return ;We're done!
                }

                ;Take the current time (needed for time-outing)
                iStartClose := A_TickCount

                Loop % AHKsock_Sockets() ;Close all sockets and cleanup
                    AHKsock_ShutdownSocket(AHKsock_Sockets("GetSocketFromIndex", A_Index))

                ;Check if we're in the OnExit subroutine
                If Not A_ExitReason {

                    A_IsCriticalOld := A_IsCritical

                    ;Make sure we can still receive FD_CLOSE msgs
                    Critical, Off
                    Thread, Priority, 0

                    ;We can try a graceful shutdown or wait for a timeout
                    While (AHKsock_Sockets()) And (A_TickCount - iStartClose < iTimeout)
                        Sleep, -1

                    ;Restore previous Critical
                    Critical, %A_IsCriticalOld%
                }

        /*! Used for debugging purposes only
        If (i := AHKsock_Sockets()) {
            If (i = 1)
                OutputDebug, % "Cleaning up now, with the socket " AHKsock_Sockets("GetSocketFromIndex", 1) " remaining..."
            Else {
                OutputDebug, % "Cleaning up now, with the following sockets remaining:"
                Loop % AHKsock_Sockets() {
                    OutputDebug, % AHKsock_Sockets("GetSocketFromIndex", A_Index)
                }
            }
        }
                */

                DllCall("Ws2_32\WSACleanup")
                AHKsock_Startup(2) ;Reset the value to show that we've turned off Winsock

                ;Close only one socket
            } Else If AHKsock_ShutdownSocket(iSocket) ;Error-checking
            Return 1 ;The shutdown() call failed. The error is in ErrorLevel.
        }

        AHKsock_GetAddrInfo(sHostName, ByRef sIPList, bOne = False) {

            ;Make sure Winsock has been started up
            If (i := AHKsock_Startup())
                Return i ;Return the same error (error 1 and 2)

            ;Resolve the address and port    
            VarSetCapacity(aiHints, 16 + 4 * A_PtrSize, 0)
            NumPut(2, aiHints, 4, "Int") ;ai_family = AF_INET
            NumPut(1, aiHints, 8, "Int") ;ai_socktype = SOCK_STREAM
            NumPut(6, aiHints, 12, "Int") ;ai_protocol = IPPROTO_TCP
            iResult := DllCall("Ws2_32\GetAddrInfo", "Ptr", &sHostName, "Ptr", 0, "Ptr", &aiHints, "Ptr*", aiResult)
            If (iResult = 11001) ;Check specifically for WSAHOST_NOT_FOUND since it's the most common error
                Return 3 ;Received WSAHOST_NOT_FOUND. No such host is known.
            Else If (iResult != 0) Or ErrorLevel { ;Check for any other error
                ErrorLevel := ErrorLevel ? ErrorLevel : iResult
                Return 4 ;The getaddrinfo() call failed. The error is in ErrorLevel.
            }

            If bOne
                sIPList := DllCall("Ws2_32\inet_ntoa", "UInt", NumGet(NumGet(aiResult+0, 16 + 2 * A_PtrSize)+4, 0, "UInt"), "AStr")
            Else {

                ;Start with the first addrinfo struct
                iPointer := aiResult, sIPList := ""
                While iPointer {
                    s := DllCall("Ws2_32\inet_ntoa", "UInt", NumGet(NumGet(iPointer+0, 16 + 2 * A_PtrSize)+4, 0, "UInt"), "AStr")
                    iPointer := NumGet(iPointer+0, 16 + 3 * A_PtrSize) ;Go to the next addrinfo struct
                    sIPList .= s (iPointer ? "`n" : "") ;Add newline only if it's not the last one
                }
            }

            ;We're done
            DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
        }

        AHKsock_GetNameInfo(sIP, ByRef sHostName, sPort = 0, ByRef sService = "") {

            ;Make sure Winsock has been started up
            If (i := AHKsock_Startup())
                Return i ;Return the same error (error 1 and 2)

            ;Translate to IN_ADDR
            iIP := DllCall("Ws2_32\inet_addr", "AStr", sIP, "UInt")
            If (iIP = 0 Or iIP = 0xFFFFFFFF) ;Check for INADDR_NONE or INADDR_ANY
                Return 3 ;The IP address supplied in sIP is invalid.

            ;Construct a sockaddr struct
            VarSetCapacity(tSockAddr, 16, 0)
            NumPut(2, tSockAddr, 0, "Short") ;ai_family = AF_INET
            NumPut(iIP, tSockAddr, 4, "UInt") ;Put in the IN_ADDR

            ;Fill in the port field if we're also looking up the service name
            If sPort ;Translate to network byte order
                NumPut(DllCall("Ws2_32\htons", "UShort", sPort, "UShort"), tSockAddr, 2, "UShort")

            ;Prep vars
            VarSetCapacity(sHostName, 1025 * 2, 0) ;NI_MAXHOST
            If sPort
                VarSetCapacity(sService, 32 * 2, 0) ;NI_MAXSERV

            iResult := DllCall("Ws2_32\GetNameInfoW", "Ptr", &tSockAddr, "Int", 16, "Str", sHostName, "UInt", 1025 * 2
            , sPort ? "Str" : "UInt", sPort ? sService : 0, "UInt", 32 * 2, "Int", 0)
            If (iResult != 0) Or ErrorLevel {
                ErrorLevel := ErrorLevel ? ErrorLevel : DllCall("Ws2_32\WSAGetLastError")
                Return 4 ;The getnameinfo() call failed. The error is in ErrorLevel.
            }
        }

        AHKsock_SockOpt(iSocket, sOption, iValue = -1) {

            ;Prep variable
            VarSetCapacity(iOptVal, iOptValLength := 4, 0)
            If (iValue <> -1)
                NumPut(iValue, iOptVal, 0, "UInt")

            If (sOption = "SO_KEEPALIVE") {
                intLevel := 0xFFFF ;SOL_SOCKET
                intOptName := 0x0008 ;SO_KEEPALIVE
            } Else If (sOption = "SO_SNDBUF") {
                intLevel := 0xFFFF ;SOL_SOCKET
                intOptName := 0x1001 ;SO_SNDBUF
            } Else If (sOption = "SO_RCVBUF") {
                intLevel := 0xFFFF ;SOL_SOCKET
                intOptName := 0x1002 ;SO_SNDBUF
            } Else If (sOption = "TCP_NODELAY") {
                intLevel := 6 ;IPPROTO_TCP
                intOptName := 0x0001 ;TCP_NODELAY
            }

            ;Check if we're getting or setting
            If (iValue = -1) {
                iResult := DllCall("Ws2_32\getsockopt", "Ptr", iSocket, "Int", intLevel, "Int", intOptName
                , "UInt*", iOptVal, "Int*", iOptValLength)
                If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
                    ErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                    Return -1
                } Else Return iOptVal
            } Else {
                iResult := DllCall("Ws2_32\setsockopt", "Ptr", iSocket, "Int", intLevel, "Int", intOptName
                , "Ptr", &iOptVal, "Int", iOptValLength)
                If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
                    ErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                    Return -2
                }
            }
        }

/*******************\
 Support functions  |
        */

        AHKsock_Startup(iMode = 0) {
            Static bAlreadyStarted

    /*
    iMode = 0 ;Turns on WSAStartup()
    iMode = 1 ;Returns whether or not WSAStartup has been called
    iMode = 2 ;Resets the static variable to force another call next time iMode = 0
            */

            If (iMode = 2)
                bAlreadyStarted := False
            Else If (iMode = 1)
                Return bAlreadyStarted
            Else If Not bAlreadyStarted { ;iMode = 0. Call the function only if it hasn't already been called.

                ;Start it up - request version 2.2
                VarSetCapacity(wsaData, A_PtrSize = 4 ? 400 : 408, 0)
                iResult := DllCall("Ws2_32\WSAStartup", "UShort", 0x0202, "Ptr", &wsaData)
                If (iResult != 0) Or ErrorLevel {
                    ErrorLevel := ErrorLevel ? ErrorLevel : iResult
                    Return 1
                }

                ;Make sure the Winsock DLL supports at least version 2.2
                If (NumGet(wsaData, 2, "UShort") < 0x0202) {
                    DllCall("Ws2_32\WSACleanup") ;Abort
                    ErrorLevel := "The Winsock DLL does not support version 2.2."
                    Return 2
                }

                bAlreadyStarted := True
            }
        }

        AHKsock_ShutdownSocket(iSocket) {

            ;Check if it's a listening socket
            sName := AHKsock_Sockets("GetName", iSocket)
            If (sName != A_Space) { ;It's not a listening socket. Shutdown send operations.
                iResult := DllCall("Ws2_32\shutdown", "Ptr", iSocket, "Int", 1) ;SD_SEND
                If (iResult = -1) Or ErrorLevel {
                    sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                    DllCall("Ws2_32\closesocket", "Ptr", iSocket)
                    AHKsock_Sockets("Delete", iSocket)
                    ErrorLevel := sErrorLevel
                    Return 1
                }

                ;Mark it
                AHKsock_Sockets("SetShutdown", iSocket)

            } Else {
                DllCall("Ws2_32\closesocket", "Ptr", iSocket) ;It's only a listening socket
                AHKsock_Sockets("Delete", iSocket) ;Remove it from the array
            }
        }

/***********************\
 AsyncSelect functions  |
        */
        ;FD_READ | FD_WRITE | FD_ACCEPT | FD_CLOSE
        AHKsock_RegisterAsyncSelect(iSocket, fFlags = 43, sFunction = "AHKsock_AsyncSelect", iMsg = 0) {
            Static hwnd := False

            If Not hwnd { ;Use the main AHK window
                A_DetectHiddenWindowsOld := A_DetectHiddenWindows
                DetectHiddenWindows, On
                WinGet, hwnd, ID, % "ahk_pid " DllCall("GetCurrentProcessId") " ahk_class AutoHotkey"
                DetectHiddenWindows, %A_DetectHiddenWindowsOld%
            }

            iMsg := iMsg ? iMsg : AHKsock_Settings("Message")
            If (OnMessage(iMsg) <> sFunction)
                OnMessage(iMsg, sFunction)

            iResult := DllCall("Ws2_32\WSAAsyncSelect", "Ptr", iSocket, "Ptr", hwnd, "UInt", iMsg, "Int", fFlags)
            If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
                ErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                Return 1
            }
        }

        AHKsock_AsyncSelect(wParam, lParam) {
            Critical ;So that messages are buffered

            ;wParam parameter identifies the socket on which a network event has occurred
            ;The low word of lParam specifies the network event that has occurred.
            ;The high word of lParam contains any error code

            ;Make sure the socket is on record. Fail-safe
            If Not AHKsock_Sockets("Index", wParam)
                Return

            iEvent := lParam & 0xFFFF, iErrorCode := lParam >> 16

    /*! Used for debugging purposes
    OutputDebug, % "AsyncSelect - A network event " iEvent " has occurred on socket " wParam
    If iErrorCode
        OutputDebug, % "AsyncSelect - Error code = " iErrorCode
            */

            If (iEvent = 1) { ;FD_READ

                ;Check for error
                If iErrorCode { ;WSAENETDOWN is the only possible
                    ErrorLevel := iErrorCode
                    ;FD_READ event received with an error. The error is in ErrorLevel. The socket is in iSocket.
                    AHKsock_RaiseError(6, wParam)
                    Return
                }

                VarSetCapacity(bufReceived, bufReceivedLength := AHKsock_Settings("Buffer"), 0)
                iResult := DllCall("Ws2_32\recv", "UInt", wParam, "Ptr", &bufReceived, "Int", bufReceivedLength, "Int", 0)
                If (iResult > 0) { ;We received data!
                    VarSetCapacity(bufReceived, -1) ;Update the internal length

                    ;Get associated function and call it
                    If IsFunc(sFunc := AHKsock_Sockets("GetFunction", wParam))
                        %sFunc%("RECEIVED", wParam, AHKsock_Sockets("GetName", wParam)
                    , AHKsock_Sockets("GetAddr", wParam)
                    , AHKsock_Sockets("GetPort", wParam), bufReceived, iResult)

                    ;Check for error other than WSAEWOULDBLOCK
                } Else If ErrorLevel Or ((iResult = -1) And Not ((iErrorCode := AHKsock_LastError()) = 10035)) {
                    ErrorLevel := ErrorLevel ? ErrorLevel : iErrorCode
                    AHKsock_RaiseError(7, wParam) ;The recv() call failed. The error is in ErrorLevel. The socket is in iSocket.
                    iResult = -1 ;So that if it's a spoofed call from FD_CLOSE, we exit the loop and close the socket
                }

                ;Here, we bother with returning a value in case it's a spoofed call from FD_CLOSE
                Return iResult

            } Else If (iEvent = 2) { ;FD_WRITE

                ;Check for error
                If iErrorCode { ;WSAENETDOWN is the only possible
                    ErrorLevel := iErrorCode
                    ;FD_WRITE event received with an error. The error is in ErrorLevel. The socket is in iSocket.
                    AHKsock_RaiseError(8, wParam)
                    Return
                }

                ;Update socket's setting
                AHKsock_Sockets("SetSend", wParam, True)

                ;Make sure the socket isn't already shut down
                If Not AHKsock_Sockets("GetShutdown", wParam)
                    If IsFunc(sFunc := AHKsock_Sockets("GetFunction", wParam))
                    %sFunc%("SEND", wParam, AHKsock_Sockets("GetName", wParam)
                , AHKsock_Sockets("GetAddr", wParam)
                , AHKsock_Sockets("GetPort", wParam))

            } Else If (iEvent = 8) { ;FD_ACCEPT

                ;Check for error
                If iErrorCode { ;WSAENETDOWN is the only possible
                    ErrorLevel := iErrorCode
                    ;FD_ACCEPT event received with an error. The error is in ErrorLevel. The socket is in iSocket.
                    AHKsock_RaiseError(9, wParam)
                    Return
                }

                ;We need to accept the connection
                VarSetCapacity(tSockAddr, tSockAddrLength := 16, 0)
                sktClient := DllCall("Ws2_32\accept", "Ptr", wParam, "Ptr", &tSockAddr, "Int*", tSockAddrLength)
                If (sktClient = -1) And ((iErrorCode := AHKsock_LastError()) = 10035) ;Check specifically for WSAEWOULDBLOCK
                    Return ;We'll be called again next time we can retry accept()
                Else If (sktClient = -1) Or ErrorLevel { ;Check for INVALID_SOCKET
                    ErrorLevel := ErrorLevel ? ErrorLevel : iErrorCode
                    ;The accept() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
                    AHKsock_RaiseError(10, wParam)
                    Return
                }

                ;Add to array
                sName := ""
                sAddr := DllCall("Ws2_32\inet_ntoa", "UInt", NumGet(tSockAddr, 4, "UInt"), "AStr")
                sPort := AHKsock_Sockets("GetPort", wParam)
                sFunc := AHKsock_Sockets("GetFunction", wParam)
                AHKsock_Sockets("Add", sktClient, sName, sAddr, sPort, sFunc)

                ;Go back to listening
                iResult := DllCall("Ws2_32\listen", "Ptr", wParam, "Int", 0x7FFFFFFF) ;SOMAXCONN       
                If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
                    sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                    DllCall("Ws2_32\closesocket", "Ptr", wParam)
                    AHKsock_Sockets("Delete", wParam) ;Remove from array
                    ErrorLevel := sErrorLevel
                    ;The listen() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
                    AHKsock_RaiseError(12, wParam)
                    Return
                }

                ;Get associated function and call it
                If IsFunc(sFunc)
                    %sFunc%("ACCEPTED", sktClient, sName, sAddr, sPort)

            } Else If (iEvent = 32) { ;FD_CLOSE

                ;Keep receiving data before closing the socket by spoofing an FD_READ event to call recv()
                While (AHKsock_AsyncSelect(wParam, 1) > 0)
                    Sleep, -1

                ;Check if we initiated it
                If Not AHKsock_Sockets("GetShutdown", wParam) {

                    ;Last chance to send data. Get associated function and call it.
                    If IsFunc(sFunc := AHKsock_Sockets("GetFunction", wParam))
                        %sFunc%("SENDLAST", wParam, AHKsock_Sockets("GetName", wParam)
                    , AHKsock_Sockets("GetAddr", wParam)
                    , AHKsock_Sockets("GetPort", wParam))

                    ;Shutdown the socket. This is to attempt a graceful shutdown
                    If AHKsock_ShutdownSocket(wParam) {
                        ;The shutdown() call failed. The error is in ErrorLevel. The socket is in iSocket.
                        AHKsock_RaiseError(13, wParam)
                        Return
                    }
                }

                ;We just have to close the socket then
                DllCall("Ws2_32\closesocket", "Ptr", wParam)

                ;Get associated data before deleting
                sFunc := AHKsock_Sockets("GetFunction", wParam)
                sName := AHKsock_Sockets("GetName", wParam)
                sAddr := AHKsock_Sockets("GetAddr", wParam)
                sPort := AHKsock_Sockets("GetPort", wParam)

                ;We can remove it from the array
                AHKsock_Sockets("Delete", wParam)

                If IsFunc(sFunc)
                    %sFunc%("DISCONNECTED", wParam, sName, sAddr, sPort)
            }
        }

/******************\
 Array controller  |
        */

        AHKsock_Sockets(sAction = "Count", iSocket = "", sName = "", sAddr = "", sPort = "", sFunction = "") {
            Static
            Static aSockets0 := 0
            Static iLastSocket := 0xFFFFFFFF ;Cache to lessen index lookups on the same socket
            Local i, ret, A_IsCriticalOld

            A_IsCriticalOld := A_IsCritical
            Critical

            If (sAction = "Count") {
                ret := aSockets0

            } Else If (sAction = "Add") {
                aSockets0 += 1 ;Expand array
                aSockets%aSockets0%_Sock := iSocket
                aSockets%aSockets0%_Name := sName
                aSockets%aSockets0%_Addr := sAddr
                aSockets%aSockets0%_Port := sPort
                aSockets%aSockets0%_Func := sFunction
                aSockets%aSockets0%_Shutdown := False
                aSockets%aSockets0%_Send := False

            } Else If (sAction = "Delete") {

                ;First we need the index
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)

                If i {
                    iLastSocket := 0xFFFF ;Clear cache
                    If (i < aSockets0) { ;Let the last item overwrite this one
                        aSockets%i%_Sock := aSockets%aSockets0%_Sock
                        aSockets%i%_Name := aSockets%aSockets0%_Name
                        aSockets%i%_Addr := aSockets%aSockets0%_Addr
                        aSockets%i%_Port := aSockets%aSockets0%_Port
                        aSockets%i%_Func := aSockets%aSockets0%_Func
                        aSockets%i%_Shutdown := aSockets%aSockets0%_Shutdown
                        aSockets%i%_Send := aSockets%aSockets0%_Send

                    }
                    aSockets0 -= 1 ;Remove element
                }

            } Else If (sAction = "GetName") {
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)
                ret := aSockets%i%_Name

            } Else If (sAction = "GetAddr") {
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)
                ret := aSockets%i%_Addr

            } Else If (sAction = "GetPort") {
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)
                ret := aSockets%i%_Port

            } Else If (sAction = "GetFunction") {
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)
                ret := aSockets%i%_Func

            } Else If (sAction = "SetFunction") {
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)
                aSockets%i%_Func := sName

            } Else If (sAction = "GetSend") {
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)
                ret := aSockets%i%_Send

            } Else If (sAction = "SetSend") {
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)
                aSockets%i%_Send := sName

            } Else If (sAction = "GetShutdown") {
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)
                ret := aSockets%i%_Shutdown

            } Else If (sAction = "SetShutdown") {
                i := (iSocket = iLastSocket) ;Check cache
                ? iLastSocketIndex
                : AHKsock_Sockets("Index", iSocket)
                aSockets%i%_Shutdown := True

            } Else If (sAction = "GetSocketFromNamePort") {
                Loop % aSockets0 {
                    If (aSockets%A_Index%_Name = iSocket)
                    And (aSockets%A_Index%_Port = sName) {
                        ret := aSockets%A_Index%_Sock
                        Break
                    }
                }

            } Else If (sAction = "GetSocketFromIndex") {
                ret := aSockets%iSocket%_Sock

            } Else If (sAction = "Index") {
                Loop % aSockets0 {
                    If (aSockets%A_Index%_Sock = iSocket) {
                        iLastSocketIndex := A_Index, iLastSocket := iSocket
                        ret := A_Index
                        Break
                    }
                }
            }

            ;Restore old Critical setting
            Critical %A_IsCriticalOld%
            Return ret
        }

/*****************\
 Error Functions  |
        */

        AHKsock_LastError() {
            Return DllCall("Ws2_32\WSAGetLastError")
        }

        AHKsock_ErrorHandler(sFunction = """") {
            Static sCurrentFunction
            If (sFunction = """")
                Return sCurrentFunction
            Else sCurrentFunction := sFunction
            }

        AHKsock_RaiseError(iError, iSocket = -1) {
            If IsFunc(sFunc := AHKsock_ErrorHandler())
                %sFunc%(iError, iSocket)
        }

/*******************\
 Settings Function  |
        */

        AHKsock_Settings(sSetting, sValue = "") {
            Static iMessage := 0x8000
            Static iBuffer := 65536

            If (sSetting = "Message") {
                If Not sValue
                    Return iMessage
                Else iMessage := (sValue = "Reset") ? 0x8000 : sValue
            } Else If (sSetting = "Buffer") {
                If Not sValue
                    Return iBuffer
                Else iBuffer := (sValue = "Reset") ? 65536 : sValue
                }
        }

        ; Update Connect button text with current address and port
        UpdateConnectButton:
            Gui, Submit, NoHide
            GuiControlGet, btnText,, btnConnect
            ; Only update if currently showing "Connect" (not "Disconnect")
            If (InStr(btnText, "Connect")) {
                GuiControl,, btnConnect, Connect (%srvAddress%:%srvPort%)
            }
        Return

        btnConnect:
            GuiControlGet, btnText,, btnConnect

            If (InStr(btnText, "Disconnect")) {
                ; Disconnect and stop auto-reconnect
                SetTimer, AttemptReconnect, Off
                If (ClientSocket != -1) {
                    AHKsock_Close(ClientSocket)
                }
                Connected := False
                ClientSocket := -1
                GuiControlGet, srvAddress,, srvAddress
                GuiControlGet, srvPort,, srvPort
                GuiControl,, btnConnect, Connect (%srvAddress%:%srvPort%)
                GuiControl,, lblStatus, Status: Not Connected
                GuiControl, Enable, btnConnect
                AddClientLog("Disconnected from server")

            } Else {
                ; Connect to server
                ; Check if already connected - prevent multiple connections
                If (Connected && ClientSocket != -1) {
                    MsgBox, 0x10, Already Connected, You are already connected. Please disconnect first.
                    Return
                }

                GuiControlGet, srvAddress,, srvAddress
                GuiControlGet, srvPort,, srvPort
                GuiControlGet, AutoReconnect,, chkAutoReconnect

                ; Validate port
                If (srvPort = "" || srvPort < 1 || srvPort > 65535) {
                    MsgBox, 0x10, Invalid Port, Please enter a valid port number (1-65535)
                    Return
                }

                ; Save server address and port for auto-reconnect
                LastServerAddress := srvAddress
                LastServerPort := srvPort

                ; Connect to server
                If (i := AHKsock_Connect(srvAddress, srvPort, "ClientEvents")) {
                    AddClientLog("ERROR: AHKsock_Connect() failed with return value = " i " and ErrorLevel = " ErrorLevel)
                    MsgBox, 0x10, Connection Error, Could not connect to server at: %srvAddress%:%srvPort%
                    Return
                }

                AddClientLog("Connecting to " srvAddress ":" srvPort "...")
                GuiControl, Disable, btnConnect
            }
        Return

        ClientEvents(sEvent, iSocket = 0, sName = 0, sAddr = 0, sPort = 0, ByRef bData = 0, iLength = 0) {
            Global Connected, ClientSocket
            Static buffer := ""

            If (sEvent = "CONNECTED") {
                ; Check if connection was successful
                If (iSocket = -1) {
                    AddClientLog("ERROR: Connection failed")
                    GuiControl, Enable, btnConnect
                    MsgBox, 0x10, Connection Error, Could not connect to the server.
                    Return
                }

                ; Successfully connected
                Connected := True
                ClientSocket := iSocket
                buffer := "" ; Clear buffer on new connection
                GuiControl,, btnConnect, Disconnect
                GuiControl,, lblStatus, Status: Connected to %sName%:%sPort%
                GuiControl, Enable, btnConnect
                AddClientLog("Connected successfully to " sName ":" sPort)

            } Else If (sEvent = "DISCONNECTED") {
                ; Disconnected from server
                Connected := False
                ClientSocket := -1
                buffer := "" ; Clear buffer on disconnect
                GuiControl,, btnConnect, Connect (%LastServerAddress%:%LastServerPort%)
                GuiControl,, lblStatus, Status: Disconnected
                GuiControl, Enable, btnConnect
                AddClientLog("Disconnected from server")

                ; Start auto-reconnect timer if enabled
                GuiControlGet, AutoReconnect,, chkAutoReconnect
                If (AutoReconnect) {
                    AddClientLog("Auto-reconnect enabled - will retry in 15 seconds")
                    SetTimer, AttemptReconnect, 15000
                }

            } Else If (sEvent = "RECEIVED") {
                ; Received data from server - append to buffer
                receivedData := StrGet(&bData, iLength, "CP0")
                AddLog("[DEBUG] RECEIVED event: iLength=" iLength ", receivedData='" receivedData "'")
                buffer .= receivedData
                AddLog("[DEBUG] Buffer now: '" buffer "'")

                ; Process all complete commands (ending with newline)
                While (InStr(buffer, "`n")) {
                    pos := InStr(buffer, "`n")
                    command := SubStr(buffer, 1, pos - 1)
                    buffer := SubStr(buffer, pos + 1)

                    AddLog("[DEBUG] Extracted command: '" command "'")

                    If (command != "") {
                        AddLog("Received command: " command)
                        ProcessCommand(command)
                    } Else {
                        AddLog("[DEBUG] Empty command, skipping")
                    }
                }
            }
        }

        ProcessCommand(command) {
            AddLog("[DEBUG] ProcessCommand called with: '" command "' (length: " StrLen(command) ")")

            ; Handle SELECTIVE command for targeting specific clients
            ; Format: SELECTIVE:2,3,5|ACTUALCOMMAND
            If (SubStr(command, 1, 10) = "SELECTIVE:") {
                rest := SubStr(command, 11)
                delimPos := InStr(rest, "|")

                If (delimPos > 0) {
                    targetList := SubStr(rest, 1, delimPos - 1) ; e.g., "2,3,5"
                    actualCommand := SubStr(rest, delimPos + 1) ; The actual command to execute

                    AddLog("[SELECTIVE] Received selective command for clients: " targetList " | Command: " actualCommand)

                    ; Determine which window this client is (win1, win2, etc.)
                    ; Extract from script path: e.g., "E:\Rappelz_Gambit\Launcher\win2\..."
                    scriptPath := A_ScriptDir
                    If (InStr(scriptPath, "\win1\") || RegExMatch(scriptPath, "\\win1$")) {
                        myWinNum := 1
                    } Else If (InStr(scriptPath, "\win2\") || RegExMatch(scriptPath, "\\win2$")) {
                        myWinNum := 2
                    } Else If (InStr(scriptPath, "\win3\") || RegExMatch(scriptPath, "\\win3$")) {
                        myWinNum := 3
                    } Else If (InStr(scriptPath, "\win4\") || RegExMatch(scriptPath, "\\win4$")) {
                        myWinNum := 4
                    } Else If (InStr(scriptPath, "\win5\") || RegExMatch(scriptPath, "\\win5$")) {
                        myWinNum := 5
                    } Else If (InStr(scriptPath, "\win6\") || RegExMatch(scriptPath, "\\win6$")) {
                        myWinNum := 6
                    } Else If (InStr(scriptPath, "\win7\") || RegExMatch(scriptPath, "\\win7$")) {
                        myWinNum := 7
                    } Else If (InStr(scriptPath, "\win8\") || RegExMatch(scriptPath, "\\win8$")) {
                        myWinNum := 8
                    } Else {
                        myWinNum := 0
                    }

                    AddLog("[SELECTIVE] I am Win" . myWinNum . ", checking if I'm in target list: " targetList)

                    ; Check if this client is in the target list
                    targets := StrSplit(targetList, ",")
                    isTargeted := false
                    For _, winNum in targets {
                        If (winNum = myWinNum) {
                            isTargeted := true
                            break
                        }
                    }

                    If (isTargeted) {
                        AddLog("[SELECTIVE] I am targeted! Executing command: " actualCommand)
                        ; Recursively call ProcessCommand with the actual command
                        ProcessCommand(actualCommand)
                    } Else {
                        AddLog("[SELECTIVE] Not targeted for this command, ignoring")
                    }
                    Return
                }
            }

            ; Parse and execute commands
            If (SubStr(command, 1, 6) = "PRESS:") {
                global TargetGameWindow
                key := SubStr(command, 7)
                AddLog("Pressing key: " key " to game window")

                ; Use ControlSend to send to the game window
                If (TargetGameWindow != "") {
                    ControlSend,, {%key%}, ahk_id %TargetGameWindow%
                } Else {
                    ; Fallback to regular Send if no target window
                    Send, {%key%}
                }

            } Else If (SubStr(command, 1, 9) = "CTRLSEND:") {
                ; Format: CTRLSEND:windowtitle:|:key
                rest := SubStr(command, 10)
                delimPos := InStr(rest, ":|:")

                If (delimPos > 0) {
                    winTitle := SubStr(rest, 1, delimPos - 1)
                    key := SubStr(rest, delimPos + 3)

                    AddLog("ControlSend '" key "' to window '" winTitle "'")

                    ; Try to find window with partial title match
                    SetTitleMatchMode, 2 ; Window title can contain the specified string anywhere

                    ; Check if window exists
                    IfWinExist, %winTitle%
                    {
                        ; Get the full window title for logging
                        WinGetTitle, fullTitle, %winTitle%
                        AddLog("Found window: " fullTitle)

                        ; Send the key - remove braces for single characters/numbers
                        If (StrLen(key) = 1 && (key >= "0" && key <= "9" || key >= "a" && key <= "z" || key >= "A" && key <= "Z")) {
                            ControlSend,, %key%, %winTitle%
                        } Else {
                            ControlSend,, {%key%}, %winTitle%
                        }
                        ack := "ACK:ControlSent " key " to " fullTitle
                    }
                    Else
                    {
                        AddLog("Window '" winTitle "' not found!")
                        ack := "ERROR:Window not found: " winTitle
                    }

                    If (ClientSocket != -1)
                        AHKsock_Send(ClientSocket, &ack, StrLen(ack))
                } Else {
                    AddLog("Invalid CTRLSEND format: " command)
                }

            } Else If (SubStr(command, 1, 9) = "STUNUSED:") {
                ; Another client used a stun - update coordination
                global lastAoeCCTime, aoeCCCooldown
                stunData := SubStr(command, 10)

                ; Parse type and duration (format: AOE|duration or SINGLE|duration)
                pipePos := InStr(stunData, "|")
                if (pipePos > 0) {
                    stunType := SubStr(stunData, 1, pipePos - 1)
                    stunDuration := SubStr(stunData, pipePos + 1)

                    ; Only apply cooldown for AoE stuns
                    if (stunType = "AOE") {
                        lastAoeCCTime := A_TickCount
                        aoeCCCooldown := stunDuration
                        AddClientLog("[CC Sync] AoE stun used by another client - " . Round(stunDuration/1000, 1) . "s cooldown")
                    }
                }

            } Else If (command = "AUTOFOLLOW") {
                ; Toggle autofollow from network command
                global autofolloww, TargetGameWindow
                AddLog("[DEBUG] Processing AUTOFOLLOW command, current state: " autofolloww)
                AddLog("[DEBUG] TargetGameWindow: " TargetGameWindow)
                if (autofolloww) {
                    autofolloww := false
                    GuiControl,, StatusText, Status: Autofollow Disabled (Network)
                    AddLog("[Network] Autofollow disabled")
                } else {
                    autofolloww := true
                    GuiControl,, StatusText, Status: Autofollow Enabled (Network)
                    AddLog("[Network] Autofollow enabled")
                }
                ; Trigger follow action on this client
                AddLog("[DEBUG] Calling ReturnToMainCharacter()")
                ReturnToMainCharacter()

            } Else If (command = "CHARSELECT") {
                ; Character selection sequence
                AddLog("[Network] Processing CHARSELECT command")
                Gosub, charselectaction

            } Else If (command = "GETCOORDS") {
                ; Get coordinates by sending /info command
                global TargetGameWindow
                AddLog("[Network] Processing GETCOORDS command")

                If (TargetGameWindow != "") {
                    WinActivate, ahk_id %TargetGameWindow%
                    Sleep, 150
                    Clipboard := "/info"
                    Send, {Enter}
                    Sleep, 80
                    Send, ^v
                    Sleep, 80
                    Send, {Enter}
                    Sleep, 300
                    AddLog("Sent /info command to game window")
                } Else {
                    AddLog("No game window selected")
                }

            } Else If (SubStr(command, 1, 9) = "LOADPATH:") {
                ; Load path from network
                global SelectedRouteFile, NavSelectedRouteFile, Waypoints, TargetNodes
                pathData := SubStr(command, 10)
                AddLog("[Network] Loading path data (" StrLen(pathData) " bytes)")

                ; Decode the path content (restore newlines)
                pathData := StrReplace(pathData, "<NL>", "`n")

                ; Create a temporary INI file in the script directory
                tempPathFile := A_ScriptDir . "\temp_loaded_path.ini"
                FileDelete, %tempPathFile%
                FileAppend, %pathData%, %tempPathFile%

                If (FileExist(tempPathFile)) {
                    ; Set as the selected route file
                    SelectedRouteFile := tempPathFile
                    NavSelectedRouteFile := tempPathFile

                    ; Load waypoints and nodes using existing functions
                    LoadWaypoints()
                    LoadNodes()

                    ; Update GUI
                    SplitPath, tempPathFile, fileName
                    GuiControl,, SelectedRouteFileDisplay, %fileName%

                    waypointCount := Waypoints.Length()
                    nodeCount := TargetNodes.Length()
                    AddLog("[Network] Path loaded: " waypointCount " waypoints, " nodeCount " nodes")
                } Else {
                    AddLog("[Network] ERROR: Failed to create temp path file")
                }

            } Else If (command = "STARTHEALING") {
                ; Start healing timer
                global healCheckInterval
                AddLog("[Network] Starting healing")
                SetTimer, DynamicHealthCheck, %healCheckInterval%

            } Else If (command = "Buff") {
                ; Start buff cycle
                AddLog("[Network] Starting Buff Cycle")
                gosub, StartAllTimers

            } Else If (command = "STOPHEALING") {
                ; Stop healing timer
                AddLog("[Network] Stopping healing")
                SetTimer, DynamicHealthCheck, Off

            } Else If (command = "STARTDPS") {
                ; Start DPS timer
                AddLog("[Network] Starting DPS")
                if (healanddps) {
                    SetTimer, DynamicHealthCheck, Off
                }
                isDpsRunning := true
                SetTimer, DPSLoop, 50

            } Else If (command = "STOPDPS") {
                ; Stop DPS timer
                AddLog("[Network] Stopping DPS")
                isDpsRunning := false
                SetTimer, DPSLoop, Off

            } Else If (SubStr(command, 1, 12) = "SETUPDPSNAV:") {
                ; Setup DPS Navigation - Format: SETUPDPSNAV:radius
                global dpsNavEnabled, dpsNavTargetX, dpsNavTargetY, dpsNavRadius, currentX, currentY
                radius := SubStr(command, 13)
                AddLog("[Network] Setting up DPS Navigation with radius: " radius)

                ; Get current coordinates from screen
                GetCurrentCoordinates(currentX, currentY)
                Sleep, 10
                GetCurrentCoordinates(tempX, tempY)

                If (currentX != "" && currentY != "" && currentX == tempX && currentY == tempY) {
                    ; Set target coordinates and radius
                    dpsNavTargetX := currentX
                    dpsNavTargetY := currentY
                    dpsNavRadius := radius

                    ; Update GUI controls first
                    GuiControl,, dpsNavTargetXEdit, %currentX%
                    GuiControl,, dpsNavTargetYEdit, %currentY%
                    GuiControl,, dpsNavRadiusEdit, %radius%
                    GuiControl,, dpsNavEnabled, 1

                    ; Sync variable with GUI state
                    GuiControlGet, dpsNavEnabled

                    ; Enable navigation and start timer
                    dpsNavEnabled := true
                    SetTimer, UpdateNavCoordinatesDisplay, 500

                    AddLog("[Network] DPS Navigation enabled at X:" currentX " Y:" currentY " Radius:" radius)
                } Else {
                    AddLog("[Network] ERROR: Could not retrieve current coordinates from screen")
                }

            } Else If (command = "STARTTRAVEL") {
                ; Start navigation travel
                global SelectedRouteFile, Waypoints, IsTraveling, SingleWaypointMode, CurrentWaypoint
                AddLog("[Network] Starting travel")

                if (SelectedRouteFile = "") {
                    AddLog("[Network] ERROR: No route file selected")
                    return
                }
                waypointCount := Waypoints.Length()
                if (waypointCount = 0) {
                    AddLog("[Network] ERROR: No waypoints loaded")
                    return
                }

                ; Reset navigation state to fix reverse direction bug
                IsTraveling := false
                SetTimer, TravelLoop, Off
                SetTimer, UpdateCoordinatesDisplay, Off
                Sleep, 100

                ; Now start fresh
                IsTraveling := true
                SingleWaypointMode := false
                CurrentWaypoint := 1
                GuiControl, Disable, StartBtn
                GuiControl, Enable, StopBtn
                SetTimer, UpdateCoordinatesDisplay, 50
                SetTimer, TravelLoop, 50
                AddLog("[Network] Travel started - " waypointCount " waypoints")

            } Else If (command = "STOPTRAVEL") {
                ; Stop navigation travel
                global IsTraveling
                AddLog("[Network] Stopping travel")
                IsTraveling := false
                SetTimer, UpdateCoordinatesDisplay, off
                SetTimer, TravelLoop, Off
                ReleaseAllWASDKeys()
                GuiControl, Enable, StartBtn
                GuiControl, Disable, StopBtn
                GuiControl,, RouteStatus, Travel stopped
                AddLog("[Network] Travel stopped")

            } Else If (SubStr(command, 1, 5) = "CALL:") {
                ; Format: CALL:FunctionName OR CALL:FunctionName(param1,param2)
                funcCall := SubStr(command, 6)
                AddLog("Calling function: " funcCall " [v5]")

                ; Parse function name and parameters
                If (InStr(funcCall, "(")) {
                    ; Has parameters - extract function name and params
                    funcName := SubStr(funcCall, 1, InStr(funcCall, "(") - 1)
                    ; Extract parameters from between ( and )
                    paramStart := InStr(funcCall, "(") + 1
                    paramEnd := InStr(funcCall, ")", , -1) ; Find last )
                    paramString := SubStr(funcCall, paramStart, paramEnd - paramStart)

                    ; Split parameters by comma
                    params := StrSplit(paramString, ",")

                    ; Trim whitespace from each parameter
                    For index, param in params {
                        params[index] := Trim(param)
                    }
                } Else {
                    funcName := funcCall
                    params := []
                }

                funcObj := Func(funcName)

                If (!funcObj) {
                    AddLog("ERROR: Function '" funcName "' not found [v5]")
                    ack := "ERROR:Function not found: " funcName
                } Else {
                    Try {
                        ; Call the function with parameters
                        If (params.Length() = 0) {
                            result := funcObj.Call()
                        } Else If (params.Length() = 1) {
                            result := funcObj.Call(params[1])
                        } Else If (params.Length() = 2) {
                            result := funcObj.Call(params[1], params[2])
                        } Else If (params.Length() = 3) {
                            result := funcObj.Call(params[1], params[2], params[3])
                        } Else {
                            result := funcObj.Call(params[1], params[2], params[3], params[4])
                        }

                        ack := "ACK:Called " funcCall

                        If (result = true || result = 1) {
                            AddLog("SUCCESS: Function returned true [v5]")
                        } Else If (result = false || result = 0) {
                            AddLog("INFO: Function returned false [v5]")
                        } Else If (result != "") {
                            AddLog("SUCCESS: Function returned: " result " [v5]")
                        } Else {
                            AddLog("SUCCESS: Function completed [v5]")
                        }
                    } Catch e {
                        errorMsg := (e.Message != "") ? e.Message : (e.What != "") ? e.What : "Unknown error"
                        errorExtra := (e.Extra != "") ? " | Extra: " e.Extra : ""
                        errorLine := (e.Line != "") ? " | Line: " e.Line : ""
                            AddLog("ERROR executing function: " errorMsg errorExtra errorLine " [v5]")
                            ack := "ERROR:Execution failed - " errorMsg
                        }
                    }

                    If (ClientSocket != -1) {
                        VarSetCapacity(ackBuffer, StrLen(ack), 0)
                        StrPut(ack, &ackBuffer, "CP0")
                        AHKsock_Send(ClientSocket, &ackBuffer, StrLen(ack))
                    }

                } Else {
                    AddLog("Unknown command: " command)
                    AddLog("[DEBUG] No matching command handler for: '" command "'")
                }
            }

            AttemptReconnect:
                ; Stop timer first
                SetTimer, AttemptReconnect, Off

                ; Only reconnect if not already connected
                If (Connected) {
                    Return
                }

                ; Check if auto-reconnect is still enabled
                GuiControlGet, AutoReconnect,, chkAutoReconnect
                If (!AutoReconnect) {
                    Return
                }

                AddClientLog("Attempting to reconnect to " LastServerAddress ":" LastServerPort "...")

                ; Try to connect
                If (i := AHKsock_Connect(LastServerAddress, LastServerPort, "ClientEvents")) {
                    AddClientLog("Reconnect failed - will retry in 15 seconds")
                    ; Restart timer for next attempt
                    SetTimer, AttemptReconnect, 15000
                } Else {
                    AddClientLog("Reconnecting...")
                }

